% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\title{R avancé}
\author{Sébastien Déjean et Thibault Laurent}
\date{2021-10-15}

\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={R avancé},
  pdfauthor={Sébastien Déjean et Thibault Laurent},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabu}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage{makecell}
\usepackage{xcolor}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{plainnat}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{corollary}{Corollary}[chapter]
\newtheorem{proposition}{Proposition}[chapter]
\newtheorem{conjecture}{Conjecture}[chapter]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\theoremstyle{definition}
\newtheorem{example}{Example}[chapter]
\theoremstyle{definition}
\newtheorem{exercise}{Exercise}[chapter]
\theoremstyle{definition}
\newtheorem{hypothesis}{Hypothesis}[chapter]
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{solution}{Solution}
\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{introduction}{%
\chapter{Introduction}\label{introduction}}

\hypertarget{principe-du-document}{%
\section{Principe du document}\label{principe-du-document}}

Ce document fait suite aux documents suivants :

\begin{itemize}
\item
  \emph{Pour se donner un peu d'\textbf{R}} disponible \href{https://www.math.univ-toulouse.fr/~sdejean/PDF/un-peu-d-R.pdf}{ici}
\item
  \emph{Introduction à \textbf{R}} disponible \href{http://www.thibault.laurent.free.fr/cours/R_intro/}{ici}
\end{itemize}

Il contient des commandes à saisir, des commentaires pour attirer l'attention sur des points particuliers et quelques questions/réponses pour tester la compréhension des notions présentées. Pour certains points particuliers, nécessitant par exemple un environnement logiciel particulier, les faits ne sont que mentionnés et il n'y a pas toujours de mise en oeuvre pratique.

\hypertarget{pruxe9-requis}{%
\section{Pré-requis}\label{pruxe9-requis}}

Même si la plupart des points abordés dans ce document ne sont pas très compliqués, ils relèvent d'une utilisation avancée de \textbf{R} et ne s'adressent donc pas au débutant en \textbf{R}. Avant d'utiliser ce document, le lecteur doit notamment savoir :

\begin{itemize}
\item
  se servir de l'aide en ligne de \textbf{R},
\item
  manipuler les objets de base de \textbf{R} : vecteur, matrice, liste, \textbf{data.frame},
\item
  programmer une fonction élémentaire.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bookdown}\SpecialCharTok{::}\FunctionTok{serve\_book}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{manipulation-de-donnuxe9es-avec-r}{%
\chapter{\texorpdfstring{Manipulation de données avec \textbf{R}}{Manipulation de données avec R}}\label{manipulation-de-donnuxe9es-avec-r}}

Packages à installer pour ce chapitre

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\FunctionTok{c}\NormalTok{(}
  \CommentTok{\# import data:}
  \StringTok{"foreign"}\NormalTok{, }\StringTok{"jsonlite"}\NormalTok{, }\StringTok{"readr"}\NormalTok{, }\StringTok{"readxl"}\NormalTok{, }\StringTok{"sas7bdat"}\NormalTok{, }\StringTok{"XML"}\NormalTok{, }
  \CommentTok{\# big data analysis}
  \StringTok{"data.table"}\NormalTok{, }\StringTok{"ff"}\NormalTok{, }\StringTok{"ffbase"}\NormalTok{, }
  \CommentTok{\# matrices creuses}
  \StringTok{"Marix"}\NormalTok{, }
  \CommentTok{\# character treatment}
  \StringTok{"classInt"}\NormalTok{, }\StringTok{"glue"}\NormalTok{, }\StringTok{"stringr"}\NormalTok{, }\StringTok{"wordcloud"}\NormalTok{, }
  \StringTok{"gplots"}\NormalTok{, }\CommentTok{\# plotting data with ggplot2 style}
  \StringTok{"tidyverse"}\NormalTok{, }\StringTok{"DSR"}\NormalTok{, }\CommentTok{\# Data Scientists toolkits}
  \StringTok{"Amelia"}\NormalTok{, }\StringTok{"DMwR"}\NormalTok{, }\StringTok{"missForest"}\NormalTok{, }\StringTok{"naniar"}\NormalTok{,  }\CommentTok{\# missing values treatement}
  \StringTok{"sp"}\NormalTok{, }\StringTok{"sf"}\NormalTok{, }\CommentTok{\# spatial data object}
  \StringTok{"zoo"}\NormalTok{)  }\CommentTok{\# Time series analysis}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{les-chauxeenes-de-caractuxe8res}{%
\section{Les chaînes de caractères}\label{les-chauxeenes-de-caractuxe8res}}

\hypertarget{fonctions-de-base}{%
\subsection{Fonctions de base}\label{fonctions-de-base}}

On considère la chaîne de caractère suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{phrase }\OtherTok{\textless{}{-}} \StringTok{"Notes obtenues}\SpecialCharTok{\textbackslash{}n}\StringTok{anglais: 16, Stat:14, Eco=18"}
\FunctionTok{class}\NormalTok{(phrase)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

Parmi les fonctions qui permettent de manipuler les chaînes de caractères, voici celles qui nous semblent importantes de connaître :

\hypertarget{nchar}{%
\subsubsection{\texorpdfstring{\emph{nchar()}}{nchar()}}\label{nchar}}

Permet de compter le nombre de caractères de chaque élément d'un vecteur :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nchar}\NormalTok{(phrase)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 43
\end{verbatim}

\hypertarget{substr}{%
\subsubsection{\texorpdfstring{\emph{substr()}}{substr()}}\label{substr}}

Permet d'extraire un sous-ensemble de caractères :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{substr}\NormalTok{(phrase, }\AttributeTok{start =} \DecValTok{1}\NormalTok{, }\AttributeTok{stop =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Notes"
\end{verbatim}

\hypertarget{strsplit}{%
\subsubsection{\texorpdfstring{\emph{strsplit()}}{strsplit()}}\label{strsplit}}

Permet d'éclater une chaîne de caractères dès qu'on trouve une sous-chaîne particulière :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{strsplit}\NormalTok{(phrase, }\AttributeTok{split =} \StringTok{" "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "Notes"              "obtenues\nanglais:" "16,"               
## [4] "Stat:14,"           "Eco=18"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{strsplit}\NormalTok{(phrase, }\AttributeTok{split =} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "Notes obtenues"               "anglais: 16, Stat:14, Eco=18"
\end{verbatim}

\textbf{Remarque 1 :} un espace est considéré comme une chaîne de caractère.

\textbf{Remarque 2 :} ``\textbackslash n'' est un caractère spécial qui correspond à un saut de ligne (pour consulter la liste des caractères spéciaux, voir cette \href{http://help.stonesoft.com/onlinehelp/StoneGate/SMC/5.3.6/SGAG/SG_RegularExpressions/Special_Character_Sequences.htm}{page web}). Pour évaluer un caractère spécial dans une chaîne de caractère, on peut utiliser la fonction \emph{cat()}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(phrase)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Notes obtenues
## anglais: 16, Stat:14, Eco=18
\end{verbatim}

\textbf{Remarque 3 :} l'objet retourné est de type \textbf{list}. Pour convertir une \textbf{list} en un vecteur, sur lequel il est plus facile de faire de la manipulation, on utilise la fonction \emph{unlist()}. Enfin, si on veut éclater une chaîne de caractère en fonction de plusieurs caractères, on utilise le symbole \textbar. Dans l'exemple suivant, l'idée est de séparer tous les mots en présence d'un des caractères spéciaux :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(mots }\OtherTok{\textless{}{-}} \FunctionTok{strsplit}\NormalTok{(phrase, }\AttributeTok{split =} \StringTok{",|}\SpecialCharTok{\textbackslash{}n}\StringTok{| |:|="}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##  [1] "Notes"    "obtenues" "anglais"  ""         "16"       ""        
##  [7] "Stat"     "14"       ""         "Eco"      "18"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(mots }\OtherTok{\textless{}{-}} \FunctionTok{unlist}\NormalTok{(mots))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Notes"    "obtenues" "anglais"  ""         "16"       ""        
##  [7] "Stat"     "14"       ""         "Eco"      "18"
\end{verbatim}

Si on utilise le type \textbf{NULL} comme critère de recherche, cela a pour effet d'éclater tous les éléments de la chaîne de caractères en des caractères uniques :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(lettres }\OtherTok{\textless{}{-}} \FunctionTok{strsplit}\NormalTok{(phrase, }\AttributeTok{split =} \ConstantTok{NULL}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##  [1] "N"  "o"  "t"  "e"  "s"  " "  "o"  "b"  "t"  "e"  "n"  "u"  "e"  "s"  "\n"
## [16] "a"  "n"  "g"  "l"  "a"  "i"  "s"  ":"  " "  "1"  "6"  ","  " "  "S"  "t" 
## [31] "a"  "t"  ":"  "1"  "4"  ","  " "  "E"  "c"  "o"  "="  "1"  "8"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(lettres[[}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 43
\end{verbatim}

\textbf{Remarque :} dans le contexte d'une étude statistique, on appliquera cette fonction à des vecteurs de caractère. Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{strsplit}\NormalTok{(mots, }\AttributeTok{split =} \StringTok{":"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "Notes"
## 
## [[2]]
## [1] "obtenues"
## 
## [[3]]
## [1] "anglais"
## 
## [[4]]
## character(0)
## 
## [[5]]
## [1] "16"
## 
## [[6]]
## character(0)
## 
## [[7]]
## [1] "Stat"
## 
## [[8]]
## [1] "14"
## 
## [[9]]
## character(0)
## 
## [[10]]
## [1] "Eco"
## 
## [[11]]
## [1] "18"
\end{verbatim}

\hypertarget{toupper-tolower}{%
\subsubsection{\texorpdfstring{\emph{toupper()}, \emph{tolower()}}{toupper(), tolower()}}\label{toupper-tolower}}

Pemettent de convertir toutes les lettres en majuscules et minuscules :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{toupper}\NormalTok{(phrase)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "NOTES OBTENUES\nANGLAIS: 16, STAT:14, ECO=18"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tolower}\NormalTok{(}\StringTok{"AAA"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "aaa"
\end{verbatim}

\hypertarget{grep}{%
\subsubsection{\texorpdfstring{\emph{grep()}}{grep()}}\label{grep}}

Permet de trouver dans un vecteur de caractères quels sont les indices des composantes du vecteur qui contiennent un ensemble de caractères. Par exemple quels sont les mots qui contiennent la lettre ``e'' :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(res }\OtherTok{\textless{}{-}} \FunctionTok{grep}\NormalTok{(}\AttributeTok{pattern =} \StringTok{"e"}\NormalTok{, }\AttributeTok{x =}\NormalTok{ mots))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mots[res]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Notes"    "obtenues"
\end{verbatim}

On peut chercher plusieurs lettres à la fois. Ici, on cherche les mots qui contiennent une des lettres ``j'', ``J'' et ``t''. Pour cela, on utilise une expression régulière grâce aux crochets (nous verrons dans la section suivante plus en détail le fonctionnement des expressions régulières) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(res }\OtherTok{\textless{}{-}} \FunctionTok{grep}\NormalTok{(}\AttributeTok{pattern =} \StringTok{"[jSE]"}\NormalTok{, }\AttributeTok{x =}\NormalTok{ mots))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  7 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mots[res]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Stat" "Eco"
\end{verbatim}

\textbf{Remarque :} un vecteur de taille nulle est retourné si le critère n'est pas satisfait.

\hypertarget{agrep}{%
\subsubsection{\texorpdfstring{\emph{agrep()}}{agrep()}}\label{agrep}}

Pemet de trouver dans un vecteur de caractères quels sont les indices des composantes du vecteur qui contiennent ``approximativement'' une sous-chaîne, l'approximation pouvant être réglée avec les options de la fonction. Dans l'exemple suivant, la lettre s minuscule est différente de S majuscule, mais cette différence d'1 caractère sera tolérée.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{agrep}\NormalTok{(}\StringTok{"stat"}\NormalTok{, mots)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
\end{verbatim}

\textbf{Remarque :} lorsqu'on traite des fichiers de données brutes, ce fichier peut contenir des erreurs de saisie, par exemple ``Toulouze'' au lieu de ``Toulouse'' et c'est pourquoi le fait de tolérer un nombre de différences peut s'avérer intéressant.

\begin{itemize}
\tightlist
\item
  \emph{sub()} pour changer une sous-chaîne de caractères par une autre :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(mots }\OtherTok{\textless{}{-}} \FunctionTok{sub}\NormalTok{(}\AttributeTok{pattern =} \StringTok{"="}\NormalTok{, }\AttributeTok{replacement =} \StringTok{":"}\NormalTok{, }\AttributeTok{x =}\NormalTok{ phrase))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Notes obtenues\nanglais: 16, Stat:14, Eco:18"
\end{verbatim}

\hypertarget{regexpr}{%
\subsubsection{\texorpdfstring{\emph{regexpr()}}{regexpr()}}\label{regexpr}}

Permet de dire à quelle position dans le mot se trouve une sous-chaîne de caractères. Dans l'exemple suivant, on cherche à savoir où se trouve le caractère ``:'' dans les mots. Si un caractère est présent, alors la fonction retourne les positions de la lettre ``:'' et si elle n'apparaît pas, la valeur -1 est retournée. Le résultat est encore donné sous forme de \textbf{list} car cela permet de traiter chaque mot du vecteur.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gregexpr}\NormalTok{(}\AttributeTok{pattern =} \StringTok{":"}\NormalTok{, }\AttributeTok{text =}\NormalTok{ mots, }\AttributeTok{ignore.case =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{Compléments :} en pratique, on peut vouloir faire des recherches plus complexes (plusieurs caractères, des caractères spéciaux, etc), ce qui nécessite une adaptation dans les critères de recherche. La gestion des chaînes de caractères est synthétisée dans l'aide suivante :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{help}\NormalTok{(regexp)}
\end{Highlighting}
\end{Shaded}

\hypertarget{abbreviate}{%
\subsubsection{\texorpdfstring{\emph{abbreviate()}}{abbreviate()}}\label{abbreviate}}

Pemet de faire des abbréviations de chaînes de caratères trop longue, tout en respectant l'unicité de chaque mot (autement dit, une même abbréviation ne peut pas être donnée à deux mots différents). Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pays }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Bosnie{-}Herzégovine"}\NormalTok{, }\StringTok{"Burkina Faso"}\NormalTok{,  }\StringTok{"Côte d\textquotesingle{}Ivoire"}\NormalTok{)}
\FunctionTok{abbreviate}\NormalTok{(pays)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in abbreviate(pays): abbreviate utilisé avec des caractères non ASCII
\end{verbatim}

\begin{verbatim}
## Bosnie-Herzégovine       Burkina Faso      Côte d'Ivoire 
##             "Bs-H"             "BrkF"             "Cd'I"
\end{verbatim}

\textbf{Exercice 1.1}

\textbf{Q1} Compter le nombre de caractères de chaque élément du vecteur suivant. Que constatez-vous ?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_with\_missing }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"oui"}\NormalTok{, }\StringTok{"peut{-}être"}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\StringTok{"non"}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\StringTok{"si"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{Q2} Dans le vecteur suivant, faire l'extraction des deux entiers qui se trouvent entre le symbole \textbf{\_} et présenter le résultat sous forme de vecteur :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{code\_INSEE }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"toulouse\_31\_HG"}\NormalTok{, }\StringTok{"lyon\_69\_Rhone"}\NormalTok{,}
                \StringTok{"marsei\_13\_PACA"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{les-expressions-ruxe9guliuxe8res}{%
\subsection{Les expressions régulières}\label{les-expressions-ruxe9guliuxe8res}}

Ce paragraphe s'inspire de cette \href{http://eric.univ-lyon2.fr/~ricco/cours/slides/TM.E\%20-\%20expressions\%20regulieres.pdf}{note de cours} écrite par Ricco Rakotomalala.

On va s'attarder sur l'utilisation d'expressions régulières qui est très populaire dans certaines disciplines et notamment le text mining qui englobe l'analyse de tweets.

\hypertarget{duxe9finition}{%
\subsubsection{Définition}\label{duxe9finition}}

Une expression régulière est une séquence de caractères qui définit un motif d'intérêt. Par exemple, on considère le motif d'intérêt ``b.b.'', une séquence de 4 caractères où le 1er et 3ème caractères sont le caractère ``b'' et le 2ème et 4ème peuvent être n'importe quel autre caractère tel que ``bobi'', ``buba'', ``bib1'', ``bpbe'', ``byb='', etc.

On pourrait considérer un second motif d'intérêt ``b.b.'', une séquence de 4 caractères où le 1er et 3ème caractère sont le caractère ``b'' et le 2ème et 4ème peuvent être une voyelle uniquement. Dans ce cas, ``bybe'' serait un candidat, mais pas ``bib1''.

Une expression régulière correspond donc à la syntaxe informatique qui sera utilisée pour détecter un motif d'intérêt.

\hypertarget{exemples}{%
\paragraph{Exemples}\label{exemples}}

Par défaut, les fonctions \emph{strsplit()}, \emph{grep()}, \emph{sub()} ou \emph{regexpr()} permettent d'utiliser une expression régulière comme critère de recherche. Par exemple, pour identifier le 1er motif d'intérêt, l'expression régulière est la suivante ``b.b.'' où le ``.'' indique donc que n'importe quel caractère est accepté

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{textes }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"bobi"}\NormalTok{, }\StringTok{"bibé"}\NormalTok{, }\StringTok{"tatane"}\NormalTok{, }\StringTok{"bAbA"}\NormalTok{, }\StringTok{"tbtc"}\NormalTok{,}
            \StringTok{"tut"}\NormalTok{, }\StringTok{"byb="}\NormalTok{, }\StringTok{"baba"}\NormalTok{, }\StringTok{"bub1"}\NormalTok{, }\StringTok{"t5t3"}\NormalTok{)}
\FunctionTok{print}\NormalTok{(}\FunctionTok{grep}\NormalTok{(}\StringTok{"b.b."}\NormalTok{, textes))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 4 7 8 9
\end{verbatim}

Pour le second motif d'intérêt, on va utiliser l'expression régulière suivante :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\FunctionTok{grep}\NormalTok{(}\StringTok{"b[aeiouy]b[aeiouy]"}\NormalTok{, textes))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 8
\end{verbatim}

On met entre crochets les caractères qui sont autorisés.

La négation des caractères autorisés est obtenue avec le symbole ``\^{}''. Par exemple, dans l'exemple suivant, on autorise tous les caractères sauf les voyelles :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\FunctionTok{grep}\NormalTok{(}\StringTok{"b[\^{}aeiouy]b[\^{}aeiouy]"}\NormalTok{, textes))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

Pour autoriser une suite de caractères, on utilise le symbole ``-''. Par exemple, si on autorise uniquement les lettres minuscules de l'alphabet, on fait:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\FunctionTok{grep}\NormalTok{(}\StringTok{"b[a{-}z]b[a{-}z]"}\NormalTok{, textes))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 8
\end{verbatim}

Si on autorise toutes les lettres de l'alphabet (minuscules et majuscules ainsi que les caractères spéciaux comme les accents é, à, è, ç, etc.), on utilise la syntaxe ``{[}:alpha:{]}'' entre crochets. Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\FunctionTok{grep}\NormalTok{(}\StringTok{"b[[:alpha:]]b[[:alpha:]]"}\NormalTok{, textes))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 4 8
\end{verbatim}

Si on utilise toutes les lettres de l'alphabet ainsi que les chiffre numériques, on utilise la syntaxe ``{[}:alnum:{]}'' entre crochets. Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\FunctionTok{grep}\NormalTok{(}\StringTok{"b[[:alnum:]]b[[:alnum:]]"}\NormalTok{, textes))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 4 8 9
\end{verbatim}

\hypertarget{les-autres-expressions-ruxe9guliuxe8res}{%
\subsubsection{Les autres expressions régulières}\label{les-autres-expressions-ruxe9guliuxe8res}}

Nous avons résumé différentes expressions régulières pouvant être utilisées :

\begin{itemize}
\tightlist
\item
  {[}\ldots{]} : un des caractères indiqués entre les crochets. Par exemple:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\FunctionTok{grep}\NormalTok{(}\StringTok{"t[aeiouy]t[aeiouy]"}\NormalTok{, textes))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{itemize}
\tightlist
\item
  {[}\^{}...{]} : tous les caractères sauf ceux indiqués après le \^{}. Par exemple:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\FunctionTok{grep}\NormalTok{(}\StringTok{"t[\^{}aeiouy]t[\^{}aeiouy]"}\NormalTok{, textes))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  5 10
\end{verbatim}

\begin{itemize}
\tightlist
\item
  {[}x-y{]} : les caractères compris entre x à y inclus. Par exemple :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\FunctionTok{grep}\NormalTok{(}\StringTok{"t[a{-}z]t[a{-}z]"}\NormalTok{, textes))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 5
\end{verbatim}

\begin{itemize}
\item
  {[}:alnum:{]} équivalent à a-zA-Z0-9 avec en plus les caractères spéciaux que l'on retrouve suivant les langues utilisées comme les é, è, ù, ç, à.
\item
  {[}:alpha:{]} équivalent à a-zA-Z avec en plus les caractères spéciaux que l'on retrouve suivant les langues utilisées
\item
  {[}:digit:{]} équivalent à 0-9. Par exemple :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\FunctionTok{grep}\NormalTok{(}\StringTok{"t[[:digit:]]t[[:digit:]]"}\NormalTok{, textes))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10
\end{verbatim}

\begin{itemize}
\item
  {[}:lower:{]} équivalent à a-z avec en plus les caractères spéciaux que l'on retrouve suivant les langues utilisées
\item
  {[}:upper:{]} équivalent à A-Z avec en plus les caractères spéciaux que l'on retrouve suivant les langues utilisées comme les Â, Û, Ô, etc.
\item
  {[}:xdigit:{]} équivalent à 0-9a-fA-F
\item
  {[}:graph:{]} tout caractère graphique
\item
  {[}:print:{]} tout caractère affichable
\item
  {[}:punct:{]} tout caractère de ponctuation
\item
  {[}:blank:{]} espace, tabulation
\item
  {[}:space:{]} espace, tabulation, nouvelle ligne, retour chariot
\item
  {[}:cntrl:{]} tout caractère de contrôle
\end{itemize}

\textbf{Exercice 1.2}:

On considère la chaîne de caractère suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ww }\OtherTok{\textless{}{-}} \StringTok{"we went to warwick 5 times"}
\end{Highlighting}
\end{Shaded}

Avec la fonction \emph{gregexpr()}, trouver les expressions régulières qui permettent de donner l'emplacement de :

\begin{itemize}
\tightlist
\item
  la chaîne de caractères ``i''
\item
  un chiffre numérique
\item
  la chaîne de caractères ``we''
\item
  une des deux chaînes de caractères ``w'' ou ``e''
\item
  un pattern commençant par un espace suivi de la chaîne ``w''.
\end{itemize}

\hypertarget{application-aux-tweets}{%
\subsection{Application aux tweets}\label{application-aux-tweets}}

On considère le vecteur suivant dont les éléments correspondent à des extraits de tweets

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tweet }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"TopStartupsUSA: RT @FernandoX: 7 C\textquotesingle{}s of Marketing in the Digital Era.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }
  \StringTok{"\#Analytics \#MachineLearning \#DataScience \#MalWare \#IIoT"}\NormalTok{, }
  \StringTok{"YvesMulkers: RT @wil\_bielert: RT @neptanum: Standard Model Physics from an Algebra?"}\NormalTok{, }
  \StringTok{"\#BigData \#Analytics \#DataScience \#AI \#MachineLearning \#IoT \#IIoT \#Python"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{Exercice 1.3.}

Expliquer la fonction de chacune des expressions régulières suivantes

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{correct }\OtherTok{\textless{}{-}} \FunctionTok{gsub}\NormalTok{(}\StringTok{"(RT|via)((?:}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{b}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{W*@}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{w+)+)"}\NormalTok{, }\StringTok{""}\NormalTok{, tweet)}
\NormalTok{correct }\OtherTok{\textless{}{-}} \FunctionTok{gsub}\NormalTok{(}\StringTok{"@}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{w+"}\NormalTok{, }\StringTok{""}\NormalTok{, correct)}
\NormalTok{correct }\OtherTok{\textless{}{-}} \FunctionTok{gsub}\NormalTok{(}\StringTok{"[[:punct:]]"}\NormalTok{, }\StringTok{""}\NormalTok{, correct)}
\NormalTok{correct }\OtherTok{\textless{}{-}} \FunctionTok{gsub}\NormalTok{(}\StringTok{"[[:digit:]]"}\NormalTok{, }\StringTok{""}\NormalTok{, correct)}
\NormalTok{correct }\OtherTok{\textless{}{-}} \FunctionTok{gsub}\NormalTok{(}\StringTok{"http}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{w+"}\NormalTok{, }\StringTok{""}\NormalTok{, correct)}
\NormalTok{correct }\OtherTok{\textless{}{-}} \FunctionTok{gsub}\NormalTok{(}\StringTok{"[}\SpecialCharTok{\textbackslash{}t}\StringTok{ ]\{2,\}"}\NormalTok{, }\StringTok{" "}\NormalTok{, correct)}
\NormalTok{correct }\OtherTok{\textless{}{-}} \FunctionTok{gsub}\NormalTok{(}\StringTok{"\^{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s+|}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{s+$"}\NormalTok{, }\StringTok{""}\NormalTok{, correct)}
\NormalTok{correct }\OtherTok{\textless{}{-}} \FunctionTok{iconv}\NormalTok{(correct, }\StringTok{"UTF{-}8"}\NormalTok{, }\StringTok{"ASCII"}\NormalTok{, }\AttributeTok{sub =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{nuage-de-mots}{%
\subsection{Nuage de mots}\label{nuage-de-mots}}

On présente ici la fonction \emph{wordcloud()} du package \textbf{wordcloud} qui permet de représenter un nuage de mots en fonctions du nombre d'occurences des mots trouvés dans un corps de texte.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{word }\OtherTok{\textless{}{-}} \FunctionTok{unlist}\NormalTok{(}\FunctionTok{strsplit}\NormalTok{(correct, }\StringTok{" "}\NormalTok{))}
\NormalTok{tab\_word }\OtherTok{\textless{}{-}} \FunctionTok{table}\NormalTok{(word)}
\FunctionTok{require}\NormalTok{(}\StringTok{"wordcloud"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Le chargement a nécessité le package : wordcloud
\end{verbatim}

\begin{verbatim}
## Le chargement a nécessité le package : RColorBrewer
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{wordcloud}\NormalTok{(}\FunctionTok{names}\NormalTok{(tab\_word), tab\_word)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-35-1.pdf}

\hypertarget{ordonnancement}{%
\subsection{Ordonnancement}\label{ordonnancement}}

Les caractères peuvent s'ordonner comme on le fait avec des chiffres. Par exemple, le caratère ``a'' est plus petit que ``b'' qui n'est pas plus grand que ``c''. Pour le vérifier :

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"a"} \SpecialCharTok{\textless{}} \StringTok{"b"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"b"} \SpecialCharTok{\textgreater{}} \StringTok{"c"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

On s'intéresse ici plus particulièrement aux règles d'ordonnancement utilisées pour la langue française. Selon la langue utilisée par la machine, il existe donc des règles particulières pour ordonnancer les chaînes de caractères, qui diffèrent d'une langue à l'autre. Pour vérifier la langue utilisée par la machine, on peut utiliser la commande

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Sys.setlocale}\NormalTok{(}\AttributeTok{category =} \StringTok{"LC\_CTYPE"}\NormalTok{, }\AttributeTok{locale =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "fr_FR.UTF-8"
\end{verbatim}

Considérons la citation suivante stockée dans l'objet \textbf{citation} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{citation }\OtherTok{\textless{}{-}} \StringTok{"Il est important que les étudiants portent un regard neuf }
\StringTok{et irrévérencieux  sur leurs études ; il ne doivent pas vénérer le savoir }
\StringTok{mais le remettre en question (chapitre : 1 {-} paragraphe : 2 {-} ligne : 10 }
\StringTok{{-} page : 185. Jacob Chanowski)."}
\end{Highlighting}
\end{Shaded}

On peut récupérer chaque ``mot'' (entités séparées par des espaces'') par la commande :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(mots }\OtherTok{\textless{}{-}} \FunctionTok{unlist}\NormalTok{(}\FunctionTok{strsplit}\NormalTok{(citation, }\AttributeTok{split =} \StringTok{" "}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Il"             "est"            "important"      "que"           
##  [5] "les"            "étudiants"      "portent"        "un"            
##  [9] "regard"         "neuf"           "\net"           "irrévérencieux"
## [13] ""               "sur"            "leurs"          "études"        
## [17] ";"              "il"             "ne"             "doivent"       
## [21] "pas"            "vénérer"        "le"             "savoir"        
## [25] "\nmais"         "le"             "remettre"       "en"            
## [29] "question"       "(chapitre"      ":"              "1"             
## [33] "-"              "paragraphe"     ":"              "2"             
## [37] "-"              "ligne"          ":"              "10"            
## [41] "\n-"            "page"           ":"              "185."          
## [45] "Jacob"          "Chanowski)."
\end{verbatim}

Le tri des éléments (uniques) du vecteur \textbf{mots} nous montre les règles d'ordonnancement appliquées par \textbf{R}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sort}\NormalTok{(}\FunctionTok{unique}\NormalTok{(mots))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] ""               "\n-"            "\net"           "\nmais"        
##  [5] "-"              ";"              ":"              "(chapitre"     
##  [9] "1"              "10"             "185."           "2"             
## [13] "Chanowski)."    "doivent"        "en"             "est"           
## [17] "études"         "étudiants"      "il"             "Il"            
## [21] "important"      "irrévérencieux" "Jacob"          "le"            
## [25] "les"            "leurs"          "ligne"          "ne"            
## [29] "neuf"           "page"           "paragraphe"     "pas"           
## [33] "portent"        "que"            "question"       "regard"        
## [37] "remettre"       "savoir"         "sur"            "un"            
## [41] "vénérer"
\end{verbatim}

\begin{itemize}
\item
  les caractères spéciaux \textbf{-}, \textbf{:}, \textbf{;}, \textbf{(}, etc. sont prioritaires sur les chiffres et les lettres.
\item
  les chiffres sont prioritaires sur les lettres.
\item
  les mots sont ordonnancés comme dans un dictionnaire français.
\item
  quand il y a des lettres avec des accents, on ordonnance comme s'il n'y avait pas d'accents.
\item
  les lettres majuscules sont insérées dans l'ordre alphabétique et ne sont pas prioritaires par rapport aux lettres minuscules.
\item
  la syntaxe \emph{``\textbackslash n''} n'est pas comptabilisée.
\item
  les chiffres ne sont pas regardés comme des chiffres mais comme une chaîne de caractères. Autrement dit ``10'' doit être vu comme un mot avec 2 caractères consécutifs : ``1'', puis ``0''. ``2'' doit être vu comme 1 mot avec un seul caractère. Pour comparer ces 2 mots, on compare les caractères entre eux les uns après les autres. Dans un premier temps, on regarde le 1er caractère de chaque mot : ``1'' est plus petit que ``2''. Aussi, quelque soit le nombre de caractère qu'on va ajouter après ``1'' ce mot sera plus petit que ``2''. Par exemple ``15552525'' sera plus petit que ``2''.
\end{itemize}

\textbf{Exercice 1.4.}

A partir du jeu de données \textbf{USArrests}, extraire les lignes dont le nom contient la chaîne de caractères ``New''. Vous pouvez vous inspirer des instructions suivantes. Dans le premier cas, tous les noms de lignes contenant la lettre \textbf{C} sont renvoyés ; dans le second cas, seuls ceux commencant par \textbf{C} sont renvoyés. Consulter la fiche d'aide sur les expressions régulières pour en savoir (beaucoup !) plus (\textbf{help(regexp)}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{USArrests[}\FunctionTok{grep}\NormalTok{(}\StringTok{"C"}\NormalTok{, }\FunctionTok{rownames}\NormalTok{(USArrests)),]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                Murder Assault UrbanPop Rape
## California        9.0     276       91 40.6
## Colorado          7.9     204       78 38.7
## Connecticut       3.3     110       77 11.1
## North Carolina   13.0     337       45 16.1
## South Carolina   14.4     279       48 22.5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{USArrests[}\FunctionTok{grep}\NormalTok{(}\StringTok{"\^{}C"}\NormalTok{, }\FunctionTok{rownames}\NormalTok{(USArrests)),]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             Murder Assault UrbanPop Rape
## California     9.0     276       91 40.6
## Colorado       7.9     204       78 38.7
## Connecticut    3.3     110       77 11.1
\end{verbatim}

\hypertarget{package-stringr}{%
\subsection{\texorpdfstring{Package \textbf{stringr}}{Package stringr}}\label{package-stringr}}

On a vu ci-dessus les fonctions de base pour manipuler des chaînes de caractères. Toutefois, si on cherche à faire des statistiques un plus poussées sur les chaînes de caractères, on va devoir avoir recours aux fonctions \emph{sapply()} ou \emph{lapply()} qui permettent de faire des opérations sur les listes. Par exemple, on cherche à calculer le nombre de fois qu'apparaît la lettre ``a'' dans le vecteur \textbf{mots} précédent. Pour cela, on va appliquer la fonction \emph{sapply()} (dont nous reparlerons plus tard) sur le résultat donné par la fonction \emph{gregexpr()}. On rappelle que le résultat de cette fonction est -1 si le caractère n'a pas été trouvé et sinon, il retourne le vecteur des positions. Pour répondre à notre problème, on exécute donc le code suivant :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res1 }\OtherTok{\textless{}{-}} \FunctionTok{gregexpr}\NormalTok{(}\AttributeTok{pattern =} \StringTok{"a"}\NormalTok{, }\AttributeTok{text =}\NormalTok{ mots, }\AttributeTok{ignore.case =}\NormalTok{ T)}
\FunctionTok{sapply}\NormalTok{(res1, }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{ifelse}\NormalTok{(x[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\FunctionTok{length}\NormalTok{(x), }\DecValTok{0}\NormalTok{)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 1 0 0 0 3 0 0 0 0
## [39] 0 0 0 1 0 0 1 1
\end{verbatim}

Le package \textbf{stringr} a vu le jour dans le but d'effacer certaines lacunes des fonctions de base et également simplifier la syntaxe des fonctions de base. Adopter les fonctions de ces packages revient un peu à oublier la syntaxe des fonctions que nous avons vues. Par exemple, la fonction \emph{str\_c()} est plus ou moins équivalente à la fonction \emph{paste()}, la fonction \emph{str\_length()} est équivalent à la fonction \emph{nchar()}. La fonction \emph{str\_count()} retourne le même résultat précédent en 1 seul ligne de commande :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"stringr"}\NormalTok{)}
\FunctionTok{str\_count}\NormalTok{(mots, }\StringTok{"a"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 1 0 0 0 3 0 0 0 0
## [39] 0 0 0 1 0 0 1 1
\end{verbatim}

Parmi les autres fonctions intéressantes de ce package, on notera la fonction \emph{str\_pad()} qui permet de faire en sorte qu'une chaîne de caractère (1er argument de la fonction) possède au minimum un nombre de caractère (2ème argument) et la compléte si nécessaire avec un caractère (3ème argument). Par exemple, si on souhaite que chaque élément du vecteur suivant possède au moins 3 caractères et qu'on souhaite compléter les chaînes manquantes par le caractère ``-'' en début de chaîne, on procède ainsi :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec\_to\_change }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"1"}\NormalTok{, }\StringTok{"10"}\NormalTok{, }\StringTok{"105"}\NormalTok{, }\StringTok{"9999"}\NormalTok{, }\StringTok{"0008"}\NormalTok{)}
\FunctionTok{str\_pad}\NormalTok{(vec\_to\_change, }\DecValTok{4}\NormalTok{, }\AttributeTok{pad =} \StringTok{"0"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0001" "0010" "0105" "9999" "0008"
\end{verbatim}

On notera que le package \textbf{stringr} a été développé par Hadley Wickam (\textbf{RStudio}) qui est l'auteur d'un grand nombre d'autres packages avec cet esprit de rendre les choses plus simples pour l'utilisateur. Nous vous présenterons ces outils au fur et à mesure, mais à notre sens, il est important d'avoir conscience que derrière ces fonctions, se cachent des programmes qui utilisent les fonctions de base de \textbf{R}.

On citera également le package \textbf{stringi} qui propose un grand nombre de fonctions plus orientées vers l'analyse statistique de chaînes de caractères.

\textbf{Bibliographie}
On pourra consulter ce document très intéressant et complet sur la gestion des chaînes de caractères avec \textbf{R} (la version gratuite est très bien) :
\url{https://leanpub.com/r4strings}

\hypertarget{package-glue}{%
\subsection{\texorpdfstring{Package \textbf{glue}}{Package glue}}\label{package-glue}}

Ce package contient la fonction \emph{glue()} qui permet d'insérer dans du texte des objets qui ont été créés dans l'environnement courant.
En reprenant l'exemple de l'auteur du package (\url{https://cran.r-project.org/web/packages/glue/readme/README.html}) :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"glue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Le chargement a nécessité le package : glue
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{name }\OtherTok{\textless{}{-}} \StringTok{"Fred"}
\NormalTok{anniversary }\OtherTok{\textless{}{-}} \FunctionTok{as.Date}\NormalTok{(}\StringTok{"1991{-}10{-}12"}\NormalTok{)}
\NormalTok{age }\OtherTok{\textless{}{-}} \FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{floor}\NormalTok{((}\FunctionTok{Sys.Date}\NormalTok{() }\SpecialCharTok{{-}}\NormalTok{ anniversary)}\SpecialCharTok{/}\DecValTok{365}\NormalTok{))}
\NormalTok{new\_object }\OtherTok{\textless{}{-}} \FunctionTok{glue}\NormalTok{(}\StringTok{\textquotesingle{}My name is \{name\},\textquotesingle{}}\NormalTok{,}
  \StringTok{\textquotesingle{} my age next year is \{age + 1\},\textquotesingle{}}\NormalTok{,}
  \StringTok{\textquotesingle{} my anniversary is \{format(anniversary, "\%A, \%d \%B, \%Y")\}.\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{Remarque:} l'objet créé est à la fois un objet de type \textbf{glue} et \textbf{character} en même temps. La particularité de ce type d'objets est qu'il hérite de toutes les fonctions qui peuvent s'appliquer à ces deux types:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(new\_object)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "glue"      "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_object}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## My name is Fred, my age next year is 31, my anniversary is samedi, 12 octobre, 1991.
\end{verbatim}

Il est important de noter qu'une fois l'objet \textbf{glue} créé, sa valeur est fixée. Autrement dit, même si on modifie les objets qui ont été utilisés pour le créer, cela ne le modifiera (à moins bien sûr de re-exécuter la commande). Exemple :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{name }\OtherTok{\textless{}{-}} \StringTok{"Jojo"}
\NormalTok{new\_object}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## My name is Fred, my age next year is 31, my anniversary is samedi, 12 octobre, 1991.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_object }\OtherTok{\textless{}{-}} \FunctionTok{glue}\NormalTok{(}\StringTok{\textquotesingle{}My name is \{name\},\textquotesingle{}}\NormalTok{,}
  \StringTok{\textquotesingle{} my age next year is \{age + 1\},\textquotesingle{}}\NormalTok{,}
  \StringTok{\textquotesingle{} my anniversary is \{format(anniversary, "\%A, \%d \%B, \%Y")\}.\textquotesingle{}}\NormalTok{)}
\NormalTok{new\_object}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## My name is Jojo, my age next year is 31, my anniversary is samedi, 12 octobre, 1991.
\end{verbatim}

\hypertarget{les-facteurs}{%
\section{Les facteurs}\label{les-facteurs}}

Même s'ils peuvent a priori ressembler à des chaînes de caractères, les \textbf{factor} ont un comportement différent. Cette classe d'objet a été créé pour correspondre à une variable qualitative.

On commence par créer un vecteur de chaîne de caractères :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{genre }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"Ctrl"}\NormalTok{, }\StringTok{"Trait"}\NormalTok{), }\AttributeTok{size =} \DecValTok{10000}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Puis, on le transforme en \textbf{factor} en utilisant la fonction \emph{factor()} ou \emph{as.factor()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{genre\_fact }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(genre)}
\end{Highlighting}
\end{Shaded}

Les facteurs ont des modalités pré-définies qui sont retournées avec la fonction \emph{levels()}. L'affectation d'une valeur différente de ces modalités pré-définies provoque un message d'avertissement et une valeur manquante dans le vecteur :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{levels}\NormalTok{(genre\_fact)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Ctrl"  "Trait"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{genre\_fact[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"Autre"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in `[<-.factor`(`*tmp*`, 1, value = "Autre"): niveau de facteur
## incorrect, NAs générés
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{genre\_fact[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] <NA>
## Levels: Ctrl Trait
\end{verbatim}

ce qui n'est bien entendu pas le cas pour les vecteurs de caractères :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{genre[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"Autre"} 
\NormalTok{genre[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Autre"
\end{verbatim}

Dans le cas de vecteurs de taille importantes, le stockage d'un \textbf{factor} est un peu moins volumineux qu'un objet \textbf{character}. Ici, on utilise la fonction \emph{object.size()} qui indique la taille allouée à un objet en mémoire vive :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{object.size}\NormalTok{(genre)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 80216 bytes
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{object.size}\NormalTok{(genre\_fact)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 40560 bytes
\end{verbatim}

L'exemple suivant permet de mieux comprendre qu'un \textbf{factor} peut être considéré comme un vecteur de valeurs entières où chaque entier pourrait être remplacé par un \textbf{label}. Dans le cas où l'on souhaite associer un \textbf{label}, on procède de la façon suivante.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\AttributeTok{size =} \DecValTok{20}\NormalTok{, }\AttributeTok{rep =}\NormalTok{ T)}
\NormalTok{(f\_vec }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(vec, }\AttributeTok{levels =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }
                      \AttributeTok{labels =} \FunctionTok{c}\NormalTok{(}\StringTok{"Rien"}\NormalTok{, }\StringTok{"Peu"}\NormalTok{, }\StringTok{"Beaucoup"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] Peu      Peu      <NA>     <NA>     Peu      Rien     Peu      Rien    
##  [9] Beaucoup <NA>     <NA>     Peu      Peu      Rien     Peu      Rien    
## [17] Beaucoup Beaucoup <NA>     Rien    
## Levels: Rien Peu Beaucoup
\end{verbatim}

\textbf{Remarque :} si on oublie d'associer un \textbf{level} à un \textbf{label}, cela a pour conséquence de créer une valeur manquante.

La fonction \emph{cut()} qui permet le recodage d'une variable quantitative en classes, génère un objet de type \textbf{factor}. On précise les amplitudes des classes avec l'option \textbf{breaks} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\NormalTok{mesures }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\NormalTok{codage }\OtherTok{\textless{}{-}} \FunctionTok{cut}\NormalTok{(mesures, }\AttributeTok{breaks =} \SpecialCharTok{{-}}\DecValTok{4}\SpecialCharTok{:}\DecValTok{4}\NormalTok{)}
\FunctionTok{table}\NormalTok{(codage)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## codage
## (-4,-3] (-3,-2] (-2,-1]  (-1,0]   (0,1]   (1,2]   (2,3]   (3,4] 
##       0       1      13      34      35      14       3       0
\end{verbatim}

Pour aider à trouver un découpage d'une variable quantitative, la fonction \emph{classIntervals()} du package \textbf{classInt} propose différentes méthodes de discrétisation d'une variable quantitative. Parmi ces méthodes, on compte la méthode basée sur des classes d'amplitudes égales, d'effectifs égaux, ou calculées à partir de l'algorithme des \(k\)-means :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"classInt"}\NormalTok{)}
\NormalTok{codage2 }\OtherTok{\textless{}{-}} \FunctionTok{cut}\NormalTok{(mesures, }
           \FunctionTok{classIntervals}\NormalTok{(mesures, }\AttributeTok{n =} \DecValTok{5}\NormalTok{, }\AttributeTok{style =} \StringTok{"kmeans"}\NormalTok{)}\SpecialCharTok{$}\NormalTok{brks)}
\FunctionTok{table}\NormalTok{(codage2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## codage2
##   (-2.31,-0.874] (-0.874,-0.0726]  (-0.0726,0.614]     (0.614,1.44] 
##               13               31               28               19 
##      (1.44,2.19] 
##                8
\end{verbatim}

\textbf{Remarque} : les fonctions classiques d'importation des jeux de données codent les variables qualitatives sous forme de \textbf{factor}. Cet aspect a été critiqué par certains programmeurs dont Hadley Wickam (nous en verrons les raisons un peu plus tard), qui préconise un codage des variables qualitatives sous forme de \textbf{character}. Toutefois, un des avantages de la classe \textbf{factor} est que cela permet de représenter les modalités d'une variable qualitative de façon ordonnée, ce qui se révelera très pratique pour représenter des diagramme en barres par exemple..

\textbf{Exercice 1.5.}

\begin{itemize}
\tightlist
\item
  \textbf{Q1. Facteur ordonné:}

  \begin{itemize}
  \tightlist
  \item
    Créer un vecteur de chaîne de caractères \textbf{doses} de taille 25, comprenant les valeurs ``faible'', ``moyenne'' ou ``forte'' (on pourra créer ce vecteur de façon aléatoire).
  \item
    Convertir cet élément en \textbf{f\_dose} de type \textbf{factor} ordonné (voir si besoin \emph{?factor}).
  \item
    Vérifier que les niveaux du facteur sont effectivement ordonnés. Pour cela, il suffit de comparer d'utiliser les opérateurs de comparaison \textbf{\textless{}} ou \textbf{\textgreater{}} sur deux composantes du vecteur.
  \end{itemize}
\item
  \textbf{Q2. Codage et comptage :} donner un équivalent de l'enchaînement des fonctions \emph{cut()} et \emph{table()} utilisées précédemment.
\end{itemize}

\hypertarget{les-dates}{%
\section{Les dates}\label{les-dates}}

\hypertarget{dates-et-unituxe9s-de-temps}{%
\subsection{Dates et unités de temps}\label{dates-et-unituxe9s-de-temps}}

Il existe plusieurs packages pour manipuler des données temporelles ; voir la \href{http://cran.r-project.org/web/views/TimeSeries.html}{Task View Time Series Analysis}. Nous nous contentons ici de présenter quelques manipulations élémentaires. Une référence sur le sujet :

\begin{itemize}
\tightlist
\item
  G. Grothendieck and T. Petzoldt (2004), \textbf{R} Help Desk: Date and Time Classes in \textbf{R}, \textbf{R} News 4(1), 29-32 (\url{https://www.r-project.org/doc/Rnews/Rnews_2004-1.pdf}).
\end{itemize}

Dans \textbf{R}, une façon naturelle de manipuler des dates est d'utiliser la classe d'objet \textbf{Date}. Voici l'allure d'un objet de classe \textbf{Date} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(format.Date }\OtherTok{\textless{}{-}} \FunctionTok{Sys.Date}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2021-10-15"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(format.Date)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Date"
\end{verbatim}

En gros, il s'agit d'une chaîne de caractère de la forme \textbf{``YYYY-MM-DD''}, parfois \textbf{``YYYY/MM/DD''} ou encore \textbf{``MM/DD/YY''}. Pour passer d'une chaîne de caractère à un objet de classe \textbf{Date}, il faut donc préciser où sont placés les années, mois et jours dans la chaîne de caractère, préciser si les mois sont des valeurs numériques ou écrit en lettre, etc. Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dates }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"01/01/17"}\NormalTok{, }\StringTok{"02/03/17"}\NormalTok{, }\StringTok{"03/05/17"}\NormalTok{)}
\FunctionTok{as.Date}\NormalTok{(dates, }\StringTok{"\%d/\%m/\%y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2017-01-01" "2017-03-02" "2017-05-03"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dates }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"1 janvier 2017"}\NormalTok{, }\StringTok{"2 mars 2017"}\NormalTok{, }\StringTok{"3 mai 2017"}\NormalTok{)}
\FunctionTok{as.Date}\NormalTok{(dates, }\StringTok{"\%d \%B \%Y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2017-01-01" "2017-03-02" "2017-05-03"
\end{verbatim}

Les informations sur la façon dont convertir les chaînes de caractères en objet \textbf{Date} sont données dans l'aide suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?format.Date}
\end{Highlighting}
\end{Shaded}

Une autre classe d'objet utile est la classe \textbf{POSIXct/POSIXt}. Le format \textbf{POSIXct/POSIXlt} est plus précis que le format \textbf{Date} car il mesure à la fois la date et l'heure. Ce format est notamment utilisé dans les séries temporelles d'indices boursiers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(format.POSIXlt }\OtherTok{\textless{}{-}} \FunctionTok{Sys.time}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2021-10-15 20:11:03 CEST"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(format.POSIXlt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "POSIXct" "POSIXt"
\end{verbatim}

Un certain nombre de fonctions de \textbf{R} reconnaissent ce type de format. On en cite ici quelques-unes :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{weekdays}\NormalTok{(format.POSIXlt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "vendredi"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{months}\NormalTok{(format.POSIXlt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "octobre"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{quarters}\NormalTok{(format.POSIXlt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Q4"
\end{verbatim}

De même que pour les dates, il est possible de convertir des chaînes de caractères en \textbf{POSIXct/POSIXlt} ou de faire l'inverse. Pour cela, il faut respecter la nomenclature des dates (voir l'aide en ligne \emph{?strptime}). Pour convertir une chaîne de caractères en \textbf{POSIXct/POSIXlt} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dates }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"02/27/92"}\NormalTok{, }\StringTok{"02/27/92"}\NormalTok{, }\StringTok{"01/14/92"}\NormalTok{, }\StringTok{"02/28/92"}\NormalTok{, }\StringTok{"02/01/92"}\NormalTok{)}
\NormalTok{times }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"23:03:20"}\NormalTok{, }\StringTok{"22:29:56"}\NormalTok{, }\StringTok{"01:03:30"}\NormalTok{, }\StringTok{"18:21:03"}\NormalTok{, }\StringTok{"16:56:26"}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(dates, times)}
\FunctionTok{strptime}\NormalTok{(x, }\StringTok{"\%m/\%d/\%y \%H:\%M:\%S"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1992-02-27 23:03:20 CET" "1992-02-27 22:29:56 CET"
## [3] "1992-01-14 01:03:30 CET" "1992-02-28 18:21:03 CET"
## [5] "1992-02-01 16:56:26 CET"
\end{verbatim}

Pour faire l'inverse (transformer un \textbf{POSIXct/POSIXlt} en \textbf{character}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(z }\OtherTok{\textless{}{-}} \FunctionTok{Sys.time}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2021-10-15 20:11:03 CEST"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{format}\NormalTok{(z,}\StringTok{"\%a \%d \%b \%Y \%X \%Z"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ven. 15 oct. 2021 20:11:03 CEST"
\end{verbatim}

La fonction \emph{system.time()} renvoie plusieurs informations concernant le temps de calcul d'une commande :

\begin{itemize}
\item
  \emph{Utilisateur} : il s'agit du temps mis par l'ordinateur pour exécuter directement le code donné par l'utilisateur,
\item
  \emph{Système} : il s'agit du temps utilisé pas directement par le calcul, mais par le système (ex: gestion des entrées/sorties, écriture sur le disque, etc.) lié au code qui doit être exécuté.
\item
  \emph{écoulé} : il s'agit du temps Utilisateur + Système C'est en général ce dernier qui est utilisé pour comparer des temps de calcul.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(}\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{) }\FunctionTok{var}\NormalTok{(}\FunctionTok{runif}\NormalTok{(}\DecValTok{100000}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## utilisateur     système      écoulé 
##       0.357       0.024       0.381
\end{verbatim}

\textbf{Remarque :} il est parfois compliqué de convertir des chaînes de caractères en \textbf{Date} ou \textbf{POSIXct/POSIXlt}, mais une fois que cela est fait, il est alors possible d'utiliser un nombre conséquent de packages existants, qui permettent en autre la manipulation de séries temporelles.

\textbf{Exercice 1.6.}

\textbf{Q1} Quel jour (lundi, mardi \ldots{} ?) sera le 1er janvier de l'année 2022 ?

\textbf{Q2} Combien de jours nous séparent du 31 décembre de l'année en cours

\hypertarget{suxe9ries-temporelles}{%
\subsection{Séries temporelles}\label{suxe9ries-temporelles}}

Nous faisons ici un aparte pour évoquer la manipulation de séries temporelles.

On commence par simuler deux séries temporelles issues respectivement d'un processus AR(2) et MA(2). Nous ne rentrerons pas dans le détail de ces modèles mais le lecteur pourra se référer à l'ouvrage d'Yves Aragon ``Séries temporelles avec \textbf{R}'' pour une introduction. On utilise la fonction \emph{set.seed()} avant chaque simulation, ce qui va nous permettre de générer la même séquence dès lors qu'on utilisera les mêmes entiers comme argument de la fonction (493 et 494 ici).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{493}\NormalTok{)}
\NormalTok{x1 }\OtherTok{\textless{}{-}} \FunctionTok{arima.sim}\NormalTok{(}\AttributeTok{model =} \FunctionTok{list}\NormalTok{(}\AttributeTok{ar =} \FunctionTok{c}\NormalTok{(.}\DecValTok{9}\NormalTok{, }\SpecialCharTok{{-}}\NormalTok{.}\DecValTok{2}\NormalTok{)), }\AttributeTok{n =} \DecValTok{100}\NormalTok{)}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{494}\NormalTok{)}
\NormalTok{x2 }\OtherTok{\textless{}{-}} \FunctionTok{arima.sim}\NormalTok{(}\AttributeTok{model =} \FunctionTok{list}\NormalTok{(}\AttributeTok{ma =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\NormalTok{.}\DecValTok{7}\NormalTok{, .}\DecValTok{1}\NormalTok{)), }\AttributeTok{n =} \DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Le principe d'une série temporelle est que les observations sont associées à une date et dans certains cas une date et un temps (indices boursiers observés en temps réel). Pour faire simple, on va associer la série à des dates journalières commencant le 1er octobre 2017 et de taille 100. Une façon de faire est d'utiliser la fonction \emph{seq.Date()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date\_x }\OtherTok{\textless{}{-}} \FunctionTok{seq.Date}\NormalTok{(}\FunctionTok{as.Date}\NormalTok{(}\StringTok{"2017{-}10{-}01"}\NormalTok{), }\AttributeTok{by =} \StringTok{"day"}\NormalTok{, }\AttributeTok{len =} \DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ensuite, on utilise la fonction \emph{zoo()} du package qui porte le même nom pour associer les séries aux dates précédemment créées :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"zoo"}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{zoo}\NormalTok{(}\FunctionTok{cbind}\NormalTok{(x1, x2), date\_x)}
\end{Highlighting}
\end{Shaded}

L'objet précédemment créé peut ensuite être appliqué aux fonctions du package \textbf{zoo}. Ainsi, en appliquant la fonction \emph{plot()} à un tel objet, cela a pour avantage d'afficher en abscisses les dates, d'afficher plusieurs courbes s'il s'agit de séries temporelles multidimensionnelles, etc. On pourra consulter les fonctions du package \textbf{zoo} pour plus d'informations (\emph{help(package=``zoo'')})

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(}\AttributeTok{las =} \DecValTok{1}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(x, }\AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"blue"}\NormalTok{, }\StringTok{"red"}\NormalTok{), }\AttributeTok{screens =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-67-1.pdf}

\textbf{Remarque :} l'option \textbf{las = 1} dans la fonction \emph{par()} permet d'afficher la légende de l'axe des ordonnées horizontalement. L'options \textbf{screens = 1} permet de représenter les deux séries dans la meme figure.

\hypertarget{opuxe9rations-ensemblistes}{%
\section{Opérations ensemblistes}\label{opuxe9rations-ensemblistes}}

On définit deux vecteurs \(A\) et \(B\) d'entiers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(A }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(B }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\SpecialCharTok{:}\DecValTok{6}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{18}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  3  4  5  6 12 15 18
\end{verbatim}

Les opérations ensemblistes classiques sont :

\hypertarget{lunion}{%
\subsection{L'union}\label{lunion}}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{union}\NormalTok{(A, B)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10 12 15 18
\end{verbatim}

équivalent à la syntaxe suivante écrite avec des fonctions de base:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{unique}\NormalTok{(}\FunctionTok{c}\NormalTok{(A, B))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10 12 15 18
\end{verbatim}

\hypertarget{lintersection}{%
\subsection{L'intersection}\label{lintersection}}

\begin{itemize}
\tightlist
\item
  fonction \emph{intersect()}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{intersect}\NormalTok{(A, B)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 4 5 6
\end{verbatim}

équivalent à la syntaxe suivante écrite avec des fonctions de base:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[A }\SpecialCharTok{\%in\%}\NormalTok{ B]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 4 5 6
\end{verbatim}

\begin{itemize}
\tightlist
\item
  fonction \emph{match()}
\end{itemize}

Ici, il nous semble important de parler de la fonction \emph{match()} qui a été utilisée pour coder la fonction \emph{intersect()}. Dans le code ci-dessous, elle retourne pour chaque élément de \textbf{A} s'il se trouve dans \textbf{B} et si oui à quelle position dans \textbf{B}. Ci-dessous, le 3ème élement de \textbf{A} est bien dans \textbf{B} et il se situe à la 1ère position de \textbf{B}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{match}\NormalTok{(A, B)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] NA NA  1  2  3  4 NA NA NA NA
\end{verbatim}

Il est important de rappeler que l'opérateur \textbf{\%in\%} fait appel à la fonction \emph{match()}. Pour afficher le code de la fonction \textbf{\%in\%}, on peut utiliser la syntaxe suivante:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{\textasciigrave{}}\AttributeTok{\%in\%}\StringTok{\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function (x, table) 
## match(x, table, nomatch = 0L) > 0L
## <bytecode: 0x55cc3b5e2548>
## <environment: namespace:base>
\end{verbatim}

\hypertarget{la-diffuxe9rence-a-b-diffuxe9rent-de-b-a}{%
\subsection{\texorpdfstring{La différence (\(A-B\), différent de \(B-A\))}{La différence (A-B, différent de B-A)}}\label{la-diffuxe9rence-a-b-diffuxe9rent-de-b-a}}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setdiff}\NormalTok{(A, B)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  2  7  8  9 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setdiff}\NormalTok{(B, A)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12 15 18
\end{verbatim}

Pour savoir si un ou plusieurs éléments sont contenus dans un ensemble :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.element}\NormalTok{(}\DecValTok{2}\NormalTok{, A)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.element}\NormalTok{(}\DecValTok{2}\NormalTok{, B)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.element}\NormalTok{(A, B)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.element}\NormalTok{(B, A)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE
\end{verbatim}

\textbf{Attention :} on utilise ces fonctions sur des objets de même classe. Si on fait l'union d'un vecteur d'entiers avec un vecteur de caractères, le vecteur d'entiers sera transformé en caractères. Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{let }\OtherTok{\textless{}{-}}\NormalTok{ letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{]}
\FunctionTok{union}\NormalTok{(A, let)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "a"  "b"  "c"  "d"  "e" 
## [16] "f"  "g"  "h"  "i"  "j"
\end{verbatim}

Il est donc possible de faire des opérations ensemblistes sur les chaînes de caractères.

\textbf{Exercice 1.7.}

\textbf{Q1 :} donner une notation équivalente à \emph{is.element(2, A)}.

\textbf{Q2 :} l'objet \textbf{letters} est un vecteur de longueur 26 qui contient les lettres de l'alphabet. Tester l'appartenance des lettres \textbf{k} et \textbf{m} à l'alphabet ; que renvoie la syntaxe ``réciproque'' (appartenance de l'alphabet à l'ensemble \emph{c(``k'', ``m'')}) ? Comment obtenir le rang des lettres \textbf{k} et \textbf{m} dans l'alphabet ?

\textbf{Q3 :} en plus des 2 vecteurs \textbf{A} et \textbf{B} définis précédemment, considérons le vecteur \textbf{E} (nous évitons la lettre \textbf{C} qui existe déjà dans \textbf{R}, voir \emph{help(C)}) suivant :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{E }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{18}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{19}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Donner l'enchaînement des commandes qui permettent de retrouver les valeurs disposées sur le diagramme de Venn ci-dessous (obtenu avec la fonction \emph{venn()} du package \textbf{gplots}).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"gplots"}\NormalTok{)}
\FunctionTok{venn}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\AttributeTok{A =}\NormalTok{ A, }\AttributeTok{B =}\NormalTok{ B, }\AttributeTok{E =}\NormalTok{ E))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-79-1.pdf}

\hypertarget{manipulation-de-bases-de-donnuxe9es}{%
\section{Manipulation de bases de données}\label{manipulation-de-bases-de-donnuxe9es}}

\hypertarget{jointure-et-agruxe9gation}{%
\subsection{Jointure et agrégation}\label{jointure-et-agruxe9gation}}

On considère une table \textbf{patient} qui contient des informations sur les patients et une table \textbf{visite} qui contient des informations sur les visites. La clé de référence est le nom du patient dont la variable ne porte pas le même nom dans les deux tables.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{patient }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
   \AttributeTok{nom.famille =} \FunctionTok{c}\NormalTok{(}\StringTok{"René"}\NormalTok{, }\StringTok{"Jean"}\NormalTok{, }\StringTok{"Ginette"}\NormalTok{, }\StringTok{"Joseph"}\NormalTok{),}
   \AttributeTok{ddn =} \FunctionTok{c}\NormalTok{(}\StringTok{"02/02/1925"}\NormalTok{, }\StringTok{"03/03/1952"}\NormalTok{, }\StringTok{"01/10/1992"}\NormalTok{, }\StringTok{"02/02/1920"}\NormalTok{),}
   \AttributeTok{sexe =} \FunctionTok{c}\NormalTok{(}\StringTok{"m"}\NormalTok{, }\StringTok{"m"}\NormalTok{, }\StringTok{"f"}\NormalTok{, }\StringTok{"m"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{visite }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
   \AttributeTok{nom =} \FunctionTok{c}\NormalTok{(}\StringTok{"René"}\NormalTok{, }\StringTok{"Jean"}\NormalTok{, }\StringTok{"René"}\NormalTok{, }\StringTok{"Simone"}\NormalTok{, }\StringTok{"Ginette"}\NormalTok{),}
   \AttributeTok{ddv =} \FunctionTok{c}\NormalTok{(}\StringTok{"01/01/2020"}\NormalTok{, }\StringTok{"10/12/2020"}\NormalTok{, }\StringTok{"05/01/2020"}\NormalTok{, }\StringTok{"04/12/2020"}\NormalTok{, }\StringTok{"05/10/2020"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\textbf{Problématique :} on souhaite avoir une table contenant l'âge du patient au moment de sa visite. Pour cela, on voit bien qu'il faut connaître la date de naissance du patient au moment de sa visite. L'idée est donc d'ajouter une colonne ``ddn'' à la table visite pour pouvoir ensuite calculer l'âge en faisant la différence entre la date de visite et la date naissance.

\hypertarget{jointure-sans-utiliser-la-fonction-merge}{%
\subsubsection{\texorpdfstring{Jointure sans utiliser la fonction \emph{merge()}}{Jointure sans utiliser la fonction merge()}}\label{jointure-sans-utiliser-la-fonction-merge}}

Dans un premier temps, nous allons essayer de répondre au problème sans utiliser la fonction \emph{merge()}. Pour cela, nous allons utiliser la fonction \emph{match()} vue précédemment. Elle va nous permettre de savoir où se trouvent dans la table \textbf{patient}, les patients qui ont eu des visites. Une fois les indices connus, on a plus qu'à sélectionner les dates de naissance des patients.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{visite}\SpecialCharTok{$}\NormalTok{ddn }\OtherTok{\textless{}{-}}\NormalTok{ patient}\SpecialCharTok{$}\NormalTok{ddn[}\FunctionTok{match}\NormalTok{(visite}\SpecialCharTok{$}\NormalTok{nom, patient}\SpecialCharTok{$}\NormalTok{nom.famille)]}
\end{Highlighting}
\end{Shaded}

Ensuite, on calcule l'âge du patient :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{visite}\SpecialCharTok{$}\NormalTok{age }\OtherTok{\textless{}{-}} \FunctionTok{round}\NormalTok{(}\FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{as.Date}\NormalTok{(visite}\SpecialCharTok{$}\NormalTok{ddv, }\AttributeTok{format =} \StringTok{"\%d/\%m/\%Y"}\NormalTok{) }\SpecialCharTok{{-}} 
                               \FunctionTok{as.Date}\NormalTok{(visite}\SpecialCharTok{$}\NormalTok{ddn, }\AttributeTok{format =} \StringTok{"\%d/\%m/\%Y"}\NormalTok{))}\SpecialCharTok{/}\DecValTok{365}\NormalTok{,}
                    \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Enfin, on efface la date de naissance qui ne nous intéresse pas ici :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{visite}\SpecialCharTok{$}\NormalTok{ddn }\OtherTok{\textless{}{-}} \ConstantTok{NULL}
\FunctionTok{head}\NormalTok{(visite)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       nom        ddv age
## 1    René 01/01/2020  95
## 2    Jean 10/12/2020  69
## 3    René 05/01/2020  95
## 4  Simone 04/12/2020  NA
## 5 Ginette 05/10/2020  28
\end{verbatim}

Pour la suite, on remet à jour la table \textbf{visite} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{visite}\SpecialCharTok{$}\NormalTok{age }\OtherTok{\textless{}{-}} \ConstantTok{NULL}
\end{Highlighting}
\end{Shaded}

\hypertarget{jointure-en-utilisant-la-fonction-merge}{%
\subsubsection{\texorpdfstring{Jointure en utilisant la fonction \emph{merge()}}{Jointure en utilisant la fonction merge()}}\label{jointure-en-utilisant-la-fonction-merge}}

A présent, nous allons utiliser la fonction \emph{merge()} qui permet de réaliser la jointure entre deux tables. Il est essentiel de préciser la clé de référence des deux tables avec l'option \textbf{by=} si les deux tables ont un nom de clé identique ou alors \textbf{by.x=} et \textbf{by.y=} si la clé de référence porte un nom différent selon la table.

Dans la première commande, le merge se fait sur les variables qui sont présentes dans les deux tables. Autrement dit, l'individu ``Simone'' n'est pas présente dans la nouvelle table compte tenu qu'elle n'est pas identifiée parmi les patients.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{visite}\SpecialCharTok{$}\NormalTok{age }\OtherTok{\textless{}{-}} \ConstantTok{NULL}
\FunctionTok{merge}\NormalTok{(visite, patient, }\AttributeTok{by.x =} \StringTok{"nom"}\NormalTok{, }\AttributeTok{by.y =} \StringTok{"nom.famille"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       nom        ddv        ddn sexe
## 1 Ginette 05/10/2020 01/10/1992    f
## 2    Jean 10/12/2020 03/03/1952    m
## 3    René 01/01/2020 02/02/1925    m
## 4    René 05/01/2020 02/02/1925    m
\end{verbatim}

Si on souhaite garder toute l'information contenue dans le fichier visite, on ajoute l'option \textbf{all.x=TRUE}. Autrement dit, on affiche ici toutes les visites, y compris celles des personnes qui ne sont bas dans la table \textbf{patient}. On remarquera que Simone apparaît en queue de table :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{merge}\NormalTok{(visite, patient, }\AttributeTok{by.x =} \StringTok{"nom"}\NormalTok{, }\AttributeTok{by.y =} \StringTok{"nom.famille"}\NormalTok{, }\AttributeTok{all.x =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       nom        ddv        ddn sexe
## 1 Ginette 05/10/2020 01/10/1992    f
## 2    Jean 10/12/2020 03/03/1952    m
## 3    René 01/01/2020 02/02/1925    m
## 4    René 05/01/2020 02/02/1925    m
## 5  Simone 04/12/2020       <NA> <NA>
\end{verbatim}

Enfin, si on souhaite conserver l'information dans les deux tables, on utilise \textbf{all.x=TRUE} et \textbf{all.y=TRUE} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(visite.patient }\OtherTok{\textless{}{-}} \FunctionTok{merge}\NormalTok{(visite, patient, }\AttributeTok{by.x =} \StringTok{"nom"}\NormalTok{,}
    \AttributeTok{by.y =} \StringTok{"nom.famille"}\NormalTok{, }\AttributeTok{all.x =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{all.y =} \ConstantTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       nom        ddv        ddn sexe
## 1 Ginette 05/10/2020 01/10/1992    f
## 2    Jean 10/12/2020 03/03/1952    m
## 3  Joseph       <NA> 02/02/1920    m
## 4    René 01/01/2020 02/02/1925    m
## 5    René 05/01/2020 02/02/1925    m
## 6  Simone 04/12/2020       <NA> <NA>
\end{verbatim}

Pour calculer l'âge du patient au moment de la visite, on utilise la commande vue précédemment :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{visite.patient}\SpecialCharTok{$}\NormalTok{age }\OtherTok{\textless{}{-}} \FunctionTok{round}\NormalTok{(}\FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{as.Date}\NormalTok{(visite.patient}\SpecialCharTok{$}\NormalTok{ddv, }
                                               \AttributeTok{format =} \StringTok{"\%d/\%m/\%Y"}\NormalTok{) }\SpecialCharTok{{-}} 
                            \FunctionTok{as.Date}\NormalTok{(visite.patient}\SpecialCharTok{$}\NormalTok{ddn, }
                                               \AttributeTok{format =} \StringTok{"\%d/\%m/\%Y"}\NormalTok{))}\SpecialCharTok{/}\DecValTok{365}\NormalTok{, }
                            \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Maintenant, on souhaite connaître l'âge des patients lors de leurs visites en fonction du sexe. On va donc faire une aggrégation.

\hypertarget{aggruxe9gation}{%
\subsubsection{Aggrégation}\label{aggruxe9gation}}

Pour faire l'agrégation, on utilise la fonction \emph{tapply()} pour aggréger une variable ou \emph{aggregate()} pour plusieurs variables. Le principe de ces finctions est le suivant :

\begin{itemize}
\item
  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    utiliser \emph{split()} sur l'échantillon total pour découper en sous-échantillons selon la variable utilisée pour faire l'aggrégation:
  \end{enumerate}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_split }\OtherTok{\textless{}{-}} \FunctionTok{split}\NormalTok{(}\AttributeTok{x =}\NormalTok{ visite.patient}\SpecialCharTok{$}\NormalTok{age, }\AttributeTok{f =}\NormalTok{ visite.patient}\SpecialCharTok{$}\NormalTok{sexe)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \setcounter{enumi}{1}
  \tightlist
  \item
    utiliser \emph{lapply()} ou \emph{sapply()} pour calculer des statistiques sur chaque sous-échantillon
  \end{enumerate}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sapply}\NormalTok{(my\_split, }\AttributeTok{FUN =}\NormalTok{ mean, }\AttributeTok{na.rm =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        f        m 
## 28.00000 86.33333
\end{verbatim}

En utilisant la fonction \emph{tapply()}, les deux étapes précédentes sont réalisées à la suite :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(}\AttributeTok{X =}\NormalTok{ visite.patient}\SpecialCharTok{$}\NormalTok{age, }\AttributeTok{INDEX =} \FunctionTok{list}\NormalTok{(}\AttributeTok{sexe =}\NormalTok{ visite.patient}\SpecialCharTok{$}\NormalTok{sexe),}
       \AttributeTok{FUN =}\NormalTok{ mean, }\AttributeTok{na.rm =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## sexe
##        f        m 
## 28.00000 86.33333
\end{verbatim}

Si on utilise la fonction \emph{aggregate()}, la variable qui permet d'aggréger doit être mise sous forme d'une liste dans l'option \textbf{by=}. L'option \textbf{FUN=} renseigne s'il s'agit de faire une somme, une moyenne, etc. Dans notre cas :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{aggregate}\NormalTok{(visite.patient}\SpecialCharTok{$}\NormalTok{age, }\AttributeTok{by =} \FunctionTok{list}\NormalTok{(}\AttributeTok{S =}\NormalTok{ visite.patient}\SpecialCharTok{$}\NormalTok{sexe),}
 \AttributeTok{FUN =}\NormalTok{ mean, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   S        x
## 1 f 28.00000
## 2 m 86.33333
\end{verbatim}

\textbf{Exercice 1.8.}

\textbf{Q1} à partir du jeu de données \textbf{iris} (disponible par défaut dans l'environnement courant), construire l'objet \textbf{iris1} qui contient en fonction des espèces (variable \textbf{Species}), la taille moyenne de la variable \textbf{Petal.Length}.

\textbf{Q2} Construire l'objet \textbf{iris2} qui contient en fonction des espèces,
la taille totale de la variable \textbf{Petal.Width}.

\textbf{Q3} Faire le merge des jeux de données \textbf{iris1} et \textbf{iris2}.

\hypertarget{package-dplyr}{%
\subsection{\texorpdfstring{Package \textbf{dplyr}}{Package dplyr}}\label{package-dplyr}}

Ce document est inspiré d'une présentation de Sophie Lamarre aux rencontres des Ingénieurs statisticiens de Toulouse, disponible
sur ce \href{http://www.thibault.laurent.free.fr/presentation\%20inge_stat/presentation\%2006-10-15/dplyr_Inge_stats_SL_02102015.pdf}{lien}. On recommande aussi la lecture de la vignette du package, disponible sur le site du CRAN :
\url{https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html}

Ce package est de plus en plus utilisé dans la manipulation de jeu de données, notamment parmi les ``Data Scientists''. Son principe est de simplifier la syntaxe des fonctions de base de \textbf{R} et d'utiliser du code \textbf{C++} derrière certaines de ses fonctions dans le but d'améliorer sensiblement les temps de calcul. Il fait partie du projet \href{https://www.tidyverse.org/}{Tidyverse} qui contient un ensemble de packages, développés en grande partie par \textbf{RStudio}. Avec la commande suivante, vous chargez un ensemble de packages dont certains très populaires (\textbf{ggplot2}, \textbf{dplyr}, etc.)

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Le chargement a nécessité le package : tidyverse
\end{verbatim}

\begin{verbatim}
## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --
\end{verbatim}

\begin{verbatim}
## v ggplot2 3.3.3     v purrr   0.3.4
## v tibble  3.1.2     v dplyr   1.0.6
## v tidyr   1.1.3     v forcats 0.5.1
## v readr   1.4.0
\end{verbatim}

\begin{verbatim}
## -- Conflicts ------------------------------------------ tidyverse_conflicts() --
## x dplyr::collapse() masks glue::collapse()
## x dplyr::filter()   masks stats::filter()
## x dplyr::lag()      masks stats::lag()
\end{verbatim}

Description du jeu de données utilisées : il s'agit du jeu de données \textbf{diamonds} du package \textbf{ggplot2}. On observe sur un peu plus de 50000 diamants, un certain nombre de variables dont : le prix de vente, le poids, la qualité, la couleur, etc.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(diamonds)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 10
##   carat cut       color clarity depth table price     x     y     z
##   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
## 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43
## 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31
## 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31
## 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63
## 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75
## 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48
\end{verbatim}

Voici le résumé statistique des variables :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(diamonds)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      carat               cut        color        clarity          depth      
##  Min.   :0.2000   Fair     : 1610   D: 6775   SI1    :13065   Min.   :43.00  
##  1st Qu.:0.4000   Good     : 4906   E: 9797   VS2    :12258   1st Qu.:61.00  
##  Median :0.7000   Very Good:12082   F: 9542   SI2    : 9194   Median :61.80  
##  Mean   :0.7979   Premium  :13791   G:11292   VS1    : 8171   Mean   :61.75  
##  3rd Qu.:1.0400   Ideal    :21551   H: 8304   VVS2   : 5066   3rd Qu.:62.50  
##  Max.   :5.0100                     I: 5422   VVS1   : 3655   Max.   :79.00  
##                                     J: 2808   (Other): 2531                  
##      table           price             x                y         
##  Min.   :43.00   Min.   :  326   Min.   : 0.000   Min.   : 0.000  
##  1st Qu.:56.00   1st Qu.:  950   1st Qu.: 4.710   1st Qu.: 4.720  
##  Median :57.00   Median : 2401   Median : 5.700   Median : 5.710  
##  Mean   :57.46   Mean   : 3933   Mean   : 5.731   Mean   : 5.735  
##  3rd Qu.:59.00   3rd Qu.: 5324   3rd Qu.: 6.540   3rd Qu.: 6.540  
##  Max.   :95.00   Max.   :18823   Max.   :10.740   Max.   :58.900  
##                                                                   
##        z         
##  Min.   : 0.000  
##  1st Qu.: 2.910  
##  Median : 3.530  
##  Mean   : 3.539  
##  3rd Qu.: 4.040  
##  Max.   :31.800  
## 
\end{verbatim}

\textbf{Remarque :} le jeu de données \textbf{diamonds} est dans un format de données nouveau : \textbf{tibble}. Il s'agit encore une fois d'une nouveauté proposée par \textbf{RStudio}. L'objet de classe \textbf{data.frame} peut présenter certaines contraintes pour ses utilisateurs. Par exemple, lorsque'on souhaite afficher un \textbf{data.frame} dans la console, \textbf{R} affiche autant de lignes qu'il le peut. D'autre part, avec un \textbf{data.frame}, certains noms de variables ne sont pas autorisés. Par exemple, dans un \textbf{data.frame} un nom de variable ne peut pas commencer par un chiffre ce qui n'est pas le cas avec le \textbf{tibble} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data.frame}\NormalTok{(}\StringTok{\textasciigrave{}}\AttributeTok{1a}\StringTok{\textasciigrave{}} \OtherTok{=} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\FunctionTok{tibble}\NormalTok{(}\StringTok{\textasciigrave{}}\AttributeTok{1a}\StringTok{\textasciigrave{}} \OtherTok{=} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

C'est pourquoi des développeurs ont pensé à créer un nouveau type d'objets, le \textbf{tibble} qui ne présenterait pas ce genre de contraintes. Ce n'est pas une grande révolution, mais ce package faisant partie du projet \textbf{tidyverse}, c'est essentiellement ce type de données qui est utilisé dans cet univers. Les fonctions que nous allons présenter dans cette section s'appliquent aussi bien sur des \textbf{data.frame} que sur des \textbf{tibble}, ce dernier type d'objet ayant hérité des propriétés des \textbf{data.frame}. Pour en savoir plus sur les \textbf{tibbles}, vous pouvez consulter ce cours en ligne : \url{http://r4ds.had.co.nz/tibbles.html}.

\hypertarget{suxe9lection-de-lignes-avec-la-fonction-filter}{%
\subsubsection{\texorpdfstring{Sélection de lignes avec la fonction \emph{filter()}}{Sélection de lignes avec la fonction filter()}}\label{suxe9lection-de-lignes-avec-la-fonction-filter}}

La fonction ``phare'' du package \textbf{dplyr} est la fonction \emph{filter()} qui permet de sélectionner un sous-échantillon du jeu de données à partir de critères qu'on lui donne. Par exemple, pour sélectionner uniquement les diamants d'une valeur supérieure à 15000 dollars et ayant une couleur \textbf{E} ou \textbf{F}, on écrit :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{filtrage1 }\OtherTok{\textless{}{-}}\NormalTok{ dplyr}\SpecialCharTok{::}\FunctionTok{filter}\NormalTok{(diamonds, price }\SpecialCharTok{\textgreater{}} \DecValTok{15000} \SpecialCharTok{\&}\NormalTok{ (color }\SpecialCharTok{==} \StringTok{"E"} \SpecialCharTok{|}\NormalTok{ color }\SpecialCharTok{==} \StringTok{"F"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Ou de façon équivalente (les virgules remplaçant la condition \textbf{et}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{filtrage1 }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(diamonds, price }\SpecialCharTok{\textgreater{}} \DecValTok{15000}\NormalTok{, (color }\SpecialCharTok{==} \StringTok{"E"} \SpecialCharTok{|}\NormalTok{ color }\SpecialCharTok{==} \StringTok{"F"}\NormalTok{))}
\FunctionTok{head}\NormalTok{(filtrage1, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 10
##   carat cut       color clarity depth table price     x     y     z
##   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
## 1  1.54 Premium   E     VS2      62.3    58 15002  7.31  7.39  4.58
## 2  1.19 Ideal     F     VVS1     61.5    55 15005  6.82  6.84  4.2 
## 3  2.05 Very Good F     SI2      61.9    56 15017  8.13  8.18  5.05
\end{verbatim}

Une nouveauté est également l'utilisation de l'opérteur \%\textgreater\% dit `pipe' en anglais. Il se trouve après un \textbf{data.frame} et indique qu'on va utiliser une fonction dont le premier argument est un objet de type \textbf{data.frame}. Dans ce cas, ce n'est plus la peine d'indiquer le premier argument de la fonction \emph{filter()}. Nous verrons par la suite son intérêt lorsqu'on souhaite appliquer successivement des commandes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{filtrage1 }\OtherTok{\textless{}{-}}\NormalTok{ diamonds }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{filter}\NormalTok{(price }\SpecialCharTok{\textgreater{}} \DecValTok{15000}\NormalTok{, (color }\SpecialCharTok{==} \StringTok{"E"} \SpecialCharTok{|}\NormalTok{ color }\SpecialCharTok{==} \StringTok{"F"}\NormalTok{))}
\FunctionTok{head}\NormalTok{(filtrage1, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 10
##   carat cut       color clarity depth table price     x     y     z
##   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
## 1  1.54 Premium   E     VS2      62.3    58 15002  7.31  7.39  4.58
## 2  1.19 Ideal     F     VVS1     61.5    55 15005  6.82  6.84  4.2 
## 3  2.05 Very Good F     SI2      61.9    56 15017  8.13  8.18  5.05
\end{verbatim}

\textbf{Remarque:} sans utiliser le package \textbf{dplyr}, on aurait du faire quelque chose comme ça :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{filtrage1 }\OtherTok{\textless{}{-}} \FunctionTok{with}\NormalTok{(diamonds, diamonds[price }\SpecialCharTok{\textgreater{}} \DecValTok{15000} \SpecialCharTok{\&} 
\NormalTok{                                       (color }\SpecialCharTok{==} \StringTok{"E"} \SpecialCharTok{|}\NormalTok{ color }\SpecialCharTok{==} \StringTok{"F"}\NormalTok{), ])}
\end{Highlighting}
\end{Shaded}

On aurait également pu utiliser la fonction de base \emph{subset()}dont le package \textbf{dplyr} s'est fortement inspiré.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{filtrage1 }\OtherTok{\textless{}{-}} \FunctionTok{subset}\NormalTok{(diamonds, price }\SpecialCharTok{\textgreater{}} \DecValTok{15000} \SpecialCharTok{\&}\NormalTok{ (color }\SpecialCharTok{==} \StringTok{"E"} \SpecialCharTok{|}\NormalTok{ color }\SpecialCharTok{==} \StringTok{"F"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{trier-le-jeu-de-donnuxe9es-avec-la-fonction-arrange}{%
\subsubsection{\texorpdfstring{Trier le jeu de données avec la fonction \emph{arrange()}}{Trier le jeu de données avec la fonction arrange()}}\label{trier-le-jeu-de-donnuxe9es-avec-la-fonction-arrange}}

On souhaite trier le jeu de données en fonction de la coupe, de la couleur et du prix (en valeur décroissante). Pour cela, on fait :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tri1 }\OtherTok{\textless{}{-}} \FunctionTok{arrange}\NormalTok{(diamonds, cut, color, }\FunctionTok{desc}\NormalTok{(price))}
\FunctionTok{head}\NormalTok{(tri1,}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 10
##   carat cut   color clarity depth table price     x     y     z
##   <dbl> <ord> <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
## 1  2.02 Fair  D     SI1      65      55 16386  7.94  7.84  5.13
## 2  2.01 Fair  D     SI2      66.9    57 16086  7.87  7.76  5.23
## 3  3.4  Fair  D     I1       66.8    52 15964  9.42  9.34  6.27
\end{verbatim}

Sans le package \textbf{dplyr}, on aurait fait :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tri1 }\OtherTok{\textless{}{-}} \FunctionTok{with}\NormalTok{(diamonds, diamonds[}\FunctionTok{order}\NormalTok{(cut, color, }\SpecialCharTok{{-}}\NormalTok{price),])}
\end{Highlighting}
\end{Shaded}

\hypertarget{suxe9lectionner-certaines-variables-avec-la-fonction-select}{%
\subsubsection{\texorpdfstring{Sélectionner certaines variables avec la fonction \emph{select()}}{Sélectionner certaines variables avec la fonction select()}}\label{suxe9lectionner-certaines-variables-avec-la-fonction-select}}

On ne souhaite garder que les variables \textbf{carat}, \textbf{price}, \textbf{color}, \textbf{z} et les variables dont le label contient le caractères \textbf{i} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{selection1 }\OtherTok{\textless{}{-}} \FunctionTok{select}\NormalTok{(diamonds, carat, price, color, z, }
\NormalTok{                     dplyr}\SpecialCharTok{::}\FunctionTok{contains}\NormalTok{(}\StringTok{"i"}\NormalTok{))}
\FunctionTok{head}\NormalTok{(selection1,}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 5
##   carat price color     z clarity
##   <dbl> <int> <ord> <dbl> <ord>  
## 1  0.23   326 E      2.43 SI2    
## 2  0.21   326 E      2.31 SI1    
## 3  0.23   327 E      2.31 VS1
\end{verbatim}

Sans le package \textbf{dplyr}, on aurait fait :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{selection1 }\OtherTok{\textless{}{-}}\NormalTok{ diamonds[, }\FunctionTok{unique}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"carat"}\NormalTok{, }\StringTok{"price"}\NormalTok{, }\StringTok{"color"}\NormalTok{, }\StringTok{"z"}\NormalTok{, }
                                  \FunctionTok{names}\NormalTok{(diamonds)[}\FunctionTok{grep}\NormalTok{(}\StringTok{"i"}\NormalTok{, }\FunctionTok{names}\NormalTok{(diamonds))]))]}
\end{Highlighting}
\end{Shaded}

\textbf{Remarque :} dans la deuxième syntaxe, pour que la variable \textbf{price} n'apparaisse qu'une seule fois dans le jeu de données, on a du utiliser la fonction \emph{unique()}.

\hypertarget{changer-le-nom-de-variables-avec-la-fonction-rename}{%
\subsubsection{\texorpdfstring{Changer le nom de variables avec la fonction \emph{rename()}}{Changer le nom de variables avec la fonction rename()}}\label{changer-le-nom-de-variables-avec-la-fonction-rename}}

On souhaite changer le nom de la variable \textbf{z} par le label \textbf{width} et \textbf{color} par \textbf{code\_color} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{renom1 }\OtherTok{\textless{}{-}} \FunctionTok{rename}\NormalTok{(diamonds, }\AttributeTok{width =}\NormalTok{ z, }\AttributeTok{code\_color =}\NormalTok{ color)}
\FunctionTok{head}\NormalTok{(renom1, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 10
##   carat cut     code_color clarity depth table price     x     y width
##   <dbl> <ord>   <ord>      <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
## 1  0.23 Ideal   E          SI2      61.5    55   326  3.95  3.98  2.43
## 2  0.21 Premium E          SI1      59.8    61   326  3.89  3.84  2.31
## 3  0.23 Good    E          VS1      56.9    65   327  4.05  4.07  2.31
\end{verbatim}

Sans le package \textbf{dplyr}, on aurait fait :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(diamonds)[}\FunctionTok{c}\NormalTok{(}\FunctionTok{match}\NormalTok{(}\StringTok{"z"}\NormalTok{, }\FunctionTok{names}\NormalTok{(diamonds)), }
                  \FunctionTok{match}\NormalTok{(}\StringTok{"color"}\NormalTok{, }\FunctionTok{names}\NormalTok{(diamonds)))] }\OtherTok{\textless{}{-}} 
  \FunctionTok{c}\NormalTok{(}\StringTok{"width"}\NormalTok{, }\StringTok{"code\_color"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{ajouter-une-nouvelle-colonne-avec-la-fonction-mutate}{%
\subsubsection{\texorpdfstring{Ajouter une nouvelle colonne avec la fonction \emph{mutate()}}{Ajouter une nouvelle colonne avec la fonction mutate()}}\label{ajouter-une-nouvelle-colonne-avec-la-fonction-mutate}}

On calcule le prix au kilo pour chaque diamant et on convertit en euros :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{calcul1 }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(diamonds, }\AttributeTok{prix.kilo =}\NormalTok{ price }\SpecialCharTok{/}\NormalTok{ carat, }
                  \AttributeTok{prix.kilo.euro =}\NormalTok{ prix.kilo }\SpecialCharTok{*} \FloatTok{0.9035}\NormalTok{)}
\FunctionTok{head}\NormalTok{(calcul1, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 12
##   carat cut     code_color clarity depth table price     x     y width prix.kilo
##   <dbl> <ord>   <ord>      <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>     <dbl>
## 1  0.23 Ideal   E          SI2      61.5    55   326  3.95  3.98  2.43     1417.
## 2  0.21 Premium E          SI1      59.8    61   326  3.89  3.84  2.31     1552.
## 3  0.23 Good    E          VS1      56.9    65   327  4.05  4.07  2.31     1422.
## # ... with 1 more variable: prix.kilo.euro <dbl>
\end{verbatim}

Sans le package \textbf{dplyr}, on aurait fait :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds}\SpecialCharTok{$}\NormalTok{prix.kilo }\OtherTok{\textless{}{-}}\NormalTok{ diamonds}\SpecialCharTok{$}\NormalTok{price}\SpecialCharTok{/}\NormalTok{diamonds}\SpecialCharTok{$}\NormalTok{carat}
\NormalTok{diamonds}\SpecialCharTok{$}\NormalTok{prix.kilo.euro }\OtherTok{\textless{}{-}}\NormalTok{ diamonds}\SpecialCharTok{$}\NormalTok{prix.kilo }\SpecialCharTok{*} \FloatTok{0.9035}
\end{Highlighting}
\end{Shaded}

\hypertarget{faire-des-calculs-statistiques-avec-la-fonction-summarise}{%
\subsubsection{\texorpdfstring{Faire des calculs statistiques avec la fonction \emph{summarise()}}{Faire des calculs statistiques avec la fonction summarise()}}\label{faire-des-calculs-statistiques-avec-la-fonction-summarise}}

On calcule le prix moyen en fonction de la couleur et de la coupe du diamant :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{calcul2 }\OtherTok{\textless{}{-}} \FunctionTok{summarise}\NormalTok{(}\FunctionTok{group\_by}\NormalTok{(diamonds, cut, code\_color), }\AttributeTok{prix.moy =} \FunctionTok{mean}\NormalTok{(price))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` has grouped output by 'cut'. You can override using the `.groups` argument.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(calcul2, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 3
## # Groups:   cut [1]
##   cut   code_color prix.moy
##   <ord> <ord>         <dbl>
## 1 Fair  D             4291.
## 2 Fair  E             3682.
## 3 Fair  F             3827.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(calcul2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "grouped_df" "tbl_df"     "tbl"        "data.frame"
\end{verbatim}

Sans le package \textbf{dplyr}, on aurait fait :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{calcul2 }\OtherTok{\textless{}{-}} \FunctionTok{aggregate}\NormalTok{(}\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{price =}\NormalTok{ diamonds[, }\StringTok{"price"}\NormalTok{]), }
                     \FunctionTok{list}\NormalTok{(}\AttributeTok{color =}\NormalTok{ diamonds}\SpecialCharTok{$}\NormalTok{code\_color, }
                          \AttributeTok{cut =}\NormalTok{ diamonds}\SpecialCharTok{$}\NormalTok{cut), mean)}
\end{Highlighting}
\end{Shaded}

\hypertarget{faire-des-calculs-statistiques-en-utilisant-une-nouvelle-syntaxe}{%
\subsubsection{Faire des calculs statistiques en utilisant une nouvelle syntaxe}\label{faire-des-calculs-statistiques-en-utilisant-une-nouvelle-syntaxe}}

On souhaite calculer le prix maximum d'un diamant en fonction de la couleur et de la coupe. On ne veut garder que les prix supérieurs à 5000 dollars. Pour cela, on peut utiliser la syntaxe suivante, dite ``pipelining'\,', qui provient du package \textbf{magrittr} (et importé par défaut via la package \textbf{dplyr}) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{group\_by}\NormalTok{(code\_color, cut) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{summarise}\NormalTok{(}\AttributeTok{prix\_groupe =} \FunctionTok{mean}\NormalTok{(price)) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{filter}\NormalTok{(prix\_groupe }\SpecialCharTok{\textgreater{}} \DecValTok{5000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` has grouped output by 'code_color'. You can override using the `.groups` argument.
\end{verbatim}

\begin{verbatim}
## # A tibble: 7 x 3
## # Groups:   code_color [3]
##   code_color cut       prix_groupe
##   <ord>      <ord>           <dbl>
## 1 H          Fair            5136.
## 2 H          Premium         5217.
## 3 I          Good            5079.
## 4 I          Very Good       5256.
## 5 I          Premium         5946.
## 6 J          Very Good       5104.
## 7 J          Premium         6295.
\end{verbatim}

L'idée de cette syntaxe est de pouvoir comprendre rapidement les différentes opérations qui sont effectuées les unes à la suite des autres. Dans l'exemple précédent :

\begin{itemize}
\tightlist
\item
  on prend le jeu de données \textbf{diamonds}, le fait d'ajouter un ``pipe'\,' à la suite implique qu'on va appliquer une première opération dessus,
\item
  \emph{group\_by} : on regroupe des observations en fonction des variables \textbf{color} et \textbf{cut},
\item
  \emph{summarise} : on calcule le prix moyen sur les groupes précédemment créés,
\item
  \emph{filter} : on ne garde que les observations supérieures à 5000 dollars.
\end{itemize}

\textbf{Remarque :} depuis la version \textbf{4.1.0}, \textbf{R} a lancé une version native de l'opérateur `\texttt{pipe\textquotesingle{}\textquotesingle{}.\ Il\ s\textquotesingle{}agit\ de\ la\ commande\ suivante}\textbar\textgreater`. Voici un exemple d'utilisation :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_vec }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{my\_vec }\SpecialCharTok{|}\ErrorTok{\textgreater{}}
  \FunctionTok{mean}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.4518699
\end{verbatim}

Dans la plupart des cas, il peut remplacer le pipe de \textbf{magrittr}.

\hypertarget{tirer-un-uxe9chantillon-dune-population}{%
\subsubsection{Tirer un échantillon d'une population}\label{tirer-un-uxe9chantillon-dune-population}}

On souhaite tirer de façon aléatoire 100 observations :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tirage1 }\OtherTok{\textless{}{-}} \FunctionTok{sample\_n}\NormalTok{(diamonds, }\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

On souhaite tirer de façon aléatoire \(5\%\) de l'échantillon :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tirage1 }\OtherTok{\textless{}{-}} \FunctionTok{sample\_frac}\NormalTok{(diamonds, }\FloatTok{0.05}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{tidy-data}{%
\section{Tidy data}\label{tidy-data}}

Pour illustrer ce paragraphe, on considére les données suivantes : on observe pour 3 pays (Afghanistan, Brazil et Chine) sur 2 années consécutives (1999 et 2000), la taille de la population ainsi que le nombre de cas de tuberculoses observés. On va voir qu'on peut utiliser différentes tables pour présenter ces données et parmi ces différentes possibilités, on aura intérêt à en utiliser une plutôt que les autres. Pour charger ces données, on va installer le package \textbf{DSR} accessible depuis \textbf{github}. En effet, il est possible de récupérer sur \textbf{github} des packages qui sont en cours de développement et qui n'ont pas encore passés le processus de validation pour être un package officiel du CRAN :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\SpecialCharTok{::}\FunctionTok{install\_github}\NormalTok{(}\StringTok{"garrettgman/DSR"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

On pourrait traduire \emph{tidy data} par données rangées en opposition à \emph{messy data}, données désordonnées. Ce courant de \emph{tidy data} vient encore de Hadley Wickham (voir article \url{https://www.jstatsoft.org/article/view/v059i10} ou encore \url{https://r4ds.had.co.nz/tidy-data.html}) qui part du principe suivant qui peut paraître évident, mais selon les situations, ce n'est pas toujours le cas :

\begin{itemize}
\item
  Une variable doit être rangée dans une colonne,
\item
  Un individu est rangé dans une ligne,
\item
  On place les valeurs observées dans les bonnes cases.
\end{itemize}

On présente ici une façon de présenter les données \emph{tidy} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DSR}\SpecialCharTok{::}\NormalTok{table1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 4
##   country      year  cases population
##   <fct>       <int>  <int>      <int>
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583
\end{verbatim}

Au contraire, dans les données \emph{messy}, on trouve en général une de ces situations :

\begin{itemize}
\item
  le nom des colonnes sont des valeurs et pas des noms,
\item
  Plusieurs variables sont stockées dans une même colonne, c'est le cas du jeu de données suivant.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DSR}\SpecialCharTok{::}\NormalTok{table3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 3
##   country      year rate             
##   <fct>       <int> <chr>            
## 1 Afghanistan  1999 745/19987071     
## 2 Afghanistan  2000 2666/20595360    
## 3 Brazil       1999 37737/172006362  
## 4 Brazil       2000 80488/174504898  
## 5 China        1999 212258/1272915272
## 6 China        2000 213766/1280428583
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Les variables sont à la fois présentes dans les lignes et les colonnes, c'est le cas du jeu de données suivant où constate que la colonne \textbf{key} contient le nom des deux variables \textbf{population} et \textbf{cases}, qu'il semblerait judiciable de présenter plutôt en colonnes.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DSR}\SpecialCharTok{::}\NormalTok{table2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 4
##    country      year key             value
##    <fct>       <int> <fct>           <int>
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  1999 population   19987071
##  3 Afghanistan  2000 cases            2666
##  4 Afghanistan  2000 population   20595360
##  5 Brazil       1999 cases           37737
##  6 Brazil       1999 population  172006362
##  7 Brazil       2000 cases           80488
##  8 Brazil       2000 population  174504898
##  9 China        1999 cases          212258
## 10 China        1999 population 1272915272
## 11 China        2000 cases          213766
## 12 China        2000 population 1280428583
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Les valeurs sont stockées dans plusieurs tables. C'est le cas de ces deux tables (une contenant les informations sur la population, l'autre sur le nombre de cas de tuberculoses) qui auraient pu être regroupées en une seule table
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DSR}\SpecialCharTok{::}\NormalTok{table4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 3
##   country     `1999` `2000`
##   <fct>        <int>  <int>
## 1 Afghanistan    745   2666
## 2 Brazil       37737  80488
## 3 China       212258 213766
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DSR}\SpecialCharTok{::}\NormalTok{table5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 3
##   country         `1999`     `2000`
##   <fct>            <int>      <int>
## 1 Afghanistan   19987071   20595360
## 2 Brazil       172006362  174504898
## 3 China       1272915272 1280428583
\end{verbatim}

On va présenter ici les fonctions principales du package \textbf{tidyr} (ce package fait partie de la bibliothèque \textbf{tidyverse}) qui permettent de passer d'un format \emph{messy} à un format \emph{tidy} ou inversement.

\hypertarget{la-fonction-pivot_longer-transformer-des-colonnes-en-lignes}{%
\subsection{\texorpdfstring{La fonction \emph{pivot\_longer()} : transformer des colonnes en lignes}{La fonction pivot\_longer() : transformer des colonnes en lignes}}\label{la-fonction-pivot_longer-transformer-des-colonnes-en-lignes}}

Cette fonction permet de représenter en 1 seul colonne (et d'ajouter une colonne correspondant à une variable qualitative où les modalités sont le nom des variables initiales), une variable contenue à l'origine dans plusieurs colonnes.

\begin{figure}
\includegraphics[width=0.8\linewidth,height=\textheight]{Figures/pivot_longer} \end{figure}

L'argument \textbf{cols} indique les variables à transformer en ligne, l'argument \textbf{names\_to} correspond au nom donné à la variable contenant les nouvelles modalités (le nom des variables) et l'argument \textbf{values\_to} correspond au nom de la colonne contenant les valeurs qui ont été transformées de colonnes en lignes.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pivot\_longer}\NormalTok{(DSR}\SpecialCharTok{::}\NormalTok{table4, }
             \AttributeTok{cols =} \FunctionTok{c}\NormalTok{(}\StringTok{"1999"}\NormalTok{, }\StringTok{"2000"}\NormalTok{),}
             \AttributeTok{names\_to =} \StringTok{"years"}\NormalTok{,}
             \AttributeTok{values\_to =} \StringTok{"cases"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 3
##   country     years  cases
##   <fct>       <chr>  <int>
## 1 Afghanistan 1999     745
## 2 Afghanistan 2000    2666
## 3 Brazil      1999   37737
## 4 Brazil      2000   80488
## 5 China       1999  212258
## 6 China       2000  213766
\end{verbatim}

Avant \emph{pivot\_longer()}, il était possible d'utiliser la fonction \emph{gather()}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gather}\NormalTok{(DSR}\SpecialCharTok{::}\NormalTok{table4, }\StringTok{"year"}\NormalTok{, }\StringTok{"cases"}\NormalTok{, }\DecValTok{2}\SpecialCharTok{:}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 3
##   country     year   cases
##   <fct>       <chr>  <int>
## 1 Afghanistan 1999     745
## 2 Brazil      1999   37737
## 3 China       1999  212258
## 4 Afghanistan 2000    2666
## 5 Brazil      2000   80488
## 6 China       2000  213766
\end{verbatim}

Avant toutes ces fonctions, il aurait fallu exécuter ce genre de commandes où l'opération mathématique consiste à transformer une matrice en un vecteur.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{country =} \FunctionTok{rep}\NormalTok{(DSR}\SpecialCharTok{::}\NormalTok{table4}\SpecialCharTok{$}\NormalTok{country, }\AttributeTok{times =} \DecValTok{2}\NormalTok{),}
  \AttributeTok{year =} \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"1999"}\NormalTok{, }\StringTok{"2000"}\NormalTok{), }\AttributeTok{each =} \FunctionTok{nrow}\NormalTok{(DSR}\SpecialCharTok{::}\NormalTok{table4)), }
  \AttributeTok{cases =} \FunctionTok{as.vector}\NormalTok{(}\FunctionTok{as.matrix}\NormalTok{(DSR}\SpecialCharTok{::}\NormalTok{table4[ , }\FunctionTok{c}\NormalTok{(}\StringTok{"1999"}\NormalTok{, }\StringTok{"2000"}\NormalTok{)]))}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       country year  cases
## 1 Afghanistan 1999    745
## 2      Brazil 1999  37737
## 3       China 1999 212258
## 4 Afghanistan 2000   2666
## 5      Brazil 2000  80488
## 6       China 2000 213766
\end{verbatim}

\hypertarget{la-fonction-pivot_wider-transformer-des-lignes-en-colonnes}{%
\subsection{\texorpdfstring{La fonction \emph{pivot\_wider()} : transformer des lignes en colonnes}{La fonction pivot\_wider() : transformer des lignes en colonnes}}\label{la-fonction-pivot_wider-transformer-des-lignes-en-colonnes}}

Cette fonction permet de re-distribuer les valeurs d'une colonne qui contenait l'information de plusieurs variables, en plusieurs colonnes où chaque colonne correspond à une variable.

\begin{figure}
\includegraphics[width=0.8\linewidth,height=\textheight]{Figures/pivot_wider} \end{figure}

L'argument \textbf{names\_from} correspond au nom de la colonne qui contient le nom des variables, et l'argument \textbf{values\_from} correspond au nom de la colonne qui contient les valeurs à re-distribuer :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pivot\_wider}\NormalTok{(DSR}\SpecialCharTok{::}\NormalTok{table2, }\AttributeTok{names\_from =}\NormalTok{ key, }
            \AttributeTok{values\_from =}\NormalTok{ value)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 4
##   country      year  cases population
##   <fct>       <int>  <int>      <int>
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583
\end{verbatim}

Avant \emph{pivot\_wider()}, il était possible d'utiliser la fonction \emph{spread()}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{spread}\NormalTok{(DSR}\SpecialCharTok{::}\NormalTok{table2, key, value)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 4
##   country      year  cases population
##   <fct>       <int>  <int>      <int>
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583
\end{verbatim}

Avant la création de ces fonctions, il aurait fallu utiliser la fonction \emph{split()} et \emph{merge()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sp\_DSR }\OtherTok{\textless{}{-}} \FunctionTok{split}\NormalTok{(DSR}\SpecialCharTok{::}\NormalTok{table2[, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{)],  DSR}\SpecialCharTok{::}\NormalTok{table2[, }\DecValTok{3}\NormalTok{]) }
\FunctionTok{names}\NormalTok{(sp\_DSR}\SpecialCharTok{$}\NormalTok{cases)[}\DecValTok{3}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"cases"}
\FunctionTok{names}\NormalTok{(sp\_DSR}\SpecialCharTok{$}\NormalTok{population)[}\DecValTok{3}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"population"}
\FunctionTok{merge}\NormalTok{(sp\_DSR}\SpecialCharTok{$}\NormalTok{cases, sp\_DSR}\SpecialCharTok{$}\NormalTok{population,}
      \AttributeTok{by.x =} \FunctionTok{c}\NormalTok{(}\StringTok{"country"}\NormalTok{, }\StringTok{"year"}\NormalTok{),}
      \AttributeTok{by.y =} \FunctionTok{c}\NormalTok{(}\StringTok{"country"}\NormalTok{, }\StringTok{"year"}\NormalTok{),)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       country year  cases population
## 1 Afghanistan 1999    745   19987071
## 2 Afghanistan 2000   2666   20595360
## 3      Brazil 1999  37737  172006362
## 4      Brazil 2000  80488  174504898
## 5       China 1999 212258 1272915272
## 6       China 2000 213766 1280428583
\end{verbatim}

\hypertarget{la-fonction-separate}{%
\subsubsection{\texorpdfstring{La fonction \emph{separate()}}{La fonction separate()}}\label{la-fonction-separate}}

Cette fonction permet de séparer une colonne en deux variables dès qu'elle détecte un caractère de séparation. Par exemple, pour spliter la colonne \textbf{rate} de la \textbf{table3}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{separate}\NormalTok{(table3, rate, }\AttributeTok{into =} \FunctionTok{c}\NormalTok{(}\StringTok{"cases"}\NormalTok{, }\StringTok{"population"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 4
##   country      year cases  population
##   <chr>       <int> <chr>  <chr>     
## 1 Afghanistan  1999 745    19987071  
## 2 Afghanistan  2000 2666   20595360  
## 3 Brazil       1999 37737  172006362 
## 4 Brazil       2000 80488  174504898 
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583
\end{verbatim}

\hypertarget{la-fonction-unite}{%
\subsubsection{\texorpdfstring{La fonction \emph{unite()}}{La fonction unite()}}\label{la-fonction-unite}}

Cette fonction permet de faire l'opération inverse de \emph{separate()}. Elle permet de concaténer deux variables. Le résultat est proche de celui de la fonction \emph{paste()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{unite}\NormalTok{(DSR}\SpecialCharTok{::}\NormalTok{table1, }\AttributeTok{col =} \StringTok{"rate"}\NormalTok{,}
\NormalTok{      cases, population, }\AttributeTok{sep =} \StringTok{"/"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 3
##   country      year rate             
##   <fct>       <int> <chr>            
## 1 Afghanistan  1999 745/19987071     
## 2 Afghanistan  2000 2666/20595360    
## 3 Brazil       1999 37737/172006362  
## 4 Brazil       2000 80488/174504898  
## 5 China        1999 212258/1272915272
## 6 China        2000 213766/1280428583
\end{verbatim}

\hypertarget{la-fonction-extract}{%
\subsubsection{\texorpdfstring{La fonction \emph{extract()}}{La fonction extract()}}\label{la-fonction-extract}}

Cette fonction permet de spliter une colonne en deux en précisant quelle chaîne de caractère est utilisée pour le split. Dans l'exemple ci-dessous, on splitte une chaîne de caractère lorsqu'il y a un espace dans une chaîne de caractère. Pour cela, on utilise l'argument \textbf{regex=} qui indique une expression régulière ``REGEX''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_to\_split }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{player =} \FunctionTok{c}\NormalTok{(}\StringTok{"Lionel Messi"}\NormalTok{, }\StringTok{"Christiano Ronaldo"}\NormalTok{, }\StringTok{"Antoine Griezman"}\NormalTok{),}
  \AttributeTok{prix =} \FunctionTok{c}\NormalTok{(}\DecValTok{170}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{120}\NormalTok{))}
\FunctionTok{extract}\NormalTok{(df\_to\_split, }
        \AttributeTok{col =}\NormalTok{ player,}
        \AttributeTok{into =} \FunctionTok{c}\NormalTok{(}\StringTok{"prenom"}\NormalTok{, }\StringTok{"nom"}\NormalTok{),}
        \AttributeTok{regex =} \StringTok{"\^{}(.).* (.).*$"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   prenom nom prix
## 1      L   M  170
## 2      C   R  100
## 3      A   G  120
\end{verbatim}

Ceci aurait pu se faire en utilisant la fonction \emph{strsplit()}.

\hypertarget{la-fonction-complete}{%
\subsubsection{\texorpdfstring{La fonction \emph{complete()}}{La fonction complete()}}\label{la-fonction-complete}}

Cette fonction permet d'ajouter des lignes dans le cas où une valeur serait manquante. Par exemple, si on considère le jeu de données suivant, on constate que la firme B n'a pas de valeurs de CA pour l'année 2009.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{firms }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{firms =} \FunctionTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{),}
  \AttributeTok{years =} \FunctionTok{c}\NormalTok{(}\StringTok{"2008"}\NormalTok{, }\StringTok{"2009"}\NormalTok{, }\StringTok{"2008"}\NormalTok{),}
  \AttributeTok{CA =} \FunctionTok{c}\NormalTok{(}\DecValTok{20000}\NormalTok{, }\DecValTok{25000}\NormalTok{, }\DecValTok{40000}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Pour changer cela, on utilise la fonction \emph{complete()} de la façon suivante:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{complete}\NormalTok{(firms, firms, years)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 4 x 3
##   firms years    CA
##   <chr> <chr> <dbl>
## 1 A     2008  20000
## 2 A     2009  25000
## 3 B     2008  40000
## 4 B     2009     NA
\end{verbatim}

Pour plus de documentation sur l'univers \textbf{tidyr}, on recommande la lecture de \href{https://juba.github.io/tidyverse/12-tidyr.html\#fn19}{cette page} écrite par Julien Barnier.

\textbf{Exercice 1.9.}

\textbf{Q1} Découper en 3 variables (\textbf{ville}, \textbf{num}, \textbf{dep}), le vecteur suivant :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{code\_INSEE }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"toulouse\_31\_HG"}\NormalTok{, }\StringTok{"lyon\_69\_Rhone"}\NormalTok{, }\StringTok{"marsei\_13\_PACA"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{gestion-de-donnuxe9es-volumineuses}{%
\section{Gestion de données volumineuses}\label{gestion-de-donnuxe9es-volumineuses}}

Ici, nous allons essentiellement parler de données ``moyennement volumineuses'', à savoir des données qui prennent entre 1 et 2 Go de RAM, ce qui correspond très approximativement à des jeux de données contenant quelques millions de lignes et quelques dizaines de variables. Nous parlerons des packages qui permettent de traiter des bases de données plus volumineuses, sans rentrer dans les détails.

\hypertarget{optimiser-la-fonction-read.table}{%
\subsection{\texorpdfstring{Optimiser la fonction \emph{read.table()}}{Optimiser la fonction read.table()}}\label{optimiser-la-fonction-read.table}}

\hypertarget{astuce-1}{%
\subsubsection{Astuce 1}\label{astuce-1}}

Une première astuce concernant la gestion de données volumineuses consiste à mieux gérer l'importation des données. Regardons ce que cela donne avec un fichier contenant 500000 lignes et 3 colonnes.

\begin{itemize}
\tightlist
\item
  Commençons par générer des données :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{500000} \CommentTok{\# à modifier selon la mémoire vive de votre machine}
\NormalTok{donnees\_a\_importer }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{chiffre =} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n,}
 \AttributeTok{lettre =} \FunctionTok{paste0}\NormalTok{(}\StringTok{"caract"}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\NormalTok{n), }
 \AttributeTok{date =} \FunctionTok{sample}\NormalTok{(}\FunctionTok{seq.Date}\NormalTok{(}\FunctionTok{as.Date}\NormalTok{(}\StringTok{"2017{-}10{-}01"}\NormalTok{), }\AttributeTok{by =} \StringTok{"day"}\NormalTok{, }\AttributeTok{len =} \DecValTok{100}\NormalTok{), n, }
               \AttributeTok{replace =}\NormalTok{ T))}
\FunctionTok{object.size}\NormalTok{(donnees\_a\_importer)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 40001136 bytes
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(donnees\_a\_importer)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    500000 obs. of  3 variables:
##  $ chiffre: int  1 2 3 4 5 6 7 8 9 10 ...
##  $ lettre : chr  "caract1" "caract2" "caract3" "caract4" ...
##  $ date   : Date, format: "2017-12-04" "2017-10-01" ...
\end{verbatim}

Ce jeu de données utilise environ 38Mo de mémoire vive ou RAM (pour un rappel sur les différents types de mémoire, voir ce \href{https://cours-informatique-gratuit.fr/cours/disque-dur-et-ram/}{tutoriel} intéressant). Il contient 3 variables : la 1ère au format \textbf{integer} (un \textbf{integer} occupe moins de mémoires qu'un \textbf{double}), la seconde au format \textbf{factor}, le troisième au format \textbf{Date}.

\begin{itemize}
\tightlist
\item
  Exportons ces données dans un fichier avec la fonction \emph{write.table()} :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{write.table}\NormalTok{(donnees\_a\_importer, }\StringTok{"fichier.txt"}\NormalTok{, }\AttributeTok{row.names =}\NormalTok{ F)}
\end{Highlighting}
\end{Shaded}

On peut connaître la taille du fichier en mémoire disque :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{file.info}\NormalTok{(}\StringTok{"fichier.txt"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

On dispose ainsi d'un fichier appelé \emph{fichier.txt} dans l'espace de travail, qui pèse environ 16Mo.

\begin{itemize}
\tightlist
\item
  Importons ces données avec la fonction \emph{read.table()} en mesurant le temps pris pour accomplir cette action. On remarque que les 2ème et 3ème variables ont été stockées en tant que \textbf{factor} (parce que on lui a demandé en utilisant l'option \textbf{stringsAsFactors = TRUE}).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(import1 }\OtherTok{\textless{}{-}} \FunctionTok{read.table}\NormalTok{(}\StringTok{"fichier.txt"}\NormalTok{, }\AttributeTok{header =}\NormalTok{ T, }
                                  \AttributeTok{stringsAsFactors =} \ConstantTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## utilisateur     système      écoulé 
##       2.746       0.027       2.779
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(import1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    500000 obs. of  3 variables:
##  $ chiffre: int  1 2 3 4 5 6 7 8 9 10 ...
##  $ lettre : Factor w/ 500000 levels "caract1","caract10",..: 1 111112 222223 333334 444445 455557 466668 477779 488890 2 ...
##  $ date   : Factor w/ 100 levels "2017-10-01","2017-10-02",..: 65 1 56 95 64 100 21 62 15 34 ...
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Exécutons la même opération en précisant que les chaînes de caractères seront stockées sous forme de \textbf{character}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(import2 }\OtherTok{\textless{}{-}} \FunctionTok{read.table}\NormalTok{(}\StringTok{"fichier.txt"}\NormalTok{, }\AttributeTok{header =}\NormalTok{ T,}
                                  \AttributeTok{stringsAsFactors =} \ConstantTok{FALSE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## utilisateur     système      écoulé 
##       0.456       0.004       0.460
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(import2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    500000 obs. of  3 variables:
##  $ chiffre: int  1 2 3 4 5 6 7 8 9 10 ...
##  $ lettre : chr  "caract1" "caract2" "caract3" "caract4" ...
##  $ date   : chr  "2017-12-04" "2017-10-01" "2017-11-25" "2018-01-03" ...
\end{verbatim}

Le gain de temps dans le second cas vient du fait qu'on demande à ce que les variables qualitatives ne soient pas codées en \textbf{factor}. En effet, pour créer un \textbf{factor}, \textbf{R} a besoin de parcourir l'ensemble du fichier pour identifier tous les \textbf{levels} possibles, pour pouvoir attribuer un numéro à chaque \textbf{levels}. Cette procédure n'est évidemment pas optimale et il s'agissait d'une critique majeure concernant les objets \textbf{data.frame}, à savoir que les variables qualitatives sont codées par défaut en \textbf{factor} jusqu'à 2019. Depuis la version 4.0.0., l'argument *stringsAsFactors** vaut :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{default.stringsAsFactors}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

En effet, depuis la conférence useR!2019 qui s'est tenue à Toulouse, les chaînes de caractères sont à présent sauvegardées au format \textbf{character}. L'idée avancée était qu'un \textbf{factor} ordonne les caractères selon des règles lexicographiques qui ne sont pas les mêmes d'un pays à un autre. Autrement dit, compte tenu que ces règles sont définies par la machine utilisée, on peut obtenir des résultats différents d'une machine à une autre et la reproductibilité d'un même code n'était donc plus assurée. Pour plus de détails , voir \href{https://developer.r-project.org/Blog/public/2020/02/16/stringsasfactors/index.html}{ce message}.

\hypertarget{astuce-2}{%
\subsubsection{Astuce 2}\label{astuce-2}}

Pour importer un gros fichier, nous conseillons d'utiliser dans un premier temps la fonction \emph{read.table()} (ou \emph{read.csv()}, etc) sur les quelques premières lignes du fichier (entre 20 et 100 lignes selon la taille du fichier), puis d'analyser la structure du jeu de données, plus particulièrement le type de chaque colonne :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bigfile\_sample }\OtherTok{\textless{}{-}} \FunctionTok{read.table}\NormalTok{(}\StringTok{"fichier.txt"}\NormalTok{, }\AttributeTok{stringsAsFactors =} \ConstantTok{FALSE}\NormalTok{, }
                             \AttributeTok{header =}\NormalTok{ T, }\AttributeTok{nrows =} \DecValTok{20}\NormalTok{)}
\NormalTok{(bigfile\_colclass }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(bigfile\_sample, class))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     chiffre      lettre        date 
##   "integer" "character" "character"
\end{verbatim}

Dans un second temps, on importe la table en précisant le type de chaque colonne (par défaut l'option \textbf{stringsAsFactors = FALSE} donc ce n'est pas la peine de l'ajouter), ce qui aura pour effet de diminuer encore légèrement le temps de traitement.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(bigfile\_raw }\OtherTok{\textless{}{-}} \FunctionTok{read.table}\NormalTok{(}\StringTok{"fichier.txt"}\NormalTok{, }\AttributeTok{header =}\NormalTok{ T, }
                    \AttributeTok{colClasses =}\NormalTok{ bigfile\_colclass)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## utilisateur     système      écoulé 
##       0.338       0.003       0.343
\end{verbatim}

\textbf{Remarque 1 :} si le type d'une colonne a été mal spécifié, cela pourra créer un message d'erreur.

\textbf{Remarque 2 :} si vous êtes sûr que le fichier ne contient pas de lignes de commentaires, vous pouvez encore améliorer le temps de lecture en précisant l'option \textbf{comment.char=``\,``}, ce qui permettra d'éviter de faire une recherche systématique de caractères de commentaires.

\hypertarget{le-package-readr}{%
\subsection{\texorpdfstring{Le package \textbf{readr}}{Le package readr}}\label{le-package-readr}}

Nous présentons ici le package \textbf{readr}, faisant également partie du projet \textbf{tidyverse} et dont l'objectif est encore et toujours de rendre les codes plus simples et calculs plus rapides. Pour cela, les fonctions de ce package utilisent du code \textbf{C++} ce qui vous le verrez permet de faire des améliorations considérables en temps de calcul. Parmi les fonctions de ce package, \emph{read\_csv()} ou \emph{read\_table()} dont le but est bien entendu l'importation de fichiers \textbf{csv} ou \textbf{txt}. Elles ont été programmées de telle sorte qu'il suffit en général de les appeler en précisant uniquement le chemin d'accès du fichier à importer.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(}
\NormalTok{ tibble.don }\OtherTok{\textless{}{-}} \FunctionTok{read\_table2}\NormalTok{(}\StringTok{"fichier.txt"}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## -- Column specification --------------------------------------------------------
## cols(
##   `"chiffre"` = col_double(),
##   `"lettre"` = col_character(),
##   `"date"` = col_date(format = "")
## )
\end{verbatim}

\begin{verbatim}
## utilisateur     système      écoulé 
##       0.324       0.004       0.330
\end{verbatim}

L'objet importé n'est pas un \textbf{data.frame} mais un \textbf{tibble} que nous avons déjà vu précédemment :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(tibble.don)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "spec_tbl_df" "tbl_df"      "tbl"         "data.frame"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{object.size}\NormalTok{(tibble.don)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 44004504 bytes
\end{verbatim}

Ce type de format ne s'est pas encore généralisé à toutes les fonctions de \textbf{R}. Il se peut donc que vous rencontriez des difficultés pour utiliser certaines fonctions sur ce type d'objets. Pour passer du format \textbf{tibble} au \textbf{data.frame}, cela se fait très facilement au moyen de la fonction \textbf{as.data.frame}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{don }\OtherTok{\textless{}{-}} \FunctionTok{as.data.frame}\NormalTok{(tibble.don)}
\end{Highlighting}
\end{Shaded}

\textbf{Autres formats de données :} dans la même lignée que \textbf{readr}, nous citons également le package \textbf{readxl} pour la lecture de fichiers \emph{xls/xlsx}, ainsi que le package \textbf{haven} pour la lecture de données issue des logiciels \textbf{SPSS}, \textbf{Stata} ou \textbf{SAS}.

\textbf{Bibliographie:} pour l'usage du package \textbf{readr}, le lecteur pourra consulter ce document \url{http://readr.tidyverse.org/}.

\hypertarget{autres-packages}{%
\subsection{Autres packages}\label{autres-packages}}

Voici 3 packages, parmi d'autres, susceptibles d'aider l'utilisateur à manipuler des fichiers de données volumineux.

\hypertarget{package-data.table}{%
\subsubsection{\texorpdfstring{Package \textbf{data.table}}{Package data.table}}\label{package-data.table}}

Ce package est un package concurent au projet \textbf{tidyverse}, l'objectif de ce package étant également de rendre les lignes de codes plus élégantes, les calculs plus rapides, notamment en présence de données volumineuses. Le package \textbf{data.table} est plus ancien que le projet \textbf{tidyverse}, mais ce dernier bénéficiant du support financier de \textbf{RStudio}, il semble à ce jour plus intéressant de choisir l'univers \textbf{tidyverse} qui devrait bénéficier de plus de développements par la suite. Nous présentons toutefois ici quelques exemples d'utilisation de \textbf{data.table}.

Pour importer un jeu de données :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"data.table"}\NormalTok{)}
\FunctionTok{system.time}\NormalTok{(}
\NormalTok{objet.data.table }\OtherTok{\textless{}{-}} \FunctionTok{fread}\NormalTok{(}\StringTok{"fichier.txt"}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## utilisateur     système      écoulé 
##       0.411       0.004       0.091
\end{verbatim}

L'objet créé appartient à la classe d'objet \textbf{data.table} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(objet.data.table)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "data.table" "data.frame"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{object.size}\NormalTok{(objet.data.table)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 40001760 bytes
\end{verbatim}

Pour manipuler ce format de données, il faut se familiariser avec une nouvelle syntaxe propre à ce genre de données. Le lecteur pourra consulter la note suivante s'il souhaite utiliser ce package : \url{https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html}

\hypertarget{package-ff}{%
\subsubsection{\texorpdfstring{Package \textbf{ff}}{Package ff}}\label{package-ff}}

Pour des données trop volumineuses par rapport à la mémoire vive disponible de la machine, la package \textbf{ff} va faire en sorte de ne charger qu'une partie des données en mémoire vive que lorsqu'il en aura besoin.

Ici, on créé un fichier \emph{``big\_file.csv''} qui va contenir 50,000,000 observations et 3 colonnes. Pour faire cela, on va concaténer 100 fois \textbf{Donnees.a.importer} au fichier de sortie \emph{big\_file.csv} en utilisant la fonction \emph{write\_csv()}. L'opération peut prendre quelques minutes et c'est pourquoi pour informer l'utilisateur du temps restant, on propose d'utiliser la fonction \emph{progress\_estimated()}, qui fait avancer une barre au début de chaque nouvelle boucle (ici la boucle est répétée 100 fois).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{write\_csv}\NormalTok{(donnees\_a\_importer, }\StringTok{"big\_file.csv"}\NormalTok{)}

\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{progress\_estimated}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{(k }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{)\{}
\NormalTok{  p}\SpecialCharTok{$}\FunctionTok{pause}\NormalTok{(}\FloatTok{0.1}\NormalTok{)}\SpecialCharTok{$}\FunctionTok{tick}\NormalTok{()}\SpecialCharTok{$}\FunctionTok{print}\NormalTok{()}
  \FunctionTok{write\_csv}\NormalTok{(donnees\_a\_importer, }\StringTok{"big\_file.csv"}\NormalTok{, }\AttributeTok{append =}\NormalTok{ T)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

La taille du fichier créé, d'environ 1.5Go est encore théoriquement manipulable sur \textbf{R} (essayer de le faire via la fonction \emph{read.csv()}), mais on va supposer ici qu'on ne souhaite pas charger ce jeu de données intégralement en mémoire vive. Pour cela, on va utiliser la fonction \emph{read.csv.ffdf()} du package \textbf{ff}. On spécifie comme options que l'on souhaite lire les données par groupe de 5,000,000 d'observations, excepté la première fois où l'on va lire 500,000 observations

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"ff"}\NormalTok{)}
\NormalTok{bigDF }\OtherTok{\textless{}{-}} \FunctionTok{read.csv.ffdf}\NormalTok{(}\AttributeTok{file=}\StringTok{"big\_file.csv"}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{,}
                       \AttributeTok{first.rows =} \DecValTok{500000}\NormalTok{, }\AttributeTok{next.rows =} \DecValTok{5000000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

L'objet créé ne prend qu'une partie de la mémoire vive.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bigDF}
\FunctionTok{object.size}\NormalTok{(bigDF)}
\end{Highlighting}
\end{Shaded}

L'idée de ce package est de stocker les variables non pas en mémoire vive, mais quelque part sur le disque dur et d'y accéder en utilisant des pointeurs. On peut effectuer un certain nombre d'opérations sur ces objets. Par exemple, pour calculer la moyenne de la variable \textbf{chiffre} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"ffbase"}\NormalTok{)}
\FunctionTok{mean.ff}\NormalTok{(bigDF}\SpecialCharTok{$}\NormalTok{chiffre)}
\end{Highlighting}
\end{Shaded}

\textbf{Remarque:} on citera également le package \textbf{bigmemory} dont le principe est similaire. Plus récemment, le package \href{https://cran.r-project.org/web/packages/disk.frame/readme/README.html}{\textbf{disk.frame}} semble également promis à un bel avenir.

\hypertarget{algorithme-de-type-mapreducce}{%
\subsection{Algorithme de type Map/Reducce}\label{algorithme-de-type-mapreducce}}

On peut utiliser un algorithme de type \emph{Map/Reduce} pour éviter d'importer un jeu de données trop volumineux sur la RAM. A la base, ce type d'algorithme s'applique sur des données qui sont organisées selon l'approche conceptuelle d'Hadoop, où les fichiers de données sont fractionnés en gros bloc et distribués à travers les noeuds d'un cluster.

Dans cet exemple, nous n'avons qu'un gros fichier de données, l'idée étant d'importer des échantillons de ce jeu de données sur lesquels on va appliquer la première étape \emph{Map} de l'algorithme.

Par exemple, dans l'exemple ci-après, on a choisi d'importer les 5,000,000 premières observations, puis les 5,000,000 suivantes, etc. jusqu'à ce qu'on est parcouru tout le fichier. Sur chacun de ces échantillons, on va calculer d'une part la somme et d'autre part le maximum d'une variable quantitative.

Une fois réalisée cette étape sur les sous-échantillons, on va assembler les résultats obtenus à l'étape précédente. Pour calculer la moyenne, on va faire la somme sur les sommes obtenues et diviser ensuite par le nombre total d'observations et pour le max, on va calculer le maximum sur les maximum.

\textbf{Remarque :} on ne peut pas appliquer toutes les méthodes statistiques sur ce type d'algorithme (par exemple calculer un quantile nécessite de travailler sur l'échantillon complet). En revanche, ce type d'algorithme peut fonctionner pour calculer l'estimateur des moindres carrés d'un modèle linéaire. Par ailleurs, le calcul parallèle (que nous verrons dans un autre chapitre) pourra être envisagé sur ce type d'algorithme.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n\_split }\OtherTok{\textless{}{-}} \DecValTok{11}
\NormalTok{ind }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{n\_max }\OtherTok{\textless{}{-}} \DecValTok{5000001}
\NormalTok{my\_max }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(n\_split)}
\NormalTok{my\_mean }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(n\_split)}
\NormalTok{my\_n }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(n\_split)}
\ControlFlowTok{for}\NormalTok{ (k }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n\_split) \{}
\NormalTok{  split\_don }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(}\StringTok{"big\_file.csv"}\NormalTok{, }\AttributeTok{skip =}\NormalTok{ ind, }\AttributeTok{n\_max =}\NormalTok{ n\_max,}
                        \AttributeTok{col\_names =} \FunctionTok{c}\NormalTok{(}\StringTok{"chiffre"}\NormalTok{, }\StringTok{"lettre"}\NormalTok{, }\StringTok{"date"}\NormalTok{), }
                        \AttributeTok{col\_types =} \StringTok{"ncc"}\NormalTok{)}
\NormalTok{  my\_max[k] }\OtherTok{\textless{}{-}} \FunctionTok{max}\NormalTok{(split\_don}\SpecialCharTok{$}\NormalTok{chiffre)}
\NormalTok{  my\_mean[k] }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(split\_don}\SpecialCharTok{$}\NormalTok{chiffre)}
\NormalTok{  my\_n[k] }\OtherTok{\textless{}{-}} \FunctionTok{nrow}\NormalTok{(split\_don)}
\NormalTok{  ind }\OtherTok{\textless{}{-}}\NormalTok{ ind }\SpecialCharTok{+}\NormalTok{ n\_max}
\NormalTok{\}}
\FunctionTok{sum}\NormalTok{(my\_mean) }\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(my\_n)}
\FunctionTok{max}\NormalTok{(my\_max)}
\end{Highlighting}
\end{Shaded}

\hypertarget{package-matrix}{%
\subsubsection{\texorpdfstring{Package \textbf{Matrix}}{Package Matrix}}\label{package-matrix}}

Il est possible d'avoir suffisament de mémoires vives pour importer des données, mais pour certaines opérations algébriques et notamment le calcul matriciel, il y a des cas où on a besoin d'avoir plus de mémoires vives que ce dont nous disposons (typiquement une inversion de matrice). Dans ce cas-là, il est important de voir si les données sur lesquelles on travaille sont creuses ou non, c'est-à-dire contenant beaucoup de 0. Si c'est le cas, le package \textbf{Matrix} permet d'obtenir de bonnes performances en temps calcul et d'utiliser moins de RAM, grâce aux propriétés des matrices creuses.

Ce package s'utilise très simplement et la plupart des fonctions existantes pour le calcul matriciel (\emph{crossprod()}, \emph{solve()}, \%\textgreater\%) s'appliquent directement sur ce type d'objet. Pour plus d'informations sur ce package, consulter la \href{https://cran.r-project.org/web/packages/Matrix/vignettes/Intro2Matrix.pdf}{vignette}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"Matrix"}\NormalTok{)}
\NormalTok{mat }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rbinom}\NormalTok{(}\DecValTok{10000}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{0.05}\NormalTok{), }\DecValTok{100}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\FunctionTok{object.size}\NormalTok{(mat)}
\NormalTok{Mat }\OtherTok{\textless{}{-}} \FunctionTok{as}\NormalTok{(mat, }\StringTok{"Matrix"}\NormalTok{)}
\FunctionTok{object.size}\NormalTok{(Mat)}
\end{Highlighting}
\end{Shaded}

\hypertarget{interaction-avec-des-systuxe8mes-de-gestion-de-bases-de-donnuxe9es}{%
\subsection{Interaction avec des systèmes de gestion de bases de données}\label{interaction-avec-des-systuxe8mes-de-gestion-de-bases-de-donnuxe9es}}

Lorsqu'une entreprise travaille sur de gros volumes de données, cela sous-entend qu'elle dispose de systèmes de gestion de base de données.

\textbf{R} dispose de plusieurs packages permettant d'intéragir avec des systèmes de gestion de base de données : \textbf{RODBC}, \textbf{RMySQL}, \textbf{RPostgresSQL}, \textbf{RSQLite} ainsi qu'avec des bases de données orientées document comme \emph{MongoDB} et \emph{couchDB} via les packages \textbf{mongolite} et \textbf{couchDB}.

Le gros avantage de ces packages est qu'ils permettent de laisser les bases de données trop grandes sur l'espace disque et d'aller récupérer uniquement l'information dont on a besoin en envoyant depuis \textbf{R} des requêtes qui seront exécutées sur les systèmes de gestion de base de données.

\textbf{Bibliographie} pour le traitement de données volumineuses, nous recommendons la lecture de ce document : \url{https://rpubs.com/msundar/large_data_analysis}

\hypertarget{utiliser-la-syntaxe-sql}{%
\subsection{Utiliser la syntaxe SQL}\label{utiliser-la-syntaxe-sql}}

Pour celles et ceux qui sont familiers avec le langage SQL, le package \textbf{sqldf} permet d'utiliser la syntaxe SQL pour faire des requêtes depuis \textbf{R}.

Pour plus d'informations, voir : \url{https://github.com/ggrothendieck/sqldf}

\hypertarget{visualiser-et-traiter-les-donnuxe9es-manquantes}{%
\section{Visualiser et traiter les données manquantes}\label{visualiser-et-traiter-les-donnuxe9es-manquantes}}

On présente dans ce paragraphe quelques packages qui permettent de visualiser et traiter les données manquantes. Pour commencer, nous allons générer des valeurs manquantes de façon aléatoire dans le jeu de données \textbf{iris} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"missForest"}\NormalTok{)}
\NormalTok{iris.mis }\OtherTok{\textless{}{-}} \FunctionTok{prodNA}\NormalTok{(iris, }\FloatTok{0.05}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Le package \textbf{Amelia} permet de visualiser dans un graphique où sont localisées les données manquantes. Cela permet notamment de voir s'il existe un pattern ou une forme particulière (un bloc par exemple) parmi les valeurs manquantes :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"Amelia"}\NormalTok{)}
\FunctionTok{missmap}\NormalTok{(iris.mis, }\AttributeTok{main =} \StringTok{"Missing values vs observed"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-156-1.pdf}

On notera également les packages \textbf{visdat} et \textbf{naniar} qui proposent plusieurs outils pour visualiser les données manquantes. Par exemple, pour savoir si les valeurs manquantes d'une variable sont liées à une autre variable, on peut utiliser l'outils suivant :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(iris.mis, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ Sepal.Length, }\AttributeTok{y =}\NormalTok{ Sepal.Width)) }\SpecialCharTok{+} 
\NormalTok{  naniar}\SpecialCharTok{::}\FunctionTok{geom\_miss\_point}\NormalTok{() }\SpecialCharTok{+} 
  \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{Species)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-157-1.pdf}

Pour traiter les données manquantes, il existe plusieurs façons de procéder :

\begin{itemize}
\tightlist
\item
  ne rien faire. Dans ce cas, certaines fonctions comme la fonction \emph{lm()} enlève automatiquement les observations dès lors qu'il existe au moins une valeur manquante parmi les variables à expliquer et explicatives :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res\_lm }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(Sepal.Width }\SpecialCharTok{\textasciitilde{}}\NormalTok{ Sepal.Length }\SpecialCharTok{+}\NormalTok{ Petal.Length }\SpecialCharTok{+} 
\NormalTok{             Petal.Width }\SpecialCharTok{+}\NormalTok{ Species, }\AttributeTok{data =}\NormalTok{ iris.mis)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  supression des observations contenant au moins une valeur manquante en utilisant la fonction \emph{subset()} ou \emph{filter()} (du package \textbf{dplyr})
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris.mis }\OtherTok{\textless{}{-}} \FunctionTok{subset}\NormalTok{(iris.mis, }\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(Species))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  imputation par la moyenne ou la médiane lorsqu'il s'agit d'une variable numérique ou alors par le mode lorsqu'il s'agit d'une variable qualitative.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ind\_NA\_Sepal.Length }\OtherTok{\textless{}{-}} \FunctionTok{is.na}\NormalTok{(iris.mis}\SpecialCharTok{$}\NormalTok{Sepal.Length)}
\NormalTok{mean\_spec }\OtherTok{\textless{}{-}} \FunctionTok{aggregate}\NormalTok{(Sepal.Length }\SpecialCharTok{\textasciitilde{}}\NormalTok{ Species, }
                       \AttributeTok{data =}\NormalTok{ iris.mis, }\AttributeTok{FUN =}\NormalTok{ mean, }\AttributeTok{na.rm =}\NormalTok{ T)}
\ControlFlowTok{for}\NormalTok{ (k }\ControlFlowTok{in} \FunctionTok{levels}\NormalTok{(iris.mis}\SpecialCharTok{$}\NormalTok{Species)) \{}
\NormalTok{ iris.mis[ind\_NA\_Sepal.Length }\SpecialCharTok{\&}\NormalTok{ iris.mis}\SpecialCharTok{$}\NormalTok{Species }\SpecialCharTok{==}\NormalTok{ k, }
   \StringTok{"Sepal.Length"}\NormalTok{] }\OtherTok{\textless{}{-}}\NormalTok{ mean\_spec[mean\_spec}\SpecialCharTok{$}\NormalTok{Species }\SpecialCharTok{==}\NormalTok{ k, }\DecValTok{2}\NormalTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  imputation en utilisant des modèles linéaires afin de prédire les valeurs manquantes. Par exemple :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris.imp\_mean }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\FunctionTok{sapply}\NormalTok{(iris.mis[, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{], }
  \ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{ifelse}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(x), x, }\FunctionTok{mean}\NormalTok{(x, }\AttributeTok{na.rm =}\NormalTok{ T))),}
  \AttributeTok{Species =}\NormalTok{ iris.mis}\SpecialCharTok{$}\NormalTok{Species)}
\NormalTok{pred }\OtherTok{\textless{}{-}} \FunctionTok{predict.lm}\NormalTok{(res\_lm, }\AttributeTok{newdata =}\NormalTok{ iris.imp\_mean)}
\NormalTok{iris.mis[}\FunctionTok{is.na}\NormalTok{(iris.mis}\SpecialCharTok{$}\NormalTok{Sepal.Width), }\StringTok{"Sepal.Width"}\NormalTok{] }\OtherTok{\textless{}{-}}
\NormalTok{  pred[}\FunctionTok{is.na}\NormalTok{(iris.mis}\SpecialCharTok{$}\NormalTok{Sepal.Width)]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  imputation en utilisant des modèles de prédiction sophistiqués issus du machine learning. Par exemple, les forêts aléatoires ou les \(K\)-plus proches voisins :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"missForest"}\NormalTok{)}
\NormalTok{iris.imp }\OtherTok{\textless{}{-}} \FunctionTok{missForest}\NormalTok{(iris.mis)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   missForest iteration 1 in progress...done!
##   missForest iteration 2 in progress...done!
##   missForest iteration 3 in progress...done!
##   missForest iteration 4 in progress...done!
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"VIM"}\NormalTok{)}
\NormalTok{iris.knn }\OtherTok{\textless{}{-}} \FunctionTok{kNN}\NormalTok{(iris.mis, }\AttributeTok{k =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{ruxe9pertoires-et-fichiers}{%
\section{Répertoires et fichiers}\label{ruxe9pertoires-et-fichiers}}

Il existe plusieurs fonctions de base qui permettent la gestion des répertoires et fichiers. L'utilisation de la plupart de ces fonctions est intéressante lors de l'écriture de scripts ``propres'' qui stockeront les résultats dans des fichiers bien rangés dans des répertoires bien nommés.

Parmi ces fonctions :

\begin{itemize}
\tightlist
\item
  la fonction \emph{getwd()} retourne le chemin du répertoire de travail. Il s'agit du répertoire où seront sauvegardées par défaut les différentes opérations de sauvegarde (graphiques, codes, fichier historique, etc.) :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getwd}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "/home/laurent/Documents/R_book/R_book"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  la fonction \emph{dir()} retourne les fichiers et répertoires situés dans le chemin spécifié et éventuellement ses sous-répertoires (options \textbf{recursive = TRUE}). Par défaut, il s'agit du chemin correspondant à l'environnement de travail actuel (donné par \emph{getwd()}) :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dir}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "_book"                  "_bookdown_files"        "_bookdown.yml"         
##  [4] "_main_files"            "_main.log"              "_main.pdf"             
##  [7] "_main.Rmd"              "_main.tex"              "_output.yml"           
## [10] "01-data-management.Rmd" "02-programming.Rmd"     "03-parallel.Rmd"       
## [13] "04_graphics.Rmd"        "05-intro.Rmd"           "06-cross-refs.Rmd"     
## [16] "07-parts.Rmd"           "07-references.Rmd"      "08-citations.Rmd"      
## [19] "09-blocks.Rmd"          "10-share.Rmd"           "book.bib"              
## [22] "fichier.txt"            "Figures"                "index.Rmd"             
## [25] "packages.bib"           "preamble.tex"           "R"                     
## [28] "R_book.Rproj"           "README.md"              "Sorties"               
## [31] "style.css"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  la fonction \emph{file.info()} prend comme argument d'entrée des chemins de fichiers ou répertoires et retourne des informations les concernant (taille, etc.) :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{file.info}\NormalTok{(}\FunctionTok{dir}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  la fonction \emph{R.home()} retourne l'emplacement de \textbf{R} :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{R.home}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "/usr/lib/R"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  la fonction \emph{file.access()} donne des informations sur la permission accordée aux fichiers. Les permissions qui sont testées sont : existence (0), exécution (1), écriture (2) et lecture (4). La fonction retourne la valeur 0 pour oui et -1 pour non. Dans l'exemple qui suit, les fichiers qui sont situés dans le chemin où se situe \textbf{R} peuvent être lus et exécutés, mais sont en revanche protégés en écriture :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fic }\OtherTok{\textless{}{-}} \FunctionTok{dir}\NormalTok{(}\FunctionTok{file.path}\NormalTok{(}\FunctionTok{R.home}\NormalTok{(), }\StringTok{"bin"}\NormalTok{), }\AttributeTok{full =}\NormalTok{ T)}
\FunctionTok{file.access}\NormalTok{(fic, }\DecValTok{0}\NormalTok{)}
\FunctionTok{file.access}\NormalTok{(fic, }\DecValTok{1}\NormalTok{)}
\FunctionTok{file.access}\NormalTok{(fic, }\DecValTok{2}\NormalTok{)}
\FunctionTok{file.access}\NormalTok{(fic, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  la fonction \emph{dir.exists()} teste l'existence d'un répertoire et la fonction \emph{dir.create()} créé un répertoire.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dir.create}\NormalTok{(}\StringTok{"Sorties"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in dir.create("Sorties"): 'Sorties' existe déjà
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dir.exists}\NormalTok{(}\StringTok{"Sorties"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\textbf{Exercice 1.10.}

écrire une fonction qui, à partir d'un nombre entier \(n\) passé en paramètre, effectue un tirage aléatoire de \(n\) valeurs selon une loi normale \(\mathcal{N}(0,1)\) puis renvoie les valeurs générées dans un fichier d'un répertoire \emph{Num} et trace une boxplot de ces données qui sera stockée dans un fichier \emph{.jpg} du répertoire \emph{Graph}.

\hypertarget{autour-de-lespace-de-travail}{%
\section{Autour de l'espace de travail}\label{autour-de-lespace-de-travail}}

La fonction \emph{search()} donne la liste des packages (mais pas seulement) attachés à l'espace de travail. En gros, il s'agit des packages et environnements auxquels il est possible d'accéder dans la session en cours à l'instant \(t\). Cette liste évolue bien entendu au fur et à mesure de la session :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{search}\NormalTok{()}
\FunctionTok{library}\NormalTok{(}\StringTok{"foreign"}\NormalTok{)}
\FunctionTok{search}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

L'option \textbf{pos} de la fonction \emph{ls()} permet de lister le contenu d'un package particulier en donnant sa position dans la liste renvoyée par \emph{search()}. Vous pourrez en choisissant le bon indice, vous rendre compte de l'ensemble des fonctions accessibles depuis le package \textbf{base} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls}\NormalTok{(}\AttributeTok{pos =} \FunctionTok{which}\NormalTok{(}\FunctionTok{search}\NormalTok{() }\SpecialCharTok{==} \StringTok{"package:base"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Certains packages peuvent avoir des fonctions portant le même nom ; d'où le message d'avertissement ci-dessous au moment de charger un nouveau package, indiquant qu'un objet est masqué dans un package situé plus loin dans la liste \emph{search()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"pls"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Attachement du package : 'pls'
\end{verbatim}

\begin{verbatim}
## L'objet suivant est masqué depuis 'package:stats':
## 
##     loadings
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{search}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] ".GlobalEnv"           "package:pls"          "package:VIM"         
##  [4] "package:grid"         "package:colorspace"   "package:Amelia"      
##  [7] "package:Rcpp"         "package:missForest"   "package:itertools"   
## [10] "package:iterators"    "package:foreach"      "package:randomForest"
## [13] "package:data.table"   "package:forcats"      "package:dplyr"       
## [16] "package:purrr"        "package:readr"        "package:tidyr"       
## [19] "package:tibble"       "package:ggplot2"      "package:tidyverse"   
## [22] "package:gplots"       "package:zoo"          "package:classInt"    
## [25] "package:glue"         "package:stringr"      "package:wordcloud"   
## [28] "package:RColorBrewer" "package:stats"        "package:graphics"    
## [31] "package:grDevices"    "package:utils"        "package:datasets"    
## [34] "package:methods"      "Autoloads"            "package:base"
\end{verbatim}

Dans ce cas, si on souhaite obtenir l'aide de la ``bonne'' fonction, il suffit de précéder le nom de la fonction par le nom du package suivi de \emph{::}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{find}\NormalTok{(}\StringTok{"loadings"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "package:pls"   "package:stats"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?loadings}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Help on topic 'loadings' was found in the following packages:
## 
##   Package               Library
##   pls                   /home/laurent/R/x86_64-pc-linux-gnu-library/4.1
##   stats                 /usr/lib/R/library
## 
## 
## Utilisation de la première correspondance ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?stats}\SpecialCharTok{::}\NormalTok{loadings}
\end{Highlighting}
\end{Shaded}

\textbf{Remarque :} on pourra procéder de la même façon pour être sûr d'exécuter la ``bonne'' fonction.

On a vu précédement que pour accéder à un élément d'une \textbf{list} ou d'un \textbf{data.frame}, il est nécessaire d'appeler cet objet suivi de l'opérateur \textbf{\$}. Il existe au moins deux façons de simplifier cette opération. La première consiste à utiliser la fonction \emph{with()} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{with}\NormalTok{(airquality,}
     \FunctionTok{summary}\NormalTok{(Ozone))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
##    1.00   18.00   31.50   42.13   63.25  168.00      37
\end{verbatim}

La seconde consiste à utiliser la fonction \emph{attach()} qui permet d'attacher tous les éléments d'un objet dans l'environnement de travail comme s'il s'agissait d'un package.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{e\_vec\_x =} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{),}
          \AttributeTok{e\_fic1 =} \ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{mean}\NormalTok{(x), }
          \AttributeTok{e\_fic2 =} \ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{mean}\NormalTok{((x}\SpecialCharTok{{-}}\FunctionTok{e\_fic1}\NormalTok{(x))}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\FunctionTok{attach}\NormalTok{(e)}
\FunctionTok{search}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] ".GlobalEnv"           "e"                    "package:pls"         
##  [4] "package:VIM"          "package:grid"         "package:colorspace"  
##  [7] "package:Amelia"       "package:Rcpp"         "package:missForest"  
## [10] "package:itertools"    "package:iterators"    "package:foreach"     
## [13] "package:randomForest" "package:data.table"   "package:forcats"     
## [16] "package:dplyr"        "package:purrr"        "package:readr"       
## [19] "package:tidyr"        "package:tibble"       "package:ggplot2"     
## [22] "package:tidyverse"    "package:gplots"       "package:zoo"         
## [25] "package:classInt"     "package:glue"         "package:stringr"     
## [28] "package:wordcloud"    "package:RColorBrewer" "package:stats"       
## [31] "package:graphics"     "package:grDevices"    "package:utils"       
## [34] "package:datasets"     "package:methods"      "Autoloads"           
## [37] "package:base"
\end{verbatim}

Ensuite, il est possible d'accéder directement aux éléments de la liste sans avoir à appeler l'objet \textbf{e} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{e\_fic1}\NormalTok{(e\_vec\_x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.6690173
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{e\_fic2}\NormalTok{(e\_vec\_x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.9399229
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{detach}\NormalTok{(e)}
\end{Highlighting}
\end{Shaded}

\textbf{Attention :} il faut être très prudent avec la fonction \emph{attach()}, car cela peut créer des conflits avec l'environnement global.

\textbf{Remarque :} il est parfois utile de connaître certains détails de l'environnement de travail notamment pour comprendre \emph{pourquoi ça ne marche pas !!!} (voir dessin ci-dessous). Les fonctions \emph{sessionInfo()} et \emph{R.Version()} peuvent permettre d'identifier certaines incompatibilités entre notre version de \textbf{R} et un package particulier que l'on vient d'installer.

\begin{figure}
\centering
\includegraphics{Figures/version.png}
\caption{ça ne marche pas !!!}
\end{figure}

\textbf{Exercice 1.11.}

\textbf{Q1} Quel est l'inconvénient illustré par les manipulations de \emph{e\_fic1()}, \textbf{e\_vec\_x} et \emph{e\_fic2()} ?

\textbf{Q2} à quoi sert l'opérateur \textbf{::} ?

\hypertarget{programmation}{%
\chapter{Programmation}\label{programmation}}

Nous allons voir dans ce chapitre des éléments de programmation qui permettent de gagner en clarté et simplicité dans le code et parfois en temps de calcul.

Ce document a été généré directement depuis \textbf{RStudio} en utilisant l'outil Markdown. La version \emph{.pdf} se trouve \href{chapitre_2_avance.pdf}{ici}.

\textbf{Packages à installer}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{((}\FunctionTok{c}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{, }\CommentTok{\# Graphiques ggplot2}
                    \StringTok{"kableExtra"}\NormalTok{, }\CommentTok{\# Insérer des tables dans Markdown}
                    \StringTok{"Matrix"}\NormalTok{, }\CommentTok{\# Matrice creuse}
                    \StringTok{"microbenchmark"}\NormalTok{, }\CommentTok{\# Temps de calcul}
                    \StringTok{"pryr"}\NormalTok{, }\CommentTok{\# Mieux comprendre R}
                    \StringTok{"Rcpp"}\NormalTok{, }\CommentTok{\# Faire appel à du code C++}
                    \StringTok{"reticulate"} \CommentTok{\# Interface vers Python}
\NormalTok{                    )))}
\end{Highlighting}
\end{Shaded}

On montre un exemple pour utiliser du code \textbf{Python}. Pour cela, on aura besoin de la bibliothèque \textbf{pandas}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reticulate}\SpecialCharTok{::}\FunctionTok{py\_install}\NormalTok{(}\StringTok{"pandas"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{quelques-ruxe8gles-de-style}{%
\section{Quelques règles de style}\label{quelques-ruxe8gles-de-style}}

\textbf{R} n'a pas de \href{https://www.python.org/dev/peps/pep-0008/}{PEP 8} comme c'est le cas pour Python. En revanche, pour des raisons évidentes de clarté et de lisibilité pour soi-même et pour les éventuels collègues qui vont lire notre code, il est important d'essayer de respecter si possible quelques règles d'écritures de codes. On s'est inspiré ici de ces deux documents :

\begin{itemize}
\item
  \href{http://adv-r.had.co.nz/Style.html}{``Style guide''''} de Hadley Wickham dans le livre ``\textbf{R} advanced''
\item
  \href{https://google.github.io/styleguide/Rguide.xml}{``Google's \textbf{R} style guide''}
\end{itemize}

\hypertarget{le-nom-des-fichiers-de-codes}{%
\subsection{Le nom des fichiers de codes}\label{le-nom-des-fichiers-de-codes}}

Appeler vos fichiers de code avec l'extension \emph{.R} et donner des noms clairs à vos fichiers de codes, en utilisant éventuellement le symbole underscore ou le trait d'union entre les différents mots. Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{traitement}\SpecialCharTok{{-}}\NormalTok{base.R}
\NormalTok{fonctions}\SpecialCharTok{{-}}\NormalTok{utiles.R}
\NormalTok{exploration.R}
\NormalTok{prediction.R}
\end{Highlighting}
\end{Shaded}

\hypertarget{le-nom-des-objets}{%
\subsection{Le nom des objets}\label{le-nom-des-objets}}

Eviter d'appeler vos objets avec des noms de fonctions existants ou de mots clés. Le nombre de caratères devrait être restreint même si le nom doit avoir un sens pour le lecteur. On peut utiliser le symbole underscore ou le point pour séparer des mots entre eux :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arbre\_reg}
\NormalTok{rf\_reg}
\NormalTok{glm\_reg}
\end{Highlighting}
\end{Shaded}

\hypertarget{espace-entre-les-opuxe9rateurs}{%
\subsection{Espace entre les opérateurs}\label{espace-entre-les-opuxe9rateurs}}

Aérer au maximum les opérations (affectation, calcul, utilisation de fonctions, etc.) par des espaces :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{) }
\FunctionTok{mean}\NormalTok{(a, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Exception faite pour les opérateurs \textbf{:}, \textbf{::} et \textbf{:::} où il ne faut pas d'espace :

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}
\NormalTok{stats}\SpecialCharTok{::}\NormalTok{lm}
\end{Highlighting}
\end{Shaded}

\hypertarget{les-conditions}{%
\subsection{Les conditions}\label{les-conditions}}

Quand on utilise les conditions \textbf{if/else}, \textbf{for}, \textbf{while} :

\begin{itemize}
\item
  laisser un espace après le mot clé,
\item
  l'accolade ouvrante se trouve à la fin de la ligne contenant le mot clé, l'accolande fermante se trouve sur une nouvelle ligne,
\item
  mettre deux espaces en début de ligne (indentation) à partir de la seconde ligne jusqu'à la fin de la condition,
\item
  si des conditions sont imbriquées, la nouvelle condition devrait se trouver sur la même ligne que l'accolade fermante de la première condition.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (y }\SpecialCharTok{\textless{}} \DecValTok{0} \SpecialCharTok{\&\&}\NormalTok{ debug) \{}
  \FunctionTok{message}\NormalTok{(}\StringTok{"Y is negative"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (y }\SpecialCharTok{==} \DecValTok{0}\NormalTok{) \{}
  \FunctionTok{log}\NormalTok{(x)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  y }\SpecialCharTok{\^{}}\NormalTok{ x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{la-taille-dune-ligne}{%
\subsection{La taille d'une ligne}\label{la-taille-dune-ligne}}

Essayer de limiter 80 caractères à une ligne de code.

\hypertarget{affectation}{%
\subsection{Affectation}\label{affectation}}

Pour affecter une valeur à un objet essayer d'utiliser l'opérateur \textbf{\textless-} plutôt que \textbf{=}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{5}
\end{Highlighting}
\end{Shaded}

\textbf{Remarque :} sur \textbf{RStudio} quelques-une des règles ci-dessus sont implémentées par défaut, notamment les indentations après les boucles ou les fonctions.

\textbf{Exercice 2.1}

Mettre le code suivant en utilisant les règles de style présentées ci-dessus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_mean}\OtherTok{=}\ControlFlowTok{function}\NormalTok{(x)}
\NormalTok{\{}
\CommentTok{\# verification}
\ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.numeric}\NormalTok{(x))}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"x must be a numeric vector"}\NormalTok{)}
\CommentTok{\# initialization}
\NormalTok{n}\OtherTok{=} \FunctionTok{length}\NormalTok{(x) }
\NormalTok{res }\OtherTok{=}\DecValTok{0}
\ControlFlowTok{for}\NormalTok{(k }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n) }
\NormalTok{\{}
\NormalTok{  res}\OtherTok{=}\NormalTok{ res}\SpecialCharTok{+}\NormalTok{x[k]}
\NormalTok{\}}
\CommentTok{\# return res}
  \FunctionTok{return}\NormalTok{(res}\SpecialCharTok{/}\NormalTok{ n)}
\NormalTok{\}  }
\end{Highlighting}
\end{Shaded}

\hypertarget{fixer-la-taille-des-vecteurs-si-on-la-connauxeet-uxe0-lavance}{%
\section{Fixer la taille des vecteurs (si on la connaît à l'avance)}\label{fixer-la-taille-des-vecteurs-si-on-la-connauxeet-uxe0-lavance}}

On a le problème suivant : on souhaite obtenir un vecteur de taille \(n\) contenant des valeurs simulées issues d'une loi gaussienne centrée et réduite, mais on ne souhaite garder que les valeurs supérieures à un paramètre \textbf{a} (égal à 0 par défaut). Dans la fonction \emph{trunc\_rnorm.1()} ci-dessous, nous ne précisons pas la taille du vecteur \textbf{x} qui sera retourné. A chaque fois qu'une valeur répond au critère, on la concatène au vecteur \textbf{x} en utilisant la commande \emph{c()}. Le défaut de cette méthode est que \textbf{R} est sans arrêt en train d'allouer un nouvel espace mémoire pour le vecteur \textbf{x} qu'on modifie à chaque fois puisqu'on change sa taille.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trunc\_rnorm}\FloatTok{.1} \OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n, }\AttributeTok{a =} \DecValTok{0}\NormalTok{) \{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\NormalTok{  i }\OtherTok{\textless{}{-}} \DecValTok{1}
  \ControlFlowTok{while}\NormalTok{ (i }\SpecialCharTok{\textless{}=}\NormalTok{ n) \{}
\NormalTok{    r }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ (r }\SpecialCharTok{\textgreater{}}\NormalTok{ a) \{}
\NormalTok{      x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(x, r)}
\NormalTok{      i }\OtherTok{=}\NormalTok{ i }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{ x}
\NormalTok{\}  }
\end{Highlighting}
\end{Shaded}

C'est pourquoi lorsqu'on connaît à l'avance la taille du vecteur qu'on souhaite créer, on créé le vecteur avec la bonne taille et l'espace mémoire alloué à ce vecteur est fixée dès le début. C'est la seule différence avec la fonction \emph{trunc\_rnorm.2()} ci-dessous où on a précisé la taille de \textbf{x} dès le départ. On affecte ensuite à chaque élément de \textbf{x} la valeur qu'on souhaite garder.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trunc\_rnorm}\FloatTok{.2} \OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n, }\AttributeTok{a =} \DecValTok{0}\NormalTok{) \{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(n)}
\NormalTok{  i }\OtherTok{\textless{}{-}} \DecValTok{1}
  \ControlFlowTok{while}\NormalTok{ (i }\SpecialCharTok{\textless{}=}\NormalTok{ n) \{}
\NormalTok{    r }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ (r }\SpecialCharTok{\textgreater{}}\NormalTok{ a) \{}
\NormalTok{      x[i] }\OtherTok{\textless{}{-}}\NormalTok{ r}
\NormalTok{      i }\OtherTok{\textless{}{-}}\NormalTok{ i }\SpecialCharTok{+} \DecValTok{1}\NormalTok{\}}
\NormalTok{    \}}
\NormalTok{  x}
\NormalTok{\}  }
\end{Highlighting}
\end{Shaded}

On constate que les différences de temps de calcul sont assez importantes :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(}\FunctionTok{trunc\_rnorm.1}\NormalTok{(}\DecValTok{10000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## utilisateur     système      écoulé 
##       0.441       0.024       0.465
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(}\FunctionTok{trunc\_rnorm.2}\NormalTok{(}\DecValTok{10000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## utilisateur     système      écoulé 
##       0.055       0.000       0.055
\end{verbatim}

\hypertarget{temps-de-calcul-et-muxe9moire}{%
\section{Temps de calcul et mémoire}\label{temps-de-calcul-et-muxe9moire}}

\hypertarget{pour-mesurer-les-temps-de-calcul-efficacement}{%
\subsection{Pour mesurer les temps de calcul efficacement}\label{pour-mesurer-les-temps-de-calcul-efficacement}}

Si vous répétez les instructions précédentes successivement, vous constaterez que les temps de calculs sont à chaque fois différents. Ceci s'explique par le fait que les machines sur lesquelles on travaille exécutent plusieurs tâches à la fois, qui ne sont pas toujours les mêmes à l'instant \(t\). Aussi, une façon de rendre robuste ces temps de calcul est de répéter un certain nombre de fois ces mêmes commandes et de présenter ensuite les résultats statistiques sur ces temps de calcul.

Pour cela, on peut bien évidemment utiliser une boucle \textbf{for} ainsi et faire ensuite des statistiques de base

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_time }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{time\_1 =} \FunctionTok{numeric}\NormalTok{(}\DecValTok{10}\NormalTok{),}
                      \AttributeTok{time\_2 =} \FunctionTok{numeric}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\ControlFlowTok{for}\NormalTok{ (b }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) \{}
\NormalTok{ my\_time}\SpecialCharTok{$}\NormalTok{time\_1[b] }\OtherTok{\textless{}{-}} \FunctionTok{system.time}\NormalTok{(}\FunctionTok{trunc\_rnorm.1}\NormalTok{(}\DecValTok{10000}\NormalTok{))[}\DecValTok{3}\NormalTok{]}
\NormalTok{ my\_time}\SpecialCharTok{$}\NormalTok{time\_2[b] }\OtherTok{\textless{}{-}} \FunctionTok{system.time}\NormalTok{(}\FunctionTok{trunc\_rnorm.2}\NormalTok{(}\DecValTok{10000}\NormalTok{))[}\DecValTok{3}\NormalTok{]}
\NormalTok{\}}
\FunctionTok{summary}\NormalTok{(my\_time)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      time_1           time_2       
##  Min.   :0.4530   Min.   :0.04100  
##  1st Qu.:0.4550   1st Qu.:0.04125  
##  Median :0.4565   Median :0.04200  
##  Mean   :0.4976   Mean   :0.04310  
##  3rd Qu.:0.4895   3rd Qu.:0.04200  
##  Max.   :0.7820   Max.   :0.05400
\end{verbatim}

Sinon, on utilise la fonction \emph{microbenchmark()} du package \textbf{microbenchmark} (Mersmann et al., 2019). En général, on regarde la moyenne.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mbm }\OtherTok{\textless{}{-}}\NormalTok{ microbenchmark}\SpecialCharTok{::}\FunctionTok{microbenchmark}\NormalTok{(}
  \FunctionTok{trunc\_rnorm.1}\NormalTok{(}\AttributeTok{n =} \DecValTok{10000}\NormalTok{),}
  \FunctionTok{trunc\_rnorm.2}\NormalTok{(}\AttributeTok{n =} \DecValTok{10000}\NormalTok{),}
  \AttributeTok{times =}\NormalTok{ 10L)}
\NormalTok{mbm}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Unit: milliseconds
##                      expr       min        lq      mean    median        uq
##  trunc_rnorm.1(n = 10000) 418.11913 422.05836 433.55421 424.85583 441.08282
##  trunc_rnorm.2(n = 10000)  41.90505  42.17059  63.89793  62.71539  85.59846
##        max neval
##  463.94235    10
##   87.65357    10
\end{verbatim}

Par ailleurs, il est possible de représenter graphiquement ces résultats avec la fonction \emph{autoplot()} du package \textbf{ggplot2}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ggplot2}\SpecialCharTok{::}\FunctionTok{autoplot}\NormalTok{(mbm)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-191-1.pdf}

\hypertarget{pour-comprendre-la-gestion-de-la-muxe9moire}{%
\subsection{Pour comprendre la gestion de la mémoire}\label{pour-comprendre-la-gestion-de-la-muxe9moire}}

Lorsqu'on crée un vecteur sous \textbf{R}, celui-ci est stocké sur un espace mémoire que l'on peut identifier avec la fonction \emph{address()} du package \textbf{pryr} (Wickham, 2019).

Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"pryr"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Attachement du package : 'pryr'
\end{verbatim}

\begin{verbatim}
## L'objet suivant est masqué depuis 'package:data.table':
## 
##     address
\end{verbatim}

\begin{verbatim}
## Les objets suivants sont masqués depuis 'package:purrr':
## 
##     compose, partial
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\FunctionTok{address}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x55cc53fca7a8"
\end{verbatim}

Lorsqu'on attribue de nouvelles valeurs à ce vecteur, l'adresse ne change pas :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) \{}
\NormalTok{  x[i] }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{)}
  \FunctionTok{print}\NormalTok{(}\FunctionTok{address}\NormalTok{(x))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x55cc53f04a68"
## [1] "0x55cc53f04a68"
## [1] "0x55cc53f04a68"
## [1] "0x55cc53f04a68"
## [1] "0x55cc53f04a68"
## [1] "0x55cc53f04a68"
## [1] "0x55cc53f04a68"
## [1] "0x55cc53f04a68"
## [1] "0x55cc53f04a68"
## [1] "0x55cc53f04a68"
\end{verbatim}

En revanche, si on change la taille de ce vecteur, \textbf{R} va systématiquement réserver un nouvel espace mémoire, ce qui est une opération coûteuse en temps calcul, d'où des temps de calcul plus long. Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{11}\SpecialCharTok{:}\DecValTok{20}\NormalTok{) \{}
\NormalTok{  x[i] }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{) }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{)}
  \FunctionTok{print}\NormalTok{(}\FunctionTok{address}\NormalTok{(x))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x55cc53ed0b58"
## [1] "0x55cc53ed0c08"
## [1] "0x55cc53ed0cb8"
## [1] "0x55cc53ed0d68"
## [1] "0x55cc53ed0e18"
## [1] "0x55cc53ed0ec8"
## [1] "0x55cc40715180"
## [1] "0x55cc55478be0"
## [1] "0x55cc553dec60"
## [1] "0x55cc42901410"
\end{verbatim}

\textbf{Exercice 2.2}

Comparer les temps de calcul des trois expressions suivantes. Représenter graphiquement la variation des temps de calcul.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{10} \SpecialCharTok{\^{}} \DecValTok{6}
\CommentTok{\# expression 1}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(n)}
\ControlFlowTok{for}\NormalTok{ (k }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n) }
\NormalTok{  x[k] }\OtherTok{\textless{}{-}}\NormalTok{ (}\DecValTok{5} \SpecialCharTok{==} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\FunctionTok{mean}\NormalTok{(x)}
\CommentTok{\# expression 2}
\NormalTok{x }\OtherTok{\textless{}{-}} \ConstantTok{NULL}
\ControlFlowTok{for}\NormalTok{ (k }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n) }
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(x, (}\DecValTok{5} \SpecialCharTok{==} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{)))}
\FunctionTok{mean}\NormalTok{(x)}
\CommentTok{\# expression 3}
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ (k }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n)}
\NormalTok{  x }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{+}\NormalTok{ (}\DecValTok{5} \SpecialCharTok{==} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\FunctionTok{mean}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\hypertarget{fonction-vectorisuxe9e}{%
\section{Fonction vectorisée}\label{fonction-vectorisuxe9e}}

\textbf{R} est un langage interprété et de ce fait, l'exécution de boucles est coûteuse en temps calcul, contrairement à des langages compilés. Pour palier ce problème, les concepteurs du langage \textbf{R} ont créé de nombreuses fonctions vectorisées, c'est-à-dire qui peuvent s'appliquer à des vecteurs et qui font en général appel à des fonctions codées en \textbf{C} ou \textbf{Fortran} pour gagner en rapidité. Pour comprendre ce concept, on va comparer les deux méthodes suivantes dont le but est de calculer la somme des éléments d'un vecteur simulée selon une loi \(\mathcal{N}(0,1)\).

\begin{itemize}
\tightlist
\item
  Méthode 1 : on utilise des boucles depuis \textbf{R}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{1000000}\NormalTok{)}
\NormalTok{my\_sum }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  res }\OtherTok{\textless{}{-}} \DecValTok{0}
  \ControlFlowTok{for}\NormalTok{ (k }\ControlFlowTok{in} \FunctionTok{seq\_along}\NormalTok{(vec)) \{}
\NormalTok{    res }\OtherTok{\textless{}{-}}\NormalTok{ res }\SpecialCharTok{+}\NormalTok{ vec[k] }
\NormalTok{  \} }
  \FunctionTok{return}\NormalTok{(res)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Méthode 2 : on utilise la fonction \emph{sum()} sur un vecteur. Cette dernière va bien entendu effectuer une boucle, mais elle sera effectuée en langage compilé, donc plus rapidement.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{microbenchmark}\SpecialCharTok{::}\FunctionTok{microbenchmark}\NormalTok{(}
   \FunctionTok{my\_sum}\NormalTok{(vec), }
   \FunctionTok{sum}\NormalTok{(vec), }
   \AttributeTok{times =}\NormalTok{ 10L)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Unit: microseconds
##         expr       min        lq      mean    median        uq       max neval
##  my_sum(vec) 79171.798 79745.959 81540.340 80752.182 82759.752 86821.961    10
##     sum(vec)   975.122   978.605  1048.408  1005.526  1078.631  1329.366    10
\end{verbatim}

\textbf{Remarque :} il existe de nombreuses fonctions de base qui sont vectorisées et qui permettent de gagner en temps de calcul et on les utilise souvent sans s'en rendre compte. Par exemple, les fonctions \emph{log()}, \emph{cos()}, \emph{exp()}, etc. Dès lors qu'on est amener à faire des boucles, cela peut valoir le coup de se poser la question : est-ce qu'il n'existe pas de fonctions prédéfinies et vectorisées qui feraient déjà ce qu'on souhaite faire, en un temps plus rapide.

\textbf{Exercise 2.3}

Ecrire la fonction \emph{my\_sd()} qui calcule l'écart-type d'un vecteur \textbf{numeric}. La fonction ne pourra pas faire appel ni à la fonction \emph{sum()} ni \emph{mean()} et ne pourra avoir qu'une seule boucle. Comparer les temps de calcul avec \emph{sd()}.

\hypertarget{ecrire-un-code-en-c}{%
\section{Ecrire un code en C++}\label{ecrire-un-code-en-c}}

Lorsqu'on a identifié certaines parties d'un code qui sont coûteuses en temps calcul, il peut être intéressant de coder ces parties sous formes de fonctions écrites en \textbf{C++} et d'appeler ensuite ces fonctions depuis \textbf{R}.

Par exemple, on va convertir la fonction \emph{my\_sum()} écrite en \textbf{R} en code \textbf{C++}. On présente ci-dessous le code inclus dans le fichier \href{R/sumcplusplus.cpp}{sumcplusplus.cpp}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}Rcpp.h\textgreater{}}\PreprocessorTok{ }\CommentTok{// pour utiliser des fonctions de base}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp}\OperatorTok{;}

\CommentTok{// La commande suivante permet d\textquotesingle{}appeler ensuite les fonctions }
\CommentTok{// crées depuis R}

\CommentTok{// [[Rcpp::export]] }

\CommentTok{// début de la function}
\DataTypeTok{double}\NormalTok{ sum\_rcpp}\OperatorTok{(}\NormalTok{NumericVector x}\OperatorTok{)} \OperatorTok{\{}
  \DataTypeTok{double}\NormalTok{ res }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
  \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=}\NormalTok{ x}\OperatorTok{.}\NormalTok{size}\OperatorTok{();}
  
  \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    res }\OperatorTok{=}\NormalTok{ res }\OperatorTok{+}\NormalTok{ x}\OperatorTok{(}\NormalTok{i}\OperatorTok{);}
  \OperatorTok{\}}
        
  \ControlFlowTok{return}\NormalTok{ res}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

L'algorithme utilisé dans la fonction \emph{sum\_rcpp()} présente la même syntaxe que la fonction \emph{my\_sum()} écrite en \textbf{R}. Par contre, il faut utiliser les particularités du langage \textbf{C++}. Parmi ces particularités :

\begin{itemize}
\item
  il faut définir le type de l'objet qui sera retourné par la fonction,
\item
  de manière générale, il faut définir le type de tous les objets créés et/ou utilisés. En effet, on a du définir le type de tous les paramètres d'entrée. Même dans la boucle \textbf{for}, on a définir le type de \textbf{i} qui sert d'incrément,
\item
  les lignes de code se terminent par le point virgule,
\item
  l'opérateur d'affectation est le symbole \textbf{=},
\item
  la boucle \textbf{for} s'utilise différemment que du code \textbf{R},
\item
  pour connaître la taille d'un vecteur, on a utilisé la méthode \emph{.size()} qui retourne un entier,
\item
  l'indexation du vecteur commence à 0 et on utiliser les parenthèses pour accéder à un élément du vecteur.
\end{itemize}

Une fois la fonction écrite, il faut la charger sous \textbf{R}. Pour cela, on utilise la fonction \emph{sourceCpp()} du package \textbf{Rcpp} (Eddelbuettel et al., 2019) qui est le package \textbf{R} le plus utilisé par d'autres packages.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"Rcpp"}\NormalTok{)}
\FunctionTok{sourceCpp}\NormalTok{(}\StringTok{"R/sumcplusplus.cpp"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

On peut ensuite appeler directement la fonction créée :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum\_rcpp}\NormalTok{(vec)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 270.4123
\end{verbatim}

Depuis \textbf{R} Markdown, il est possible d'insérer du code écrit \textbf{C++} directement à l'intérieur d'un chunk. Pour cela, il suffit de cliquer depuis \textbf{RStudio} sur l'onglet ``Insert'', puis ``Rcpp'' et cela aura pour effet d'insérer une balise de code qui sera compilée au moment de son évaluation (autrement dit, \emph{sourceCpp()} est automatiquement exécutée).

Si on compare les temps de calcul avec \emph{my\_func()} et la fonction \emph{sum()}, on constate que \emph{sum\_rcpp()} est presque 20 fois plus rapides que \emph{my\_sum()} et 4 fois plus lentes que \emph{sum()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ microbenchmark}\SpecialCharTok{::}\FunctionTok{microbenchmark}\NormalTok{(}
   \FunctionTok{my\_sum}\NormalTok{(vec),}
   \FunctionTok{sum}\NormalTok{(vec), }
   \FunctionTok{sum\_rcpp}\NormalTok{(vec),}
   \AttributeTok{times =}\NormalTok{ 10L)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Unit: microseconds
##           expr       min        lq      mean     median        uq       max
##    my_sum(vec) 78677.186 78849.071 79794.805 79642.6285 80081.235 82813.024
##       sum(vec)   974.451   975.041  1094.846   976.0095   985.024  1974.992
##  sum_rcpp(vec)  3888.509  3889.551  4192.511  3982.4395  4051.475  6117.131
##  neval
##     10
##     10
##     10
\end{verbatim}

Pour en savoir plus sur l'utilisation de code \textbf{C++} depuis \textbf{R}, on recommande le document suivant : \url{http://adv-r.had.co.nz/Rcpp.html}

\textbf{Exercise 2.4}

Ecrire la fonction \emph{my\_sd\_cpp()} en \textbf{C++} qui calcule l'écart-type d'un vecteur \textbf{numeric}. Comparer les temps de calcul avec \emph{sd()}.

\textbf{Remarque :} en \textbf{C++}, on utilise \emph{pow(a, b)} pour calculer \(a^b\)

\hypertarget{insuxe9rer-du-code-python-dans-un-document-markdown}{%
\section{Insérer du code Python dans un document Markdown}\label{insuxe9rer-du-code-python-dans-un-document-markdown}}

Il est possible d'exécuter du code \textbf{Python} dans un document \textbf{R} Markdown et d'importer ensuite les objets créés sous \textbf{R} pour les utiliser.

Pour cela, il suffit de cliquer depuis \textbf{RStudio} sur l'onglet Insert, puis Python et cela aura pour effet d'insérer une balise de code Python

\begin{verbatim}
```{python}
```
\end{verbatim}

Par exemple, on va executer les lignes de commande \textbf{Python} suivantes dans lesquelles on a créé l'objet \textbf{flights} :

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas}
\NormalTok{flights }\OperatorTok{=}\NormalTok{ pandas.read\_csv(}\StringTok{"http://www.thibault.laurent.free.fr/cours/R\_avance/flights.csv"}\NormalTok{)}
\NormalTok{flights }\OperatorTok{=}\NormalTok{ flights[flights[}\StringTok{\textquotesingle{}Dest\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \StringTok{"TPA"}\NormalTok{]}
\NormalTok{flights }\OperatorTok{=}\NormalTok{ flights[[}\StringTok{\textquotesingle{}UniqueCarrier\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}DepDelay\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}ArrDelay\textquotesingle{}}\NormalTok{]]}
\NormalTok{flights }\OperatorTok{=}\NormalTok{ flights.dropna()}
\end{Highlighting}
\end{Shaded}

Pour rappatrier l'objet \textbf{Python} dans \textbf{R}, il suffit ensuite d'utiliser la commande \textbf{py\$} du package \textbf{reticulate} (Ushey et al., 2019) suivi de l'objet à rappatrier :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"reticulate"}\NormalTok{)}
\FunctionTok{library}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\FunctionTok{ggplot}\NormalTok{(py}\SpecialCharTok{$}\NormalTok{flights, }\FunctionTok{aes}\NormalTok{(UniqueCarrier, ArrDelay)) }\SpecialCharTok{+} 
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+} 
  \FunctionTok{geom\_jitter}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{eviter-si-possible-les-boucles-apply-lapply-replicate-colsums-etc.}{%
\section{\texorpdfstring{Eviter si possible les boucles (\emph{apply()}, \emph{lapply()}, \emph{replicate()}, \emph{colSums()}, etc.)}{Eviter si possible les boucles (apply(), lapply(), replicate(), colSums(), etc.)}}\label{eviter-si-possible-les-boucles-apply-lapply-replicate-colsums-etc.}}

On va parler ici des fonctions \emph{apply()}, \emph{lapply}, \emph{sapply()}, \emph{mapply()}, \emph{tapply()}. Les différences en temps de calcul ne sont pas significatives par rapport à l'utilisation de boucles, dans la mesure où implicitement, ces fonctions font le même travail que les boucles. L'idée de ces fonctions est de réduire le nombre de lignes de code qu'on utiliserait en faisant des boucles à la place.

On va voir qu'on utilise une de ces fonctions plutôt qu'une autre selon le type de l'objet considéré en entrée et selon le type d'objets que l'on souhaite en sortie. On verra également la fonction \emph{replicate()} qui utilise les propriétés de la fonction \emph{sapply()}, mais pour un usage un peu différent.

On présentera également les fonctions \emph{colSums()}, \emph{rowSums()}, \emph{colMeans()}, \emph{rowMeans()} qui sont plus performantes qu'utiliser la fonction \emph{apply()} car elles sont vectorisées.

\hypertarget{apply-pour-les-matrixarray}{%
\subsection{\texorpdfstring{\emph{apply()} pour les \textbf{matrix/array}}{apply() pour les matrix/array}}\label{apply-pour-les-matrixarray}}

Une \textbf{matrix} est une forme particulière d'un \textbf{array}. Une \textbf{matrix} posssède deux dimensions (espace des lignes et espace des colonnes), un \textbf{array} peut avoir autant de dimensions que souhaitées. Les \(D\)-dimensions sont données sous forme d'un vecteur de taille \(D\), chaque élément \(i\) donnant la taille de la dimension \(i\). En général, on utilise peu les \textbf{array} à plus de 3 dimensions. Une caractéristique d'un \textbf{array} est que tous ses éléments sont du même type : \textbf{numeric}, \textbf{integer}, \textbf{logical}, \textbf{character} (rarement \textbf{complex}).

Commençons par créer un \textbf{array} à trois dimensions de taille \(3 \times 2 \times 2\). Pour simplifier la compréhension d'un \textbf{array}, on va donner des noms à chaque composante de chaque dimension. La 1ère dimension correspondra aux nom des individus, la 2ème celle des variables, la 3ème celle des années :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab }\OtherTok{\textless{}{-}} \FunctionTok{array}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{110}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{28}\NormalTok{, }\DecValTok{175}\NormalTok{, }\DecValTok{180}\NormalTok{, }\DecValTok{190}\NormalTok{, }\DecValTok{68}\NormalTok{, }\DecValTok{74}\NormalTok{, }\DecValTok{85}\NormalTok{), }
             \AttributeTok{dim =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\FunctionTok{dimnames}\NormalTok{(tab)[[}\DecValTok{1}\NormalTok{]] }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Luc"}\NormalTok{, }\StringTok{"Pierre"}\NormalTok{, }\StringTok{"Pedro"}\NormalTok{)}
\FunctionTok{dimnames}\NormalTok{(tab)[[}\DecValTok{2}\NormalTok{]] }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"taille"}\NormalTok{, }\StringTok{"poids"}\NormalTok{)}
\FunctionTok{dimnames}\NormalTok{(tab)[[}\DecValTok{3}\NormalTok{]] }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"2000"}\NormalTok{, }\StringTok{"2010"}\NormalTok{)}
\NormalTok{tab}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## , , 2000
## 
##        taille poids
## Luc       100    25
## Pierre     90    24
## Pedro     110    28
## 
## , , 2010
## 
##        taille poids
## Luc       175    68
## Pierre    180    74
## Pedro     190    85
\end{verbatim}

La fonction \emph{apply()} permet de faire des calculs :

\begin{itemize}
\tightlist
\item
  sur une seule dimension. On précise alors le numéro de la dimension dans le deuxième argument et le troisième argument correspond à la fonction qu'on souhaite appliquer sur chaque élément appartenant à cette dimension. Dans ce cas, le résultat est un vecteur de longueur la taille de la dimension choisie. Par exemple, si on souhaite faire la moyenne des éléments en considérant la 2ème dimension.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{apply}\NormalTok{(tab, }\DecValTok{2}\NormalTok{, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    taille     poids 
## 140.83333  50.66667
\end{verbatim}

\textbf{Remarque :} en réalité, selon la fonction qu'on applique à \emph{apply()}, le résultat n'est pas forcément un vecteur. Essayer par exemple de remplacer la fonction \emph{mean()} par \emph{range()} dans l'exemple ci-dessus.

\textbf{Equivalent avec les boucles :} si on avait utilisé les boucles plutôt que la fonction \emph{apply()}, on aurait utilisé le code suivant :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\FunctionTok{dim}\NormalTok{(tab)[}\DecValTok{2}\NormalTok{])}
\ControlFlowTok{for}\NormalTok{ (k }\ControlFlowTok{in} \FunctionTok{seq\_along}\NormalTok{(res))}
\NormalTok{  res[k] }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(tab[, k, ])}
\NormalTok{res}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 140.83333  50.66667
\end{verbatim}

\begin{itemize}
\tightlist
\item
  sur deux dimensions :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{apply}\NormalTok{(tab, }\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{), mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             2000      2010
## taille 100.00000 181.66667
## poids   25.66667  75.66667
\end{verbatim}

\textbf{Equivalent avec les boucles :} si on avait utilisé les boucles pour faire ce calcul, on aurait fait :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OtherTok{\textless{}{-}} \FunctionTok{array}\NormalTok{(}\DecValTok{0}\NormalTok{, }\AttributeTok{dim =} \FunctionTok{dim}\NormalTok{(tab)[}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)])}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{dim}\NormalTok{(tab)[}\DecValTok{2}\NormalTok{])}
  \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{dim}\NormalTok{(tab)[}\DecValTok{3}\NormalTok{])}
\NormalTok{    res[i, j] }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(tab[, i, j])}
\NormalTok{res}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           [,1]      [,2]
## [1,] 100.00000 181.66667
## [2,]  25.66667  75.66667
\end{verbatim}

\hypertarget{les-fonctions-colsums-rowsums-colmeans-rowmeans}{%
\subsection{\texorpdfstring{Les fonctions \emph{colSums()}, \emph{rowSums()}, \emph{colMeans()}, \emph{rowMeans()}}{Les fonctions colSums(), rowSums(), colMeans(), rowMeans()}}\label{les-fonctions-colsums-rowsums-colmeans-rowmeans}}

Ces fonctions sont équivalentes à la fonction \emph{apply()} en utilisant \textbf{FUN=sum} ou \textbf{FUN=mean} et en appliquant les bonnes dimensions (1 pour lignes, 2 pour colonnes), mais sont plus rapides car elles ont été codées en langage compilé.

Pour comparer les temps de calcul :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{runif}\NormalTok{(}\FloatTok{10e6}\NormalTok{), }\AttributeTok{nc =} \DecValTok{5}\NormalTok{)}
\NormalTok{ microbenchmark}\SpecialCharTok{::}\FunctionTok{microbenchmark}\NormalTok{(}
   \FunctionTok{apply}\NormalTok{(x, }\DecValTok{2}\NormalTok{, mean),}
   \FunctionTok{colMeans}\NormalTok{(x),}
   \AttributeTok{times =}\NormalTok{ 10L)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Unit: milliseconds
##               expr       min        lq      mean    median        uq       max
##  apply(x, 2, mean) 183.02811 196.58432 232.10561 196.79185 197.63764 546.86843
##        colMeans(x)  11.29878  11.37811  11.47504  11.45622  11.50457  11.78339
##  neval
##     10
##     10
\end{verbatim}

\hypertarget{la-fonction-lapply}{%
\subsection{\texorpdfstring{La fonction \emph{lapply()}}{La fonction lapply()}}\label{la-fonction-lapply}}

Même si la fonction \emph{lapply()} s'applique aussi bien sur les vecteurs que les \textbf{list}, on présentera ici son utilisation pour les \textbf{list/data.frame}. L'intérêt de l'appliquer sur des vecteurs sera présenté avec la fonction \emph{replicate()}.

On rappelle ici qu'une \textbf{list} est caractérisée par un certain nombre d'éléments pouvant être de types différents. On accède aux éléments d'une liste par le symbole \textbf{\$} suivi du nom de l'élément de la liste et s'il n'y a pas de nom, on y accède avec les doubles crochets avec l'indice de l'élément auquel on souhaite accèder. Un \textbf{data.frame} est une forme particulière d'une \textbf{list} dans la mesure où les éléments peuvent être vus comme étant les variables (on y accède avec le symbole \textbf{\$}).

La fonction \emph{lapply()} consiste à appliquer la même opération sur chaque élément de la \textbf{list}. Cette opération pouvant être donnée par une fonction de base de \textbf{R} ou bien pouvant être une fonction programmée.

On considère le jeu de données \textbf{mtcars} accessible par défaut sous \textbf{R} et contenant un certaine nombre de variables sur des moteurs de voitures de différentes marques. Pour connaître les caractéristiques moyennes, on applique la fonction \emph{mean()} à chaque élément de \textbf{mtcars}, autrement dit à chaque variable. Le résultat est retourné sous forme de \textbf{list} de même longeur que la \textbf{list} de départ.

Ici, on a utilisé la fonction \emph{unlist()} sur le résultat retourné afin de présenter le résultat sous forme d'un vecteur, plus lisible à lire :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{unlist}\NormalTok{(}\FunctionTok{lapply}\NormalTok{(mtcars, mean))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        mpg        cyl       disp         hp       drat         wt       qsec 
##  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 
##         vs         am       gear       carb 
##   0.437500   0.406250   3.687500   2.812500
\end{verbatim}

Cette fonction nous permet ainsi d'éviter de faire la boucle suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\FunctionTok{length}\NormalTok{(mtcars))}
\ControlFlowTok{for}\NormalTok{ (k }\ControlFlowTok{in} \FunctionTok{seq\_along}\NormalTok{(res))}
\NormalTok{  res[k] }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(mtcars[[k]])}
\NormalTok{res}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250
##  [7]  17.848750   0.437500   0.406250   3.687500   2.812500
\end{verbatim}

\hypertarget{la-fonction-sapply}{%
\subsection{\texorpdfstring{La fonction \emph{sapply()}}{La fonction sapply()}}\label{la-fonction-sapply}}

On a vu que la fonction \emph{lapply()} retournait une \textbf{list}. Or, si on sait par avance que le résultat retourné pour chaque élément de la liste sera identique pour chaque élément, la fonction \emph{sapply()} va concaténer les résultats de chaque élément sous forme d'un vecteur ou d'un tableau. Si on reprend l'exemple précédent :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sapply}\NormalTok{(mtcars, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        mpg        cyl       disp         hp       drat         wt       qsec 
##  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 
##         vs         am       gear       carb 
##   0.437500   0.406250   3.687500   2.812500
\end{verbatim}

On présente ici un autre exemple où on va créer notre propre fonction qui consiste à retourner, le minimum, le maximum, la moyenne, l'écart-type et la moyenne de chaque élément. On code la fonction suivante où l'argument \textbf{x} sera interpété comme représentant un élément de la \textbf{list}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) }
  \FunctionTok{c}\NormalTok{(}\AttributeTok{min =} \FunctionTok{min}\NormalTok{(x), }\AttributeTok{max =} \FunctionTok{max}\NormalTok{(x), }\AttributeTok{mean =} \FunctionTok{mean}\NormalTok{(x), }\AttributeTok{med =} \FunctionTok{median}\NormalTok{(x), }\AttributeTok{sd =} \FunctionTok{sd}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

On applique ensuite la fonction \emph{f()} à chaque élément de la \textbf{list} avec la fonction \emph{sapply()}. On transpose le résultat car c'est en général ainsi que sont présentées les statistiques descriptives des variables :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t}\NormalTok{(}\FunctionTok{sapply}\NormalTok{(mtcars, f))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         min     max       mean     med          sd
## mpg  10.400  33.900  20.090625  19.200   6.0269481
## cyl   4.000   8.000   6.187500   6.000   1.7859216
## disp 71.100 472.000 230.721875 196.300 123.9386938
## hp   52.000 335.000 146.687500 123.000  68.5628685
## drat  2.760   4.930   3.596563   3.695   0.5346787
## wt    1.513   5.424   3.217250   3.325   0.9784574
## qsec 14.500  22.900  17.848750  17.710   1.7869432
## vs    0.000   1.000   0.437500   0.000   0.5040161
## am    0.000   1.000   0.406250   0.000   0.4989909
## gear  3.000   5.000   3.687500   4.000   0.7378041
## carb  1.000   8.000   2.812500   2.000   1.6152000
\end{verbatim}

Par ailleurs, pour insérer une table dans un document Markdown, on peut utiliser la fonction \emph{kbl()} du package \textbf{kableExtra} dont on verra d'autres exemples dans le chapitre sur la visualisation de données.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{kableExtra}\SpecialCharTok{::}\FunctionTok{kbl}\NormalTok{(}\FunctionTok{t}\NormalTok{(}\FunctionTok{round}\NormalTok{(}\FunctionTok{sapply}\NormalTok{(mtcars, f), }\DecValTok{3}\NormalTok{))) }
\end{Highlighting}
\end{Shaded}

\begin{tabular}[t]{l|r|r|r|r|r}
\hline
  & min & max & mean & med & sd\\
\hline
mpg & 10.400 & 33.900 & 20.091 & 19.200 & 6.027\\
\hline
cyl & 4.000 & 8.000 & 6.188 & 6.000 & 1.786\\
\hline
disp & 71.100 & 472.000 & 230.722 & 196.300 & 123.939\\
\hline
hp & 52.000 & 335.000 & 146.688 & 123.000 & 68.563\\
\hline
drat & 2.760 & 4.930 & 3.597 & 3.695 & 0.535\\
\hline
wt & 1.513 & 5.424 & 3.217 & 3.325 & 0.978\\
\hline
qsec & 14.500 & 22.900 & 17.849 & 17.710 & 1.787\\
\hline
vs & 0.000 & 1.000 & 0.438 & 0.000 & 0.504\\
\hline
am & 0.000 & 1.000 & 0.406 & 0.000 & 0.499\\
\hline
gear & 3.000 & 5.000 & 3.688 & 4.000 & 0.738\\
\hline
carb & 1.000 & 8.000 & 2.812 & 2.000 & 1.615\\
\hline
\end{tabular}

\textbf{Remarque :} si on on souhaite appliquer la fonction \emph{f()} pour les éléments qui sont de type \textbf{numeric} et la fonction \emph{table()} pour les éléments de type \textbf{factor}, alors la fonction \emph{sapply()} retournera le même résultat que la fonction \emph{lapply()}, à savoir une \textbf{list}, car les résultats retournés pour chaque élément ne seront pas les mêmes :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sapply}\NormalTok{(iris, }\ControlFlowTok{function}\NormalTok{(x)\{}
  \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{is.numeric}\NormalTok{(x)) }
    \FunctionTok{f}\NormalTok{(x)}
  \ControlFlowTok{else}
    \FunctionTok{table}\NormalTok{(x)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $Sepal.Length
##       min       max      mean       med        sd 
## 4.3000000 7.9000000 5.8433333 5.8000000 0.8280661 
## 
## $Sepal.Width
##       min       max      mean       med        sd 
## 2.0000000 4.4000000 3.0573333 3.0000000 0.4358663 
## 
## $Petal.Length
##      min      max     mean      med       sd 
## 1.000000 6.900000 3.758000 4.350000 1.765298 
## 
## $Petal.Width
##       min       max      mean       med        sd 
## 0.1000000 2.5000000 1.1993333 1.3000000 0.7622377 
## 
## $Species
## x
##     setosa versicolor  virginica 
##         50         50         50
\end{verbatim}

\hypertarget{la-fonction-replicate}{%
\subsection{\texorpdfstring{La fonction \emph{replicate()}}{La fonction replicate()}}\label{la-fonction-replicate}}

On va partir de l'exemple suivant : on souhaitre simuler 5 échantillons de taille 10 distribués selon une loi uniforme \(U_{[0,1]}\).

\begin{itemize}
\tightlist
\item
  La première solution serait de faire une boucle :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OtherTok{\textless{}{-}} \FunctionTok{vector}\NormalTok{(}\StringTok{"list"}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ (k }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{)}
\NormalTok{  res[[k]] }\OtherTok{\textless{}{-}} \FunctionTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  La deuxième solution consiste à appliquer la fonction \emph{lapply()} sur un vecteur quelconque de taille 5 (ici, le plus simple est de faire \emph{1:5}, mais on aurait pu prendre n'importe quel vecteur de taille 5) et de lui appliquer une fonction qui retourne un vecteur simulé selon une \(U_{[0,1]}\). Un vecteur est donc considéré ici comme une liste où chaque élément du vecteur serait un élement d'une liste.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OtherTok{\textless{}{-}} \FunctionTok{lapply}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\textbf{Remarque :} dans le deuxième argument, la fonction qu'on va appliquer sur chaque élément d'une vecteur prend comme argument d'entrée \textbf{x} (un élément du vecteur), mais on ne l'utilise pas à l'intérieur de la fonction, car on n'en a pas besoin pour faire ce qu'on souhaite faire.

\begin{itemize}
\tightlist
\item
  La troisième solution consiste à utiliser la fonction \emph{replicate()}, qui comme la fonction \emph{sapply()} va retourner le résultat sous une forme plus simplifiée qu'une \textbf{list} :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(}\DecValTok{5}\NormalTok{, }\FunctionTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\textbf{Remarque :} la fonction \emph{replicate()} fait précisément appel à la fonction \emph{sapply()}. Pour cela, elle créé un vecteur de 0L de taille le premier argument de \emph{replicate()}.

\hypertarget{la-fonction-mapply}{%
\subsection{\texorpdfstring{La fonction \emph{mapply()}}{La fonction mapply()}}\label{la-fonction-mapply}}

Pour illustrer cette fonction, on considère 5 échantillons de taille 10 issus d'une loi \(U_{[0,1]}\). Pour calculer la moyenne par échantilon, on peut utiliser la fonction \emph{lapply()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xs }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(}\DecValTok{5}\NormalTok{, }\FunctionTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{), }\AttributeTok{simplify =} \ConstantTok{FALSE}\NormalTok{)}
\FunctionTok{lapply}\NormalTok{(xs, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 0.4200745
## 
## [[2]]
## [1] 0.4105398
## 
## [[3]]
## [1] 0.363235
## 
## [[4]]
## [1] 0.5592183
## 
## [[5]]
## [1] 0.4279419
\end{verbatim}

A présent, supposons qu'on souhaite pondérer les moyennes par un vecteur de poids qui est différent selon chaque échantillon. On créé ici les poids associés à chaque échantillon sous forme d'une liste :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ws }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(}\DecValTok{5}\NormalTok{, }\FunctionTok{rpois}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{5}\NormalTok{) }\SpecialCharTok{+} \DecValTok{1}\NormalTok{, }\AttributeTok{simplify =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Une façon de faire avec des boucles serait la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\FunctionTok{length}\NormalTok{(xs))}
\ControlFlowTok{for}\NormalTok{ (k }\ControlFlowTok{in} \FunctionTok{seq\_along}\NormalTok{(res))}
\NormalTok{  res[k] }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(xs[[k]] }\SpecialCharTok{*}\NormalTok{ ws[[k]]) }\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(ws[[k]])}
\NormalTok{res}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.3918269 0.4219046 0.3278862 0.5367989 0.4524113
\end{verbatim}

Le problème de la fonction \emph{lapply()} est qu'on ne peut pas appliquer une fonction sur deux \textbf{list} simultanément. C'est ce que fait la fonction \emph{mapply()} qui prend comme 1er argument d'entrée une fonction à appliquer sur les éléments d'autant de \textbf{list} que l'on souhaite. La fonction qu'on applique contient donc deux arguments d'entrée \textbf{x} et \textbf{y} qui correspondent aux éléments de chacune des deux listes :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mapply}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x, y) }\FunctionTok{sum}\NormalTok{(x }\SpecialCharTok{*}\NormalTok{ y) }\SpecialCharTok{/} \FunctionTok{mean}\NormalTok{(y), xs, ws)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.918269 4.219046 3.278862 5.367989 4.524113
\end{verbatim}

\hypertarget{la-fonction-tapply}{%
\subsection{\texorpdfstring{La fonction \emph{tapply()}}{La fonction tapply()}}\label{la-fonction-tapply}}

On considère les deux vecteurs suivants :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(taille }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{165}\NormalTok{, }\DecValTok{10}\NormalTok{), }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{175}\NormalTok{, }\DecValTok{10}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 141.7006 181.0656 164.2458 177.7004 174.7507 165.0026 180.6391 179.8185
##  [9] 170.9057 177.5540
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(sexe }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"M"}\NormalTok{, }\StringTok{"F"}\NormalTok{), }\AttributeTok{each =} \DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "M" "M" "M" "M" "M" "F" "F" "F" "F" "F"
\end{verbatim}

On souhaite calculer la moyenne dans chaque sous-groupe \emph{``M''} et \emph{``F''}. Une façon de faire est de créer une \textbf{list} contenant deux éléments, le premier correspondant au vecteur de \textbf{taille} du sous-groupe \emph{``M''} et le second correspondant au vecteur de \textbf{taille} du sous-groupe \emph{``F''}. C'est ce que fait la fonction \emph{split()} ci-dessous :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(res.split }\OtherTok{\textless{}{-}} \FunctionTok{split}\NormalTok{(taille, sexe))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $F
## [1] 165.0026 180.6391 179.8185 170.9057 177.5540
## 
## $M
## [1] 141.7006 181.0656 164.2458 177.7004 174.7507
\end{verbatim}

Ensuite, il suffit d'appliquer la fonction \emph{sapply()} à cette \textbf{list} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sapply}\NormalTok{(res.split, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        F        M 
## 174.7840 167.8926
\end{verbatim}

La fonction \emph{tapply()} permet de faire ce calcul en une seule ligne :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{tapply}\NormalTok{(taille, sexe, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        F        M 
## 174.7840 167.8926
\end{verbatim}

\textbf{Remarque :} la fonction \emph{tapply()} ne s'appliquant que sur des vecteurs, la fonction \emph{by()} permet de généraliser la fonction \emph{tapply()} aux \textbf{data.frame}.

\textbf{Exercise 2.5}

\begin{itemize}
\item
  Créer deux fonctions \emph{mean\_rnorm.1()} et \emph{mean\_rnorm.2()} qui prennent en entrée les paramètres \textbf{n} et \textbf{p}. Ces fonctions permettent de simuler \textbf{n} échantillons de taille \textbf{p} de lois normales centrées réduites et retournent pour chaque échantillon la moyenne. \emph{mean\_rnorm.1()} utilisera des boucles, \emph{mean\_rnorm.2()} la fonction \emph{replicate()}.
\item
  Comparer les temps de calcul de ces 2 fonctions.
\end{itemize}

\hypertarget{amuxe9liorer-ses-fonctions}{%
\section{Améliorer ses fonctions}\label{amuxe9liorer-ses-fonctions}}

\hypertarget{cruxe9er-des-sous-fonctions}{%
\subsection{Créer des sous-fonctions}\label{cruxe9er-des-sous-fonctions}}

Il ne faut pas hésiter à créer des petites fonctions qui peuvent être

\begin{itemize}
\item
  locales si elles ne sont utilisées qu'à l'intérieur d'une seule fonction principale
\item
  globales si elles ont à vocation d'être uilisées dans plusieurs fonctions.
\end{itemize}

Supposons par exemple qu'on souhaite calculer une densité non paramétrique de la densité en utilisant un des noyaux suivants :

\begin{itemize}
\item
  noyau \emph{biweight} \(K(x) = \frac{15}{16}(1-(\frac{x}{h})^2)^21_{(\frac{x}{h})^2\leq 1}\)
\item
  noyau \emph{triweight} \(K(x) = \frac{35}{32}(1-(\frac{x}{h})^2)^31_{(\frac{x}{h})^2\leq 1}\)
\item
  noyau gaussien \(K(x) = \frac{1}{\sqrt{2\pi}}\exp(-0.5(\frac{x}{h})^2))\)
\end{itemize}

où \textbf{h} est le paramètre de lissage. Dans un premier temps, pn peut alors programmer une fonction par noyau :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{biweight }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, h) \{}
  \FunctionTok{return}\NormalTok{(}\DecValTok{15} \SpecialCharTok{/} \DecValTok{16} \SpecialCharTok{*}\NormalTok{ (}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ (x }\SpecialCharTok{/}\NormalTok{ h) }\SpecialCharTok{\^{}} \DecValTok{2}\NormalTok{) }\SpecialCharTok{\^{}} \DecValTok{2} \SpecialCharTok{*} \FunctionTok{ifelse}\NormalTok{((x }\SpecialCharTok{/}\NormalTok{ h) }\SpecialCharTok{\^{}} \DecValTok{2} \SpecialCharTok{\textless{}=} \DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{))}
\NormalTok{\}}
\NormalTok{triweight }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, h) \{}
  \FunctionTok{return}\NormalTok{(}\DecValTok{35} \SpecialCharTok{/} \DecValTok{32}\SpecialCharTok{*}\NormalTok{(}\DecValTok{1} \SpecialCharTok{{-}}\NormalTok{ (x }\SpecialCharTok{/}\NormalTok{ h) }\SpecialCharTok{\^{}} \DecValTok{2}\NormalTok{) }\SpecialCharTok{\^{}} \DecValTok{3} \SpecialCharTok{*} \FunctionTok{ifelse}\NormalTok{((x }\SpecialCharTok{/}\NormalTok{ h) }\SpecialCharTok{\^{}} \DecValTok{2} \SpecialCharTok{\textless{}=} \DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{))}
\NormalTok{\}}
\NormalTok{gaussian }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, h) \{}
  \FunctionTok{return}\NormalTok{(}\DecValTok{1} \SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{2} \SpecialCharTok{*}\NormalTok{ pi) }\SpecialCharTok{*} \FunctionTok{exp}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{0.5} \SpecialCharTok{*}\NormalTok{ (x }\SpecialCharTok{/}\NormalTok{ h) }\SpecialCharTok{\^{}} \DecValTok{2}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{structure-de-contruxf4le}{%
\subsection{Structure de contrôle}\label{structure-de-contruxf4le}}

Les structures de contrôle classiques (\textbf{for}, \textbf{while}, \textbf{repeat}, \textbf{if/else}) sont bien entendu disponibles dans \textbf{R} (voir les document \href{http://math.univ-toulouse.fr/~sdejean}{``Pour se donner un peu d'\textbf{R}''} et \href{http://www.thibault.laurent.free.fr/pedago.html}{``Introduction à \textbf{R}''}. Nous nous intéressons ici à la notion d'aiguillage (fonction \emph{switch()}) moins couramment utilisée bien que très pratique.

Celle-ci permet d'éviter d'emboîter des \textbf{if/else} lorsqu'on a plusieurs options possibles. Supposons par exemple qu'on souhaite calculer une densité non paramétrique de la densité en utilisant un des noyaux suivants :

\begin{itemize}
\item
  noyau \emph{biweight} \(K(x) = \frac{15}{16}(1-(\frac{x}{h})^2)^21_{(\frac{x}{h})^2\leq 1}\)
\item
  noyau \emph{triweight} \(K(x) = \frac{35}{32}(1-(\frac{x}{h})^2)^31_{(\frac{x}{h})^2\leq 1}\)
\item
  noyau gaussien \(K(x) = \frac{1}{\sqrt{2\pi}}\exp(-0.5(\frac{x}{h})^2))\)
\end{itemize}

où \textbf{h} est le paramètre de lissage. On peut alors programmer sous \textbf{R} la fonction \emph{f\_noyau()} suivante, prenant en entrée les arguments \textbf{x}, \textbf{h} et \textbf{type} où \textbf{type} est un caractère prenant les valeurs \textbf{``bi''}, \textbf{``tri''} et \textbf{``gauss''}.

\hypertarget{solution-avec-ifelse}{%
\subsubsection{\texorpdfstring{Solution avec \textbf{if/else}}{Solution avec if/else}}\label{solution-avec-ifelse}}

La façon traditionnelle pour gérer différents cas de figure est d'utiliser les conditions \textbf{if/else} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f\_noyau }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, h, }\AttributeTok{type =} \StringTok{"bi"}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{ (type }\SpecialCharTok{==} \StringTok{"bi"}\NormalTok{) \{}
    \FunctionTok{biweight}\NormalTok{(x, h)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \ControlFlowTok{if}\NormalTok{ (type }\SpecialCharTok{==} \StringTok{"tri"}\NormalTok{) \{}
       \FunctionTok{triweight}\NormalTok{(x, h)}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \FunctionTok{gaussian}\NormalTok{(x, h)}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Un inconvénient est qu'en emboîtant des conditions \textbf{if/else}, on peut alors vite se perdre dans la lecture du code.

\hypertarget{solution-avec-switch}{%
\subsubsection{\texorpdfstring{Solution avec \textbf{switch()}}{Solution avec switch()}}\label{solution-avec-switch}}

La fonction \emph{switch()} s'applique sur l'argument \textbf{type} et on donne ensuite pour chaque valeur possible de \textbf{type} le type de calcul à effectuer. On ajoute ici un cas qui correspondrait à toutes autres valeurs de \textbf{type}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f\_noyau}\FloatTok{.2} \OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, h, }\AttributeTok{type =} \StringTok{"bi"}\NormalTok{) \{}
  \ControlFlowTok{switch}\NormalTok{(type, }\AttributeTok{bi =} \FunctionTok{biweight}\NormalTok{(x, h),}
               \AttributeTok{tri =} \FunctionTok{triweight}\NormalTok{(x, h),}
               \AttributeTok{gauss =} \FunctionTok{gaussian}\NormalTok{(x, h),}
               \StringTok{"Préciser une autre valeur de type"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Application :}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{0.01}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(x, }\FunctionTok{f\_noyau.2}\NormalTok{(x, }\FloatTok{0.3}\NormalTok{, }\AttributeTok{type =} \StringTok{"bi"}\NormalTok{), }\AttributeTok{type =} \StringTok{"l"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{""}\NormalTok{, }\AttributeTok{ylim =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{1.2}\NormalTok{))}
\FunctionTok{lines}\NormalTok{(x, }\FunctionTok{f\_noyau.2}\NormalTok{(x, }\FloatTok{0.3}\NormalTok{, }\AttributeTok{type =} \StringTok{"tri"}\NormalTok{), }\AttributeTok{lty =} \DecValTok{2}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(x, }\FunctionTok{f\_noyau.2}\NormalTok{(x, }\FloatTok{0.3}\NormalTok{, }\AttributeTok{type =} \StringTok{"gauss"}\NormalTok{), }\AttributeTok{lty =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-231-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f\_noyau.2}\NormalTok{(x, }\FloatTok{0.3}\NormalTok{, }\AttributeTok{type =} \StringTok{"unif"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Préciser une autre valeur de type"
\end{verbatim}

\hypertarget{fonction-stopifnot}{%
\subsection{\texorpdfstring{Fonction \emph{stopifnot()}}{Fonction stopifnot()}}\label{fonction-stopifnot}}

On connaît la fonction \emph{stop()} qui s'insère en général à l'intérieur des conditions \textbf{if/else}.

La fonction \emph{stopifnot()} permet de tester simultanément plusieurs conditions et évite donc d'avoir recours aux \textbf{if/else}. Elle est particulièrement utile à l'intérieur d'une fonction pour, par exemple, vérifier la conformité des valeurs passées en paramètres. Un exemple d'uitlisation :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{stopifnot}\NormalTok{(}\DecValTok{1} \SpecialCharTok{\textless{}} \DecValTok{2}\NormalTok{, }\FunctionTok{length}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{) }\SpecialCharTok{==} \DecValTok{2}\NormalTok{, pi }\SpecialCharTok{\textless{}} \DecValTok{2}\NormalTok{, }\FunctionTok{cos}\NormalTok{(pi) }\SpecialCharTok{\textgreater{}} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error: pi < 2 n'est pas TRUE
\end{verbatim}

Si plusieurs conditions ne sont pas respectées, c'est la première non respectée qui est renvoyée comme source de l'erreur.

\textbf{Exercise 2.6}

Modifier la fonction \emph{f\_noyau.2()} définie précédemment pour vérifier que :

\begin{itemize}
\item
  le paramètre \textbf{x} est \textbf{numeric}
\item
  \textbf{h} est de taille 1 et de type \textbf{numeric}
\item
  \textbf{type} est une chaîne de caractères (on supprimera la possibilité de passer un entier pour choisir le type).
\end{itemize}

\hypertarget{les-arguments-dans-une-fonction}{%
\subsection{Les arguments dans une fonction}\label{les-arguments-dans-une-fonction}}

\hypertarget{supprimer-les-paramuxe8tres-inutiles}{%
\subsubsection{Supprimer les paramètres inutiles}\label{supprimer-les-paramuxe8tres-inutiles}}

Dans l'exemple ci-dessous, les paramètres \textbf{d} et \textbf{e} ne sont pas utilisés dans la fonction et pourtant ils ont un coût de stockage et un coût en temps de calcul car ils sont évalués par défaut dans la fonction.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f\_1 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{a =} \DecValTok{5}\NormalTok{, }\AttributeTok{b =} \DecValTok{4}\NormalTok{, }\AttributeTok{d =} \DecValTok{3}\NormalTok{, }\AttributeTok{e =} \DecValTok{1}\NormalTok{)}
\NormalTok{  (a }\SpecialCharTok{+}\NormalTok{ b)}\SpecialCharTok{\^{}}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

On compare les temps de calcul avec la même fonction mais qui n'utilise pas les paramètres inutilisés :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f\_2 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{a =} \DecValTok{5}\NormalTok{, }\AttributeTok{b =} \DecValTok{4}\NormalTok{)}
\NormalTok{  (a }\SpecialCharTok{+}\NormalTok{ b)}\SpecialCharTok{\^{}}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{microbenchmark}\SpecialCharTok{::}\FunctionTok{microbenchmark}\NormalTok{(}
  \FunctionTok{f\_1}\NormalTok{(),}
  \FunctionTok{f\_2}\NormalTok{()}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Unit: nanoseconds
##   expr min    lq     mean median    uq     max neval
##  f_1() 480 525.5 27955.93    587 772.0 2706845   100
##  f_2() 362 415.5 32974.04    479 635.5 3227319   100
\end{verbatim}

Contrairement à d'autres langages, \textbf{R} ne signale pas les paramètres qui ne sont pas utiles, qu'il s'agisse de paramètres utilisés en argument d'entrée ou de paramètres créés à l'intérieur de la fonction. C'est donc à celui qui programme d'être vigilent à ne pas créer des paramètres inutiles.

\hypertarget{utiliser-des-fonctions-comme-argument-dentruxe9e}{%
\subsubsection{Utiliser des fonctions comme argument d'entrée}\label{utiliser-des-fonctions-comme-argument-dentruxe9e}}

On a vu dans la section précédente que la fonction \emph{lapply()} avait dans ses argument d'entrée une fonction. On peut si on le souhaite créer nos propres fonctions qui ont comme argument d'entrée une fonction. Dans l'exemple suivant, on applique une fonction choisie par l'utilisateur sur un échantillon simulée selon une loi uniforme :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{randomise }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(f) }\FunctionTok{f}\NormalTok{(}\FunctionTok{runif}\NormalTok{(}\FloatTok{1e3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Pour l'utiliser, on remplace l'argument \textbf{f} par le nom de la fonction qui nous intéresse :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{randomise}\NormalTok{(mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.4924948
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{randomise}\NormalTok{(mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.5048686
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{randomise}\NormalTok{(sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 496.2882
\end{verbatim}

\hypertarget{utiliser-des-fonctions-comme-argument-de-sortie}{%
\subsubsection{Utiliser des fonctions comme argument de sortie}\label{utiliser-des-fonctions-comme-argument-de-sortie}}

Il est également possible de faire retourner une fonction par une fonction. C'est ce que fait la fonction \emph{f\_power()} ci-dessous :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f\_power }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(exponent)}
  \ControlFlowTok{function}\NormalTok{(x) x}\SpecialCharTok{\^{}}\NormalTok{exponent }
\end{Highlighting}
\end{Shaded}

Pour utiliser cette fonction :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f\_power}\NormalTok{(}\DecValTok{2}\NormalTok{)(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  4  9 16 25
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f\_power}\NormalTok{(}\DecValTok{3}\NormalTok{)(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]   1   8  27  64 125
\end{verbatim}

On peut également créer les fonctions \emph{f\_square()} et \emph{f\_cube()} à partir de la fonction \emph{f\_power()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f\_square }\OtherTok{\textless{}{-}} \FunctionTok{f\_power}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{f\_cube }\OtherTok{\textless{}{-}} \FunctionTok{f\_power}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\FunctionTok{class}\NormalTok{(f\_square)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "function"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(f\_cube)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "function"
\end{verbatim}

Et pour obtenir le calcul souhaité :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f\_square}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  4  9 16 25
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f\_cube}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]   1   8  27  64 125
\end{verbatim}

\hypertarget{utiliser-les-comme-argument-dentruxe9e}{%
\subsubsection{Utiliser les \ldots{} comme argument d'entrée}\label{utiliser-les-comme-argument-dentruxe9e}}

Lorsqu'un utilisateur définit une fonction, il peut permettre à sa fonction d'utiliser toutes les options d'une autre fonction sans les lister une à une. Prenons l'exemple de la fonction \emph{plot\_reg()} définie ci-dessous.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plot\_reg }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y, }\AttributeTok{np =} \ConstantTok{TRUE}\NormalTok{, ...) \{}
  \FunctionTok{plot}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ x, ...)}
  \FunctionTok{abline}\NormalTok{(}\FunctionTok{lm}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ x), }\AttributeTok{col =} \StringTok{"blue"}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (np) \{}
\NormalTok{    np.reg }\OtherTok{\textless{}{-}} \FunctionTok{loess}\NormalTok{(y }\SpecialCharTok{\textasciitilde{}}\NormalTok{ x)}
\NormalTok{    x.seq }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\FunctionTok{min}\NormalTok{(x), }\FunctionTok{max}\NormalTok{(x), }\AttributeTok{length.out =} \DecValTok{25}\NormalTok{)}
    \FunctionTok{lines}\NormalTok{(x.seq, }\FunctionTok{predict}\NormalTok{(np.reg, x.seq), }\AttributeTok{col =} \StringTok{"red"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

L'utilisation de la syntaxe \textbf{\ldots{}} permet de préciser que la fonction \emph{plot\_reg()} pourra, si besoin, faire appel à n'importe quelle option de la fonction \emph{plot()}.

Pour illustrer la chose, exécuter les instructions suivantes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{100}\NormalTok{) }
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{*}\FunctionTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot\_reg}\NormalTok{(x, y, }\AttributeTok{np =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-245-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot\_reg}\NormalTok{(x, y, }\AttributeTok{pch =} \DecValTok{16}\NormalTok{, }\AttributeTok{col =} \StringTok{"pink"}\NormalTok{,}
 \AttributeTok{xlab =} \StringTok{"variable explicative"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{"variable à expliquer"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-245-2.pdf}

\textbf{Exercice 2.7}

\textbf{Q1} Que fait la fonction \emph{plot\_reg()} ?

\textbf{Q2} Ecrire une fonction \emph{hist\_extrm()} qui prend en argument d'entrée un entier \textbf{n}, un entier \textbf{B} et \textbf{\ldots{}} qui correspondra aux options utilisées dans la fonction \emph{hist()}. Cette fonction devra mettre en oeuvre l'algorithme ci-dessous :

Répèter \textbf{B} fois l'opération suivante :

\begin{itemize}
\tightlist
\item
  simulation d'un vecteur \textbf{x} de taille \emph{n} selon une \(N(0,1)\),
\end{itemize}

\textbf{Résultat}
On comptabilise sur les \textbf{B} boucles le pourcentages de boucles où il existe au moins un élément de \textbf{x} supérieur en valeur absolue à 1.96. On stockera les valeurs concernées et on représentera l'histogramme des valeurs extrêmes.

\hypertarget{a-quoi-servent-les-fonctions-substitutequote-et-eval}{%
\section{\texorpdfstring{A quoi servent les fonctions \emph{substitute()/quote()} et \emph{eval()} ?}{A quoi servent les fonctions substitute()/quote() et eval() ?}}\label{a-quoi-servent-les-fonctions-substitutequote-et-eval}}

On considère l'exemple ci-dessous :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{5}
\FunctionTok{identical}\NormalTok{(a, }\StringTok{"a"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\textbf{a} et \textbf{``a''} sont bien entendu deux entités différentes. \textbf{a} est un objet qui pointe sur la valeur 5 alors que \textbf{``a''} est une chaîne de caractère.

Losqu'on charge une librairie, on a la possibilité d'utiliser les deux commandes suivantes :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}
\FunctionTok{require}\NormalTok{(tidyverse)}
\end{Highlighting}
\end{Shaded}

Dans le deuxième cas, \textbf{tidyverse} (sans guillemet) n'est a priori pas un objet (à moins qu'au cours d'une session on ait créé un objet avec ce nom). C'est donc qu'il a été interprété comme étant quelque chose de différent d'un objet.

\hypertarget{les-fonctions-quote-et-substitute}{%
\subsection{\texorpdfstring{Les fonctions \emph{quote()} et \emph{substitute()}}{Les fonctions quote() et substitute()}}\label{les-fonctions-quote-et-substitute}}

Les fonctions \emph{quote()} et \emph{substitute()} permettent de capturer une instruction sans l'évaluer. Pour généraliser, on va appeler cette capture une expression. La différence entre \emph{eval()} et \emph{substitute()} est décrite dans le chapitre \href{http://adv-r.had.co.nz/Computing-on-the-language.html}{Non-standard evaluation} de l'ouvrage d'Hadley Wickham, mais pour résumer \emph{quote()} ne fait que retourner l'expression qu'on lui donne en entrée alors que \emph{substitute} est un peu plus complexe.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{quote}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1:10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{quote}\NormalTok{(}\FunctionTok{f}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## f(1:10)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{quote}\NormalTok{(}\FunctionTok{f}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## f(x)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{quote}\NormalTok{(}\FunctionTok{f}\NormalTok{(x }\SpecialCharTok{+}\NormalTok{ y}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## f(x + y^2)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{substitute}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1:10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{substitute}\NormalTok{(}\FunctionTok{f}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## f(1:10)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{substitute}\NormalTok{(}\FunctionTok{f}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## f(x)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{substitute}\NormalTok{(}\FunctionTok{f}\NormalTok{(x }\SpecialCharTok{+}\NormalTok{ y}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## f(x + y^2)
\end{verbatim}

Une fois qu'on a fait cette capture de code, le but est d'évaluer cette expression dans un environnement spécifique et au moment où on le souhaitera avec la fonction \emph{eval()}.

\hypertarget{la-fonction-eval}{%
\subsection{\texorpdfstring{La fonction \emph{eval()}}{La fonction eval()}}\label{la-fonction-eval}}

Cette fonction permet d'évaluer une expression. Par défaut, elle est évaluée dans l'environnement courant de \textbf{R}. Autrement dit, si on considère l'expression suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{quote}\NormalTok{(}\FunctionTok{f.eval}\NormalTok{(x.eval))}
\end{Highlighting}
\end{Shaded}

Si on veut évaluer cette expression, il faut que la fonction \emph{f.eval()} et l'objet \textbf{x.eval} existent tous les deux dans l'environnement où on souhaite exécuter cette expression. Par défaut, \emph{eval()} ira chercher dans l'environnement courant. Ici, on obtient le message d'erreur suivant car la fonction \emph{f.eval()} et l'objet \textbf{x.eval} n'ont pas été définies au préalables :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{eval}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in f.eval(x.eval): impossible de trouver la fonction "f.eval"
\end{verbatim}

On considère un autre exemple avec l'expression suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{quote}\NormalTok{(Species }\SpecialCharTok{==} \StringTok{"setosa"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La commande suivante donnera un message d'erreur :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{eval}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in eval(a): objet 'Species' introuvable
\end{verbatim}

En revanche, on peut préciser qu'on va trouver le nom \textbf{Species} dans l'environnement du \textbf{data.frame} nommé \textbf{iris} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{eval}\NormalTok{(a, }\AttributeTok{envir =}\NormalTok{ iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [49]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [145] FALSE FALSE FALSE FALSE FALSE FALSE
\end{verbatim}

\hypertarget{et-en-pratique}{%
\subsubsection{Et en pratique ?}\label{et-en-pratique}}

Elles sont utilisées dans beaucoup de fonction sans qu'on s'en apperçoive nécessairement. On va voir quelques fonctions qui utilisent ces expressions :

\begin{itemize}
\tightlist
\item
  dans la fonction \emph{subset()}, le deuxième argument est considérée comme une expression :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{subset}\NormalTok{(iris, Species }\SpecialCharTok{==} \StringTok{"setosa"} \SpecialCharTok{\&}\NormalTok{ Sepal.Length }\SpecialCharTok{\textgreater{}} \FloatTok{5.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 15          5.8         4.0          1.2         0.2  setosa
## 16          5.7         4.4          1.5         0.4  setosa
## 19          5.7         3.8          1.7         0.3  setosa
\end{verbatim}

Ainsi, l'expression \emph{Species == ``setosa'' \& Sepal.Length \textgreater{} 5.5} sera évaluée dans le jeu de données \textbf{iris} ce qui permet d'éviter de faire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris[iris}\SpecialCharTok{$}\NormalTok{Species }\SpecialCharTok{==} \StringTok{"setosa"} \SpecialCharTok{\&}\NormalTok{ iris}\SpecialCharTok{$}\NormalTok{Sepal.Length }\SpecialCharTok{\textgreater{}} \FloatTok{5.5}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 15          5.8         4.0          1.2         0.2  setosa
## 16          5.7         4.4          1.5         0.4  setosa
## 19          5.7         3.8          1.7         0.3  setosa
\end{verbatim}

\begin{itemize}
\item
  les différentes fonctions \emph{filter()}, \emph{arrange()}, etc. du package \textbf{dplyr} présentées dans le chapitre précédent utilisent le même genre de syntaxe que celui de la fonction \emph{subset()}.
\item
  la fonction \emph{plot.defaut()} qui représente un nuage de points :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\FunctionTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-257-1.pdf}

Les arguments par défaut pour représenter la légende en abscisse et en ordonnées (\textbf{xlab} et \textbf{ylab}) correspondent aux expressions des paramètres \textbf{x} et \textbf{y} données en entrée.

\hypertarget{duxe9bugger-une-fonction}{%
\subsection{Débugger une fonction}\label{duxe9bugger-une-fonction}}

\hypertarget{analyser-le-message-derreur}{%
\subsubsection{Analyser le message d'erreur}\label{analyser-le-message-derreur}}

Lorsqu'un message d'erreur (ou d'avertissement) apparaît en rouge dans la console, la première chose à faire est d'essayer de le comprendre. La plupart du temps, le message est suffisament implicite pour qu'on puisse trouver d'où provient le problème.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in sum(c("a", "b")): 'type' (character) de l'argument incorrect
\end{verbatim}

Dans cet exemple, le message d'erreur n'intervient pas dans le coeur de la fonction, mais dans l'appel des arguments. Lorsque l'erreur est dûe à l'exécution d'une commande à l'intérieur d'une fonction, il est parfois plus difficile d'identifier d'où vient le problème.

\hypertarget{la-fonction-traceback}{%
\subsubsection{\texorpdfstring{La fonction \emph{traceback()}}{La fonction traceback()}}\label{la-fonction-traceback}}

Le principe de la fonction \emph{traceback()} est le suivant : si un message d'erreur est apparu à cause de l'appel d'une commande, l'historique qui a conduit à l'appel de cette commande sera affiché.

Ici, on créé une fonction \emph{ex\_bug()} à partir des fonctions \emph{mean\_rnorm.1()} et \emph{mean\_rnorm.2()} créées précédemment, dans laquelle on a glissé une erreur.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ex\_bug }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n, p) \{}
\NormalTok{  n2 }\OtherTok{\textless{}{-}} \FunctionTok{as.character}\NormalTok{(n)}
  \FunctionTok{length}\NormalTok{(}\FunctionTok{which}\NormalTok{(}\FunctionTok{mean\_rnorm.1}\NormalTok{(n2, p) }\SpecialCharTok{\textgreater{}} \FunctionTok{mean\_rnorm.2}\NormalTok{(n, p)))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

On obtient le message d'erreur suivant :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ex\_bug}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in mean_rnorm.1(n2, p): impossible de trouver la fonction "mean_rnorm.1"
\end{verbatim}

On appelle la fonction \emph{traceback()} dans la foulée du message d'erreur :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{traceback}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{4:}\NormalTok{ matrix}\ErrorTok{(}\ExtensionTok{0,}\NormalTok{ n, 1}\KeywordTok{)} \ExtensionTok{at} \CommentTok{\#2}
\ExtensionTok{3:}\NormalTok{ mean\_rnorm.1}\ErrorTok{(}\ExtensionTok{n2,}\NormalTok{ p}\KeywordTok{)} \ExtensionTok{at} \CommentTok{\#3}
\ExtensionTok{2:}\NormalTok{ which}\ErrorTok{(}\ExtensionTok{mean\_rnorm.1}\ErrorTok{(}\ExtensionTok{n2,}\NormalTok{ p}\KeywordTok{)} \OperatorTok{\textgreater{}}\NormalTok{ mean\_rnorm.2}\KeywordTok{(}\ExtensionTok{n,}\NormalTok{ p}\KeywordTok{))} \ExtensionTok{at} \CommentTok{\#3}
\ExtensionTok{1:}\NormalTok{ ex\_bug}\ErrorTok{(}\ExtensionTok{5,}\NormalTok{ 10}\KeywordTok{)}
\end{Highlighting}
\end{Shaded}

Comment interpéter le résultat de la fonction \emph{traceback()}. Le message d'erreur est intervenu au moment d'appeler la commande de la ligne 4. Cette commande a été appelée à la suite de l'appel de la commande de la ligne 3. La commande de la ligne 3 a été appelée suite à la commande de la ligne 2. La ligne 1 correspond bien entend à l'appel de la fonction de départ \emph{ex\_bug()}.

\hypertarget{la-fonction-debugonce}{%
\subsubsection{\texorpdfstring{La fonction \emph{debugonce()}}{La fonction debugonce()}}\label{la-fonction-debugonce}}

La fonction \emph{debugonce()} a pour objectif de rentrer dans le coeur de la fonction considérée et d'exécuter les lignes de code l'une après l'autre. Après chaque exécution, il est possible d'utiliser la fonction \emph{ls()}, \emph{print()}, etc. pour connaître le résultat des étapes intermédiaires. On n'est pas obligé d'utiliser cette fonction uniquement après l'affichage d'un message d'erreur. Parfois, on n'a pas de message d'erreur, mais le résultat retourné n'est pas celui attendu et il peut s'agir d'un problème de programmation. Dans ce cas là, l'idée est d'exécuter son code ligne après ligne et de vérifier les étapes intermédiaires.

On considère la fonction suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ex\_bug}\FloatTok{.2} \OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  x }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{  x }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{3}
\NormalTok{  x }\OtherTok{\textless{}{-}} \FunctionTok{log}\NormalTok{(x)}
\NormalTok{x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Pour utiliser la fonction \emph{debugonce()} :

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{debugonce}\ErrorTok{(}\ExtensionTok{ex\_bug.2}\KeywordTok{)}
\ExtensionTok{ex\_bug.2}\ErrorTok{(}\ExtensionTok{{-}5}\KeywordTok{)}
\end{Highlighting}
\end{Shaded}

En exécutant pas à pas la fonction \emph{ex\_bug.2(-5)}, on peut demander à chaque étape la valeur que prend la variable \textbf{x} en cours d'exécution ; il faut pour cela saisir la variable \textbf{x} devant le prompt du débugger (\emph{Browse{[}2{]}\textgreater{}}).

\hypertarget{nuxe9gliger-un-message-derreur}{%
\subsubsection{Négliger un message d'erreur}\label{nuxe9gliger-un-message-derreur}}

Une erreur entraîne l'interruption automatique du processus en cours d'execution. Parfois, on peut avoir une erreur, mais on ne souhaite pas que cela interrompe le processus.

\hypertarget{la-fonction-try}{%
\paragraph{\texorpdfstring{La fonction \emph{try()}}{La fonction try()}}\label{la-fonction-try}}

Si on connaît l'instruction qui peut entraîner une erreur, il est possible de lui appliquer la fonction \emph{try()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f\_error}\FloatTok{.1} \OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
  \FunctionTok{try}\NormalTok{(x }\OtherTok{\textless{}{-}} \FunctionTok{log}\NormalTok{(x))}
\NormalTok{  x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Ci-dessous, on constate que le message d'erreur est affiché, mais cela n'a pas interrompu la fonction.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f\_error.1}\NormalTok{(}\StringTok{"10"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in log(x) : argument non numérique pour une fonction mathématique
\end{verbatim}

\begin{verbatim}
## [1] "10"
\end{verbatim}

\textbf{Bibliographie :} pour plus de d'informations sur le débuggage, on renvoie le lecteur au chapitre \href{http://adv-r.had.co.nz/Exceptions-Debugging.html}{``Debugging, condition handling, and defensive programming''} du livre ``Advanced \textbf{R}'' d'Hadley Wickham.

\hypertarget{programmation-orientuxe9e-s3s4}{%
\section{Programmation orientée : S3/S4}\label{programmation-orientuxe9e-s3s4}}

\hypertarget{la-norme-s3}{%
\subsection{La norme S3}\label{la-norme-s3}}

Nous nous sommes inspirés du document suivant pour décrire la programmation orientée qui utilise la norme S3 : \url{http://www.duclert.org/r-divers/classes-S3-R.php}. Pour expliquer son principe, nous allons prende un exemple concret.

On voudrait calculer l'aire de différentes figures géométriques :

\begin{itemize}
\tightlist
\item
  un carré, dont il nous faut connaître la longueur d'un côté, par exemple :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{squ }\OtherTok{\textless{}{-}} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  un rectangle, défini par sa longueur et sa largeur, par exemple :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rec }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  un cercle, caractérisé par son rayon, par exemple :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cir }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Pour ce faire, on souhaiterait utiliser une fonction qui s'appelle \emph{getArea()} et qui puisse reconaître quand on l'applique à un carré, un rectangle ou un cercle afin d'utiliser la bonne formule. Ceci consiste à définir une méthode générique \textbf{getArea} qui renvoie à la bonne implémentation en fonction de la classe de l'argument d'entrée. C'est ce qu'on appelle le polymorphisme.

\hypertarget{duxe9finition-dune-nouvelle-classe}{%
\subsubsection{Définition d'une nouvelle classe}\label{duxe9finition-dune-nouvelle-classe}}

Pour pouvoir être identifié comme étant un objet particulier, les trois objets ci-dessus doivent être définis comme appartenant à une certaine classe, que l'utilisateur, dans la norme S3, peut lui-même créer. On définit ainsi ci-dessous les trois types de classe \textbf{carre}, \textbf{rectangle} et \textbf{cercle} en utilisant la fonction \emph{class()} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(cir) }\OtherTok{\textless{}{-}} \StringTok{"cercle"}
\NormalTok{cir}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.162278
## attr(,"class")
## [1] "cercle"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(rec) }\OtherTok{\textless{}{-}} \StringTok{"rectangle"}
\NormalTok{rec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5 6
## attr(,"class")
## [1] "rectangle"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(squ) }\OtherTok{\textless{}{-}} \StringTok{"carre"} 
\NormalTok{squ}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
## attr(,"class")
## [1] "carre"
\end{verbatim}

\textbf{Remarque :} à ce stade, nous n'avons créé aucune fonction qui puisse s'appliquer spécifiquement à ces objets. Cependant, comme ils ont été construits à la base comme des vecteurs, on peut toujours appliquer toutes les fonctions qui s'appliquent à des vecteurs de \textbf{numeric}.

Par ailleurs, pour calculer l'aire de ces objets, on pourrait écrire la fonction suivante qui traite le cas de chaque classe:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{area }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
   \ControlFlowTok{switch}\NormalTok{(}\FunctionTok{class}\NormalTok{(x), }
      \AttributeTok{carre =}\NormalTok{ x }\SpecialCharTok{\^{}} \DecValTok{2}\NormalTok{,}
      \AttributeTok{rectangle =}\NormalTok{ x[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{*}\NormalTok{ x[}\DecValTok{2}\NormalTok{],}
      \AttributeTok{cercle =}\NormalTok{ pi }\SpecialCharTok{*}\NormalTok{ x }\SpecialCharTok{\^{}} \DecValTok{2}\NormalTok{,}
      \StringTok{"class should be among carre/rec/cercle"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Cependant, si on considère une nouvelle classe d'objet (un triangle par exemple), on devra reprogrammer la fonction \emph{area()}.

C'est pourquoi on définit une méthode générique afin de de pouvoir greffer autant de nouvelles classes d'objet sur celle-ci (par exemple, \textbf{plot} est une méthode sur laquelle on peut appliquer différents types d'objets).

\hypertarget{duxe9finition-dune-muxe9thode-guxe9nuxe9rique}{%
\subsubsection{Définition d'une méthode générique}\label{duxe9finition-dune-muxe9thode-guxe9nuxe9rique}}

On va créer la fonction \emph{getArea()} qui va s'appliquer à ces classes d'objet en 3 étapes : \textbf{getArea} sera définie comme étant une méthode générique.

\begin{itemize}
\tightlist
\item
  La première étape consiste à définir la fonction \emph{getArea()} comme étant une méthode générique. Autrement dit, on signale à \textbf{R} que cette fonction sera ensuite implémentée sous différentes versions :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{getArea }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(obj)}
  \FunctionTok{UseMethod}\NormalTok{(}\StringTok{"getArea"}\NormalTok{, obj)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  La deuxième étape consiste à créer une fonction par défaut qui sera appliquée dans le cas où on appliquerait à la fonction \emph{getArea()} une classe d'objet autre que \textbf{carre}, \textbf{rectangle} ou \textbf{cercle}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{getArea.default }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(obj) \{}
  \FunctionTok{stop}\NormalTok{(}\StringTok{"Méthode getArea non définie pour ce type d\textquotesingle{}objet"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Enfin, on va créer les 3 ``sous'' fonctions de \emph{getArea()} en ajoutant simplement à \textbf{getArea} le suffixe \textbf{.cercle}, \textbf{.rectangle} et \textbf{.carre} :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{getArea.cercle }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(obj) \{}
\NormalTok{  pi }\SpecialCharTok{*}\NormalTok{ obj[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{\^{}} \DecValTok{2}
\NormalTok{\}}

\NormalTok{getArea.rectangle }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(obj) \{}
\NormalTok{  obj[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{*}\NormalTok{ obj[}\DecValTok{2}\NormalTok{]}
\NormalTok{\}}

\NormalTok{getArea.carre }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(obj) \{}
\NormalTok{  obj[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{\^{}}\DecValTok{2}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Voici un exemple d'application d'utilisation de la méthode \textbf{getArea} qu'on vient de créer :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getArea}\NormalTok{(cir)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 31.41593
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getArea}\NormalTok{(rec)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 30
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getArea}\NormalTok{(squ)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

Si on applique la méthode \textbf{getArea} à une classe d'objet non défini :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{5}
\FunctionTok{getArea}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in getArea.default(a): Méthode getArea non définie pour ce type d'objet
\end{verbatim}

\textbf{Exercice 2.8}

Ajouter à la méthode \textbf{getArea}, la classe triangle

\hypertarget{exemple-de-muxe9thodes-guxe9nuxe9riques}{%
\subsubsection{Exemple de méthodes génériques}\label{exemple-de-muxe9thodes-guxe9nuxe9riques}}

Il existe de nombreuses méthodes sous \textbf{R} qui sont déclarées comme génériques dans la norme S3. Par exemple, lorsqu'on utilise la fonction \emph{plot()} ci-dessous, on l'applique dans le premier cas sur deux vecteurs \textbf{numeric} et dans le deuxième cas, on l'applique sur le résultat de la fonction \emph{lm()} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{), }\FunctionTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{lm}\NormalTok{(Sepal.Length }\SpecialCharTok{\textasciitilde{}}\NormalTok{ Sepal.Width, }\AttributeTok{data =}\NormalTok{ iris))}
\end{Highlighting}
\end{Shaded}

De même, pour savoir si un objet appartient à la norme S3, ce qui sous-entend que des méthodes génériques pourront s'appliquer sur cet objet, on peut utiliser la fonction \emph{otype()} du package \textbf{pryr} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"pryr"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\AttributeTok{y =}\NormalTok{ letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{])}
\NormalTok{pryr}\SpecialCharTok{::}\FunctionTok{otype}\NormalTok{(df)    }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "S3"
\end{verbatim}

On constate qu'un \textbf{data.frame} appartient à la norme S3, ce qui sous entend qu'un nombre de méthodes génériques pourront s'appliquer dessus. La plupart du temps, ces objets qui appartiennent à la norme S3 sont créés à partir de \textbf{list}. Pour savoir comment ils sont constitués, on peut donc simplement utiliser la fonction \emph{str()}.

\hypertarget{pour-connauxeetre-les-objets-qui-sappliquent-sur-une-muxe9thode-guxe9nuxe9rique}{%
\paragraph{Pour connaître les objets qui s'appliquent sur une méthode générique}\label{pour-connauxeetre-les-objets-qui-sappliquent-sur-une-muxe9thode-guxe9nuxe9rique}}

On utilise la fonction \emph{methods()} appliquée au nom de la méthode. Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{methods}\NormalTok{(}\StringTok{"plot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] plot,ANY,ANY-method                       
##  [2] plot,color,ANY-method                     
##  [3] plot,psi_func,ANY-method                  
##  [4] plot,Spatial,missing-method               
##  [5] plot,SpatialGrid,missing-method           
##  [6] plot,SpatialGridDataFrame,missing-method  
##  [7] plot,SpatialLines,missing-method          
##  [8] plot,SpatialMultiPoints,missing-method    
##  [9] plot,SpatialPixels,missing-method         
## [10] plot,SpatialPixelsDataFrame,missing-method
## [11] plot,SpatialPoints,missing-method         
## [12] plot,SpatialPolygons,missing-method       
## [13] plot.acf*                                 
## [14] plot.aggr*                                
## [15] plot.amelia*                              
## [16] plot.bclust*                              
## [17] plot.boot*                                
## [18] plot.classIntervals*                      
## [19] plot.correspondence*                      
## [20] plot.data.frame*                          
## [21] plot.decomposed.ts*                       
## [22] plot.default                              
## [23] plot.dendrogram*                          
## [24] plot.density*                             
## [25] plot.ecdf                                 
## [26] plot.factor*                              
## [27] plot.formula*                             
## [28] plot.function                             
## [29] plot.ggplot*                              
## [30] plot.goodfit*                             
## [31] plot.gtable*                              
## [32] plot.hcl_palettes*                        
## [33] plot.hclust*                              
## [34] plot.histogram*                           
## [35] plot.HoltWinters*                         
## [36] plot.ica*                                 
## [37] plot.isoreg*                              
## [38] plot.lda*                                 
## [39] plot.lm*                                  
## [40] plot.lmrob*                               
## [41] plot.loadings*                            
## [42] plot.loddsratio*                          
## [43] plot.loglm*                               
## [44] plot.lowess*                              
## [45] plot.lts*                                 
## [46] plot.margin*                              
## [47] plot.mca*                                 
## [48] plot.mcd*                                 
## [49] plot.medpolish*                           
## [50] plot.mlm*                                 
## [51] plot.mvr*                                 
## [52] plot.mvrVal*                              
## [53] plot.numpy.ndarray*                       
## [54] plot.paretoTail*                          
## [55] plot.ppr*                                 
## [56] plot.prcomp*                              
## [57] plot.princomp*                            
## [58] plot.profile*                             
## [59] plot.profile.nls*                         
## [60] plot.R6*                                  
## [61] plot.randomForest*                        
## [62] plot.raster*                              
## [63] plot.ridgelm*                             
## [64] plot.scores*                              
## [65] plot.shingle*                             
## [66] plot.SOM*                                 
## [67] plot.somgrid*                             
## [68] plot.spec*                                
## [69] plot.stepfun                              
## [70] plot.stft*                                
## [71] plot.stl*                                 
## [72] plot.structable*                          
## [73] plot.svm*                                 
## [74] plot.table*                               
## [75] plot.trans*                               
## [76] plot.trellis*                             
## [77] plot.ts                                   
## [78] plot.tskernel*                            
## [79] plot.TukeyHSD*                            
## [80] plot.tune*                                
## [81] plot.venn                                 
## [82] plot.zoo                                  
## see '?methods' for accessing help and source code
\end{verbatim}

\hypertarget{pour-connauxeetre-les-muxe9thodes-qui-sappliquent-sur-une-classe-dobjet}{%
\paragraph{Pour connaître les méthodes qui s'appliquent sur une classe d'objet}\label{pour-connauxeetre-les-muxe9thodes-qui-sappliquent-sur-une-classe-dobjet}}

On utilise la fonction \emph{methods()} en précisant l'argument \textbf{class =}. Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{methods}\NormalTok{(}\AttributeTok{class =} \StringTok{"lm"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] add1           alias          anova          case.names     coerce        
##  [6] confint        cooks.distance deviance       dfbeta         dfbetas       
## [11] drop1          dummy.coef     effects        extractAIC     family        
## [16] formula        fortify        hatvalues      influence      initialize    
## [21] kappa          labels         logLik         model.frame    model.matrix  
## [26] nobs           plot           predict        print          proj          
## [31] qr             residuals      rstandard      rstudent       show          
## [36] simulate       slotsFromS3    summary        variable.names vcov          
## see '?methods' for accessing help and source code
\end{verbatim}

\textbf{Pour en savoir plus :} le lecteur pourra consulter la dernière partie du lien suivant qui donne un exemple de création de méthode générique plus complet, avec la possibilité de définir les commandes \textbf{+}, \textbf{{[}{]}}, etc. sur de nouvelles classes d'objet : \url{http://www.duclert.org/r-divers/classes-S3-R.php}.

\hypertarget{la-norme-s4}{%
\subsection{La norme S4}\label{la-norme-s4}}

Ici, on présentera uniquement les grandes lignes de la norme S4. Cette section est inspirée du chapitre \href{http://adv-r.had.co.nz/OO-essentials.html}{OO field guide} du livre d'Hadley Wickham.

La norme S4 s'inspire de la norme S3 auxquelles s'ajoutent certaines caractéristiques telles que :

\begin{itemize}
\tightlist
\item
  les classes sont définies en ajoutant un certain nombre de règles et de précisions les concernant. Pour mieux comprendre, dans l'exemple ci-dessous, on peut définir l'objet \textbf{a} comme appartenant à la classe \textbf{lm} dans la norme S3, alors qu'il n'en possède pas les caractéristiques :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{5}
\FunctionTok{class}\NormalTok{(a) }\OtherTok{\textless{}{-}} \StringTok{"lm"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  on utilisera un opérateur spécial \textbf{@} pour extraire des éléments d'un objet ayant la norme S4.
\end{itemize}

Pour savoir si un objet appartient à la norme S4, on peut utiliser la fonction \emph{isS4()}. La plupart du temps, la norme S4 n'a pas été utilisée pour définir des objets et fonctions qui appartiennant à l'environnement de base. Ils sont donc plutôt présents dans des nouveaux packages qu'on va charger.

Les principales fonctions utilisées pour travailler sur la norme S4 sont :

\begin{itemize}
\tightlist
\item
  la fonction \emph{setClass()} qui permet de définir une nouvelle classe. Le 1er argument est le nom de la classe, le second est le résultat de la fonction \emph{representation()} qui définit le nom et le type des éléments que la classe contient et le troisième argument est le résultat de la fonction \emph{prototype()} qui donne des valeurs par défaut. Par exemple :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setClass}\NormalTok{(}\StringTok{"Personne"}\NormalTok{, }\FunctionTok{representation}\NormalTok{(}\AttributeTok{nom =} \StringTok{"character"}\NormalTok{, }\AttributeTok{age =} \StringTok{"numeric"}\NormalTok{),}
                        \FunctionTok{prototype}\NormalTok{(}\AttributeTok{nom =} \ConstantTok{NA\_character\_}\NormalTok{, }\AttributeTok{age =} \ConstantTok{NA\_real\_}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  la fonction \emph{new()} permet de créer un nouvel objet.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hadley }\OtherTok{\textless{}{-}} \FunctionTok{new}\NormalTok{(}\StringTok{"Personne"}\NormalTok{, }\AttributeTok{nom =} \StringTok{"Hadley"}\NormalTok{, }\AttributeTok{age =} \DecValTok{31}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{Remarque :} on accède aux éléments d'un objet de norme S4 avec la commande spéciale \textbf{@} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hadley}\SpecialCharTok{@}\NormalTok{age}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 31
\end{verbatim}

Les autres fonctions utiles dont vous trouverez des exemples d'utilisation dans \url{http://adv-r.had.co.nz/S4.html} sont :

\begin{itemize}
\item
  la fonction \emph{setMethods()} permettant de définir des nouvelles méthodes.
\item
  les fonctions \emph{as()} et \emph{setAs()} pour passer d'une classe d'objet à une autre (quand cela est possible).
\item
  les fonctions \emph{setValidity()} et \emph{validObject()} pour vérifier la validité.
\item
  les fonctions \emph{showClass()}, \emph{showMethods()} et \emph{getMethod()} pour accéder aux propriétés des objets et méthodes créées.
\end{itemize}

\textbf{Bilbiographie :} la présentation de F. Leisch à useR! 2004 (\url{http://www.ci.tuwien.ac.at/Conferences/useR-2004/Keynotes/Leisch.pdf}) ainsi que le manuel de C. Genolini (\url{https://cran.r-project.org/doc/contrib/Genolini-PetitManuelDeS4.pdf}).

\hypertarget{visualiser-le-code-source-dune-fonction}{%
\section{Visualiser le code source d'une fonction}\label{visualiser-le-code-source-dune-fonction}}

Nous nous sommes inspirés du document suivant pour écrire cette section : \href{https://informatique-mia.inra.fr/r4ciam/sites/default/files/download/tutoriels/T-methods-fev16.pdf}{``Visualiser le code d'une fonction''}.

\hypertarget{la-fonction-est-dans-lenvironnement-courant}{%
\subsection{La fonction est dans l'environnement courant}\label{la-fonction-est-dans-lenvironnement-courant}}

Vous tapez le nom de la fonction dans la console et le code apparaît :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sapply}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function (X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) 
## {
##     FUN <- match.fun(FUN)
##     answer <- lapply(X = X, FUN = FUN, ...)
##     if (USE.NAMES && is.character(X) && is.null(names(answer))) 
##         names(answer) <- X
##     if (!isFALSE(simplify)) 
##         simplify2array(answer, higher = (simplify == "array"))
##     else answer
## }
## <bytecode: 0x55cc3db093e8>
## <environment: namespace:base>
\end{verbatim}

\hypertarget{la-fonction-est-une-muxe9thode-guxe9nuxe9rique-de-type-s3}{%
\subsection{La fonction est une méthode générique de type S3}\label{la-fonction-est-une-muxe9thode-guxe9nuxe9rique-de-type-s3}}

Vous tapez le nom d'une fonction \emph{lambda()} et vous obtenez une ligne \textbf{UseMethod(``lambda'')}. Ceci signifie que \textbf{lambda} est une méthode générique pour des objets issus de la classe S3. Il existe donc plusieurs fonctions associées à la fonction \emph{lambda()}. Pour connaître quelles sont les différentes fonctions associées à la fonction \emph{lambda()}, on utilise la fonction \emph{methods()}. Par exemple, pour la fonction \emph{summary()}, si on tape le nom de la fonction dans la console, on obtient :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{summary}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function (object, ...) 
## UseMethod("summary")
## <bytecode: 0x55cc41917e70>
## <environment: namespace:base>
\end{verbatim}

Pour obtenir les différentes fonctions associées à \emph{summary()}, on utilise donc la fonction \emph{methods()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{methods}\NormalTok{(}\StringTok{"summary"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] summary,ANY-method                   summary,DBIObject-method            
##  [3] summary,diagonalMatrix-method        summary,GridTopology-method         
##  [5] summary,sparseMatrix-method          summary,Spatial-method              
##  [7] summary.aggr*                        summary.amelia*                     
##  [9] summary.Anova.mlm*                   summary.aov                         
## [11] summary.aovlist*                     summary.aspell*                     
## [13] summary.assocstats*                  summary.bcnPowerTransform*          
## [15] summary.bcnPowerTransformlmer*       summary.boot*                       
## [17] summary.check_packages_in_dir*       summary.connection                  
## [19] summary.data.frame                   summary.Date                        
## [21] summary.default                      summary.Duration*                   
## [23] summary.ecdf*                        summary.factor                      
## [25] summary.ggplot*                      summary.glm                         
## [27] summary.glmrob*                      summary.goodfit*                    
## [29] summary.haven_labelled*              summary.hcl_palettes*               
## [31] summary.infl*                        summary.Interval*                   
## [33] summary.Kappa*                       summary.lca*                        
## [35] summary.lm                           summary.lmrob*                      
## [37] summary.lodds*                       summary.loddsratio*                 
## [39] summary.loess*                       summary.loglm*                      
## [41] summary.lts*                         summary.manova                      
## [43] summary.matrix                       summary.mcd*                        
## [45] summary.mi*                          summary.microbenchmark*             
## [47] summary.mlm*                         summary.multinom*                   
## [49] summary.mvr*                         summary.negbin*                     
## [51] summary.nlrob*                       summary.nls*                        
## [53] summary.nnet*                        summary.packageStatus*              
## [55] summary.pandas.core.frame.DataFrame* summary.pandas.core.series.Series*  
## [57] summary.Period*                      summary.polr*                       
## [59] summary.POSIXct                      summary.POSIXlt                     
## [61] summary.powerTransform*              summary.ppr*                        
## [63] summary.pr_DB*                       summary.prcomp*                     
## [65] summary.princomp*                    summary.proc_time                   
## [67] summary.proxy_registry*              summary.python.builtin.object*      
## [69] summary.rlang_error*                 summary.rlang_trace*                
## [71] summary.rlm*                         summary.shingle*                    
## [73] summary.srcfile                      summary.srcref                      
## [75] summary.stepfun                      summary.stl*                        
## [77] summary.svm*                         summary.table                       
## [79] summary.trellis*                     summary.tukeysmooth*                
## [81] summary.tune*                        summary.vctrs_sclr*                 
## [83] summary.vctrs_vctr*                  summary.warnings                    
## [85] summary.yearmon*                     summary.yearqtr*                    
## [87] summary.zoo*                        
## see '?methods' for accessing help and source code
\end{verbatim}

Pour lire le code des fonctions affichées ci-dessus, il y a deux options :

\begin{itemize}
\tightlist
\item
  si il n'y pas d'étoile à côté de la fonction, vous pouvez obtenir directement le code de la fonction en tapant son nom complet :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{summary.proc\_time}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function (object, ...) 
## {
##     if (!is.na(object[4L])) 
##         object[1L] <- object[1L] + object[4L]
##     if (!is.na(object[5L])) 
##         object[2L] <- object[2L] + object[5L]
##     object <- object[1L:3L]
##     names(object) <- c(gettext("user"), gettext("system"), gettext("elapsed"))
##     object
## }
## <bytecode: 0x55cc41918298>
## <environment: namespace:base>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  s'il y a une étoile, c'est que la fonction se trouve dans un package et qu'on doit indiquer le nom du package suivi de \textbf{:::} :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stats}\SpecialCharTok{:::}\NormalTok{summary.ecdf}
\end{Highlighting}
\end{Shaded}

Si on ne connaît pas le nom du package, on peut alors utiliser la fonction \emph{getAnywhere()} qui va chercher dans toutes les librairies chargées :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getAnywhere}\NormalTok{(summary.ecdf)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## A single object matching 'summary.ecdf' was found
## It was found in the following places
##   registered S3 method for summary from namespace stats
##   namespace:stats
## with value
## 
## function (object, ...) 
## {
##     n <- length(eval(expression(x), envir = environment(object)))
##     header <- paste("Empirical CDF:\t ", n, "unique values with summary\n")
##     structure(summary(knots(object), ...), header = header, class = "summary.ecdf")
## }
## <bytecode: 0x55cc5b7460d8>
## <environment: namespace:stats>
\end{verbatim}

\hypertarget{la-fonction-fait-appel-uxe0-du-code-c}{%
\subsection{\texorpdfstring{La fonction fait appel à du code \textbf{C}}{La fonction fait appel à du code C}}\label{la-fonction-fait-appel-uxe0-du-code-c}}

Si on affiche le code la fonction \emph{sum()}, on constate que le calcul n'est pas directement fait dans le corps de la fonction. C'est ce que nous avons vu précédemment, à savoir qu'il existe un grand nombre de fonctions qui font appel à du code compilé pour gagner en performances. Lorsqu'on voit dans une fonction les instructions \textbf{.Primitive()} ou \textbf{.Internal()}, cela signifie que \textbf{R} va en réalité exécuter des fonctions qui ont été compilées en \textbf{C}. La différence entre \textbf{.Primitive()} ou \textbf{.Internal()} vient du fait que dans le deuxième cas, on peut appeler des fonctions qui sont codées en langage \textbf{R}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sum}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function (..., na.rm = FALSE)  .Primitive("sum")
\end{verbatim}

On peut donc faire appel à du code \textbf{C} de plusieurs façons. On verra ici les deux principales façons de le faire.

\hypertarget{primitive-ou-.internal}{%
\subsubsection{\texorpdfstring{\textbf{.Primitive()} ou \textbf{.Internal()}}{.Primitive() ou .Internal()}}\label{primitive-ou-.internal}}

Il est difficile d'accéder directement au code source de la fonction exécutée par \textbf{.Primitive()} ou \textbf{.Internal()}. Il s'agit des fonctions qui font en général partie du package \textbf{base}. On peut utiliser la fonction \emph{show\_c\_source()} du package \textbf{pryr} qui va effectuer une recherche sur \href{https://github.com}{github} où a été déposé le source de l'ensemble des fichiers de codes pré-compilés utilisés dans \textbf{R} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pryr}\SpecialCharTok{::}\FunctionTok{show\_c\_source}\NormalTok{(}\FunctionTok{.Internal}\NormalTok{(}\FunctionTok{mean}\NormalTok{(x)))}
\end{Highlighting}
\end{Shaded}

\hypertarget{call}{%
\subsubsection{\texorpdfstring{\textbf{.Call()}}{.Call()}}\label{call}}

Dans d'autres situtations, une fonction fait appel à du code \textbf{C} via la fonction \emph{.Call()}. Par exemple :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{qnorm}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function (p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 
## .Call(C_qnorm, p, mean, sd, lower.tail, log.p)
## <bytecode: 0x55cc5bba54e8>
## <environment: namespace:stats>
\end{verbatim}

A priori, le code source est disponible dans les répertoires nommés \textbf{src} : soit dans \textbf{R}, soit dans les packages installés (dans les deux cas, les codes sources doivent donc être accessibles depuis les répertoires). Sinon, on peut faire une reherche en ligne en tapant dans le moteur de recherche les instructions suivantes :

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{site:https://svn.r{-}project.org/R/trunk/src}\NormalTok{ qnorm}
\end{Highlighting}
\end{Shaded}

\textbf{Biliographie : } pour en savoir plus sur le langage compilé, on pourra lire le chapitre \href{http://adv-r.had.co.nz/C-interface.html\#c-find-source}{R's C interface} du livre d'Hadley Wickham, ``Advanced \textbf{R}''.

\hypertarget{la-fonction-est-une-muxe9thode-guxe9nuxe9rique-de-type-s4}{%
\subsection{La fonction est une méthode générique de type S4}\label{la-fonction-est-une-muxe9thode-guxe9nuxe9rique-de-type-s4}}

C'est le cas des fonctions programmées dans le package \textbf{Matrix}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"Matrix"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si on utiliser la fonction \emph{methods()} sur la méthode \textbf{dim}, pour identifier les méthodes génériques qui s'appliquent à des objets S4, on constate que le nom de la fonction est suivi d'une virgule, suivi alors de la classe de l'objet sur laquelle s'applique la méthode. Dans le cas de \emph{dim()}, elle peut s'appliquer sur les classes d'objet \textbf{MatrixFactorization} ou \textbf{Matrix}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{methods}\NormalTok{(}\StringTok{"dim"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] dim,Matrix-method                dim,MatrixFactorization-method  
##  [3] dim.cell_limits*                 dim.data.frame                  
##  [5] dim.data.table*                  dim.dist*                       
##  [7] dim.gtable*                      dim.layout*                     
##  [9] dim.lodds*                       dim.loddsratio*                 
## [11] dim.pandas.core.frame.DataFrame* dim.pandas.core.series.Series*  
## [13] dim.permutation*                 dim.resample*                   
## [15] dim.scipy.sparse.base.spmatrix*  dim.SpatialGridDataFrame*       
## [17] dim.SpatialLinesDataFrame*       dim.SpatialMultiPointsDataFrame*
## [19] dim.SpatialPixelsDataFrame*      dim.SpatialPointsDataFrame*     
## [21] dim.SpatialPolygonsDataFrame*    dim.structable*                 
## [23] dim.tbl_lazy*                    dim.trellis*                    
## see '?methods' for accessing help and source code
\end{verbatim}

Pour obtenir le code source de la fonction \emph{dim()} qui s'applique à la classe d'objet \textbf{MatrixFactorization}, on utilise la fonction \emph{getMethod()} ainsi :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getMethod}\NormalTok{(}\StringTok{"dim"}\NormalTok{, }\StringTok{"MatrixFactorization"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Method Definition:
## 
## function (x) 
## x@Dim
## <bytecode: 0x55cc52cfac68>
## <environment: namespace:Matrix>
## 
## Signatures:
##         x                    
## target  "MatrixFactorization"
## defined "MatrixFactorization"
\end{verbatim}

Pour connaître les méthodes S4 qui s'appliquent sur une classe d'objets particuliers, on utilise la fonction \emph{showMethods()} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{showMethods}\NormalTok{(}\AttributeTok{class =} \StringTok{"MatrixFactorization"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Function "%m-%":
##  <not an S4 generic function>
## 
## Function "%m+%":
##  <not an S4 generic function>
## 
## Function "%within%":
##  <not an S4 generic function>
## 
## Function "addAttrToGeom":
##  <not an S4 generic function>
## 
## Function "as_date":
##  <not an S4 generic function>
## 
## Function "as_datetime":
##  <not an S4 generic function>
## 
## Function "as.difftime":
##  <not an S4 generic function>
## 
## Function "as.duration":
##  <not an S4 generic function>
## 
## Function "as.interval":
##  <not an S4 generic function>
## 
## Function "as.period":
##  <not an S4 generic function>
## 
## Function "asJSON":
##  <not an S4 generic function>
## 
## Function "bbox":
##  <not an S4 generic function>
## 
## Function "chgDefaults":
##  <not an S4 generic function>
## 
## Function "complete":
##  <not an S4 generic function>
## 
## Function "coordinates":
##  <not an S4 generic function>
## 
## Function "coordinates<-":
##  <not an S4 generic function>
## 
## Function "coordnames":
##  <not an S4 generic function>
## 
## Function "coordnames<-":
##  <not an S4 generic function>
## 
## Function "date<-":
##  <not an S4 generic function>
## 
## Function "day<-":
##  <not an S4 generic function>
## 
## Function "dbAppendTable":
##  <not an S4 generic function>
## 
## Function "dbBegin":
##  <not an S4 generic function>
## 
## Function "dbBind":
##  <not an S4 generic function>
## 
## Function "dbCallProc":
##  <not an S4 generic function>
## 
## Function "dbCanConnect":
##  <not an S4 generic function>
## 
## Function "dbClearResult":
##  <not an S4 generic function>
## 
## Function "dbColumnInfo":
##  <not an S4 generic function>
## 
## Function "dbCommit":
##  <not an S4 generic function>
## 
## Function "dbConnect":
##  <not an S4 generic function>
## 
## Function "dbCreateTable":
##  <not an S4 generic function>
## 
## Function "dbDataType":
##  <not an S4 generic function>
## 
## Function "dbDisconnect":
##  <not an S4 generic function>
## 
## Function "dbDriver":
##  <not an S4 generic function>
## 
## Function "dbExecute":
##  <not an S4 generic function>
## 
## Function "dbExistsTable":
##  <not an S4 generic function>
## 
## Function "dbFetch":
##  <not an S4 generic function>
## 
## Function "dbGetConnectArgs":
##  <not an S4 generic function>
## 
## Function "dbGetException":
##  <not an S4 generic function>
## 
## Function "dbGetInfo":
##  <not an S4 generic function>
## 
## Function "dbGetQuery":
##  <not an S4 generic function>
## 
## Function "dbGetRowCount":
##  <not an S4 generic function>
## 
## Function "dbGetRowsAffected":
##  <not an S4 generic function>
## 
## Function "dbGetStatement":
##  <not an S4 generic function>
## 
## Function "dbHasCompleted":
##  <not an S4 generic function>
## 
## Function "dbiDataType":
##  <not an S4 generic function>
## 
## Function "dbIsReadOnly":
##  <not an S4 generic function>
## 
## Function "dbIsValid":
##  <not an S4 generic function>
## 
## Function "dbListConnections":
##  <not an S4 generic function>
## 
## Function "dbListFields":
##  <not an S4 generic function>
## 
## Function "dbListObjects":
##  <not an S4 generic function>
## 
## Function "dbListResults":
##  <not an S4 generic function>
## 
## Function "dbListTables":
##  <not an S4 generic function>
## 
## Function "dbQuoteIdentifier":
##  <not an S4 generic function>
## 
## Function "dbQuoteLiteral":
##  <not an S4 generic function>
## 
## Function "dbQuoteString":
##  <not an S4 generic function>
## 
## Function "dbReadTable":
##  <not an S4 generic function>
## 
## Function "dbRemoveTable":
##  <not an S4 generic function>
## 
## Function "dbRollback":
##  <not an S4 generic function>
## 
## Function "dbSendQuery":
##  <not an S4 generic function>
## 
## Function "dbSendStatement":
##  <not an S4 generic function>
## 
## Function "dbSetDataMappings":
##  <not an S4 generic function>
## 
## Function "dbUnloadDriver":
##  <not an S4 generic function>
## 
## Function "dbUnquoteIdentifier":
##  <not an S4 generic function>
## 
## Function "dbWithTransaction":
##  <not an S4 generic function>
## 
## Function "dbWriteTable":
##  <not an S4 generic function>
## Function: dim (package base)
## x="MatrixFactorization"
## 
## 
## Function "dimensions":
##  <not an S4 generic function>
## 
## Function "disaggregate":
##  <not an S4 generic function>
## Function: expand (package Matrix)
## x="MatrixFactorization"
## 
## 
## Function "fetch":
##  <not an S4 generic function>
## 
## Function "format_ISO8601":
##  <not an S4 generic function>
## 
## Function "fullgrid":
##  <not an S4 generic function>
## 
## Function "fullgrid<-":
##  <not an S4 generic function>
## 
## Function "functions":
##  <not an S4 generic function>
## 
## Function "geometry":
##  <not an S4 generic function>
## 
## Function "geometry<-":
##  <not an S4 generic function>
## 
## Function "gridded":
##  <not an S4 generic function>
## 
## Function "gridded<-":
##  <not an S4 generic function>
## 
## Function "hour<-":
##  <not an S4 generic function>
## 
## Function "is.projected":
##  <not an S4 generic function>
## 
## Function "isSQLKeyword":
##  <not an S4 generic function>
## 
## Function "make.db.names":
##  <not an S4 generic function>
## 
## Function "merge":
##  <not an S4 generic function>
## 
## Function "minute<-":
##  <not an S4 generic function>
## 
## Function "month<-":
##  <not an S4 generic function>
## 
## Function "over":
##  <not an S4 generic function>
## 
## Function "polygons":
##  <not an S4 generic function>
## 
## Function "polygons<-":
##  <not an S4 generic function>
## 
## Function "proj4string":
##  <not an S4 generic function>
## 
## Function "proj4string<-":
##  <not an S4 generic function>
## 
## Function "qday<-":
##  <not an S4 generic function>
## 
## Function "rebuild_CRS":
##  <not an S4 generic function>
## 
## Function "recenter":
##  <not an S4 generic function>
## 
## Function "reclass_timespan":
##  <not an S4 generic function>
## 
## Function "second<-":
##  <not an S4 generic function>
## Function: show (package methods)
## object="MatrixFactorization"
## 
## Function: solve (package base)
## a="MatrixFactorization", b="ANY"
## a="MatrixFactorization", b="missing"
## a="MatrixFactorization", b="numeric"
## 
## 
## Function "spChFIDs":
##  <not an S4 generic function>
## 
## Function "spChFIDs<-":
##  <not an S4 generic function>
## 
## Function "split":
##  <not an S4 generic function>
## 
## Function "sppanel":
##  <not an S4 generic function>
## 
## Function "spplot":
##  <not an S4 generic function>
## 
## Function "spsample":
##  <not an S4 generic function>
## 
## Function "spTransform":
##  <not an S4 generic function>
## 
## Function "sqlAppendTable":
##  <not an S4 generic function>
## 
## Function "sqlCreateTable":
##  <not an S4 generic function>
## 
## Function "sqlData":
##  <not an S4 generic function>
## 
## Function "sqlInterpolate":
##  <not an S4 generic function>
## 
## Function "SQLKeywords":
##  <not an S4 generic function>
## 
## Function "sqlParseVariables":
##  <not an S4 generic function>
## 
## Function "surfaceArea":
##  <not an S4 generic function>
## 
## Function "time_length":
##  <not an S4 generic function>
## 
## Function "wkt":
##  <not an S4 generic function>
## 
## Function "year<-":
##  <not an S4 generic function>
\end{verbatim}

\hypertarget{calcul-paralluxe8le}{%
\chapter{Calcul parallèle}\label{calcul-paralluxe8le}}

Nous allons voir dans ce chapitre le principe du calcul parallèle et une façon d'en faire avec \textbf{R}. Ce document est fortement inspiré du tutoriel suivant \href{https://rawgit.com/PPgp/useR2017public/master/tutorial.html}{Introduction to parallel computing with R}. Le lecteur pourra également consulter cette présentation très intéressante de Vicent Miele \href{http://rug.mnhn.fr/semin-r/PDF/semin-R_calcul-parallele_VMiele_160617.pdf}{Le calcul parallèle pour non-spécialistes,c'est maintenant!}

Ce document a été généré directement depuis \textbf{RStudio} en utilisant l'outil Markdown. La version \emph{.pdf} se trouve \href{chapitre_3_avance.pdf}{ici}.

\textbf{Packages à installer}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"parallel"}\NormalTok{, }\StringTok{"snow"}\NormalTok{, }\StringTok{"snowFT"}\NormalTok{, }\StringTok{"VGAM"}\NormalTok{), }
                 \AttributeTok{dependencies =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{principe-du-calcul-paralluxe8le}{%
\section{Principe du calcul parallèle}\label{principe-du-calcul-paralluxe8le}}

On suppose que nous ayons un calcul à réaliser qui aurait cette forme :

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{initialize.rng}\ErrorTok{(}\ExtensionTok{...}\KeywordTok{)} \CommentTok{\# on définit une séquence de graines pour tirage aléatoire}
\ControlFlowTok{for} \KeywordTok{(}\ExtensionTok{iteration}\NormalTok{ in 1:N}\KeywordTok{)} \KeywordTok{\{}              \CommentTok{\# on répète N fois,  }
    \VariableTok{result}\OperatorTok{[}\NormalTok{iteration}\OperatorTok{]} \OperatorTok{\textless{}}\NormalTok{{-} }\ExtensionTok{myfunc}\ErrorTok{(}\ExtensionTok{...}\KeywordTok{)}  \CommentTok{\# la fonction myfunc() }
                                      \CommentTok{\# avec une valeur de graine différente par itération}
\KeywordTok{\}}
\ExtensionTok{process}\ErrorTok{(}\ExtensionTok{result,...}\KeywordTok{)} \CommentTok{\# récupération des résultats }
\end{Highlighting}
\end{Shaded}

\textbf{Exemple}: un exemple de programme ayant cette forme serait l'algorithme des forêts aléatoires, dans lequel \emph{myfunc()} permettrait de coder un arbre de régression ou de classification sur un échantillon qui serait tiré différemment à chaque itération. A la fin de la boucle, on agrège en général les résultats des différents arbres pour faire de la prédiction.

\begin{figure}
\centering
\includegraphics{Figures/rf.png}
\caption{Schéma des forêts aléatoires}
\end{figure}

Si on ne précise rien, le calcul précédent sera effectué de façon séquentiel, autrement dit il faut attendre qu'une itération soit terminée pour passer à la suivante. L'idée du calcul parallèle est de permettre de lancer le calcul de la fonction \emph{myfunc()}, en parallèle, comme le montre la figure suivante.

\begin{figure}
\centering
\includegraphics{Figures/Figure1.png}
\caption{Exemple de calcul parallèle}
\end{figure}

Avant de continuer à parler de calcul parallèle, rappelons la définition d'un processeur : ``Le processeur ou CPU (Central Processing Unit) est le composant de votre ordinateur qui exécute les instructions qui lui sont données par votre système d'exploitation. Quand vous exécutez un logiciel, décompressez une archive ZIP ou regardez une vidéo en haute définition, vous faites travailler en priorité le processeur ! Pour répondre à vos demandes les plus exigeantes, le processeur peut être doté de plusieurs coeurs.'' (définition extraite de \href{https://lecrabeinfo.net/le-role-des-processeurs-et-de-leurs-coeurs.html}{ce site})

Si un processeur ne possède qu'un seul coeur, il ne sera pas possible faire du calcul parallèle car les instructions seront traitées en série. Aujourd'hui, la plupart des machines sont dotées d'un processeur multi coeur, composé de deux ou plusieurs coeurs indépendants. Un processeur dual-core contient deux coeurs, un processeur quad-core quatre coeurs, etc. Sur la représentation graphique ci-dessous, on distingue bien les quatre coeurs du processeur.

\begin{figure}
\centering
\includegraphics{Figures/cpu.jpg}
\caption{CPU}
\end{figure}

Pour savoir combien de coeurs on dispose sur notre machine, on peut utiliser la fonction \emph{detectCores()} du package \textbf{parallel}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"parallel"}\NormalTok{)}
\FunctionTok{detectCores}\NormalTok{() }\CommentTok{\# nombre de coeurs physiques}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 40
\end{verbatim}

Cependant, un coeur peut lui-même se dédoubler : le nombre de tâches pouvant être exécuté correspond au nombre de ``Thread'' ou processeurs logiques. Pour connaître le nombre de Threads, on exécute la commande suivante :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{detectCores}\NormalTok{(}\AttributeTok{logical =} \ConstantTok{TRUE}\NormalTok{) }\CommentTok{\# nombre de Threads}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 40
\end{verbatim}

Sur Windows, il y a en général deux fois plus de Threads que de coeurs physiques. Dans notre cas, c'est le nombre de Threads qui nous intéresse plus particulièrement et c'est ce dernier chiffre que nous utiliserons pour faire du calcul parallèle. Dans la suite du cours, j'utiliserai l'expression coeur pour définir un Thread.

\textbf{Pour en savoir plus} sur les définitions des coeurs logiques et physiques, vous pouvez consulter cette page \href{https://fr.wikipedia.org/wiki/Hyper-Threading}{wikipedia}

\hypertarget{notion-de-programme-mauxeetre}{%
\section{Notion de programme maître}\label{notion-de-programme-mauxeetre}}

Dans l'exemple précédent, on a vu qu'on souhaitait répliquer \emph{N} fois la fonction \emph{myfunc()}, sachant que pour chaque itération, on utilise une valeur de graine différente (ce qui est logique sinon cela voudrait dire qu'on aurait \(N\) fois le même résultat). Si \(N\) est plus grand que le nombre de coeurs dont on dispose (ce qui est le plus souvent le cas), l'idée sera d'envoyer sur chaque coeur un certain nombre d'itération. Prenons par exemple \(N=100\) et 4 coeurs, dans ce cas il semble naturel de répartir les tâches de la façon suivante :

\begin{itemize}
\tightlist
\item
  le coeur 1 lancera les itérations 1, 5, 9, \ldots{} 93 et 97.
\item
  le coeur 2 lancera les itérations 2, 6, 10, \ldots, 94 et 98.
\item
  le coeur 3 lancera les itérations 3, 7, 11, \ldots, 95 et 99.
\item
  le coeur 4 lancera les itérations 4, 8, 12, \ldots, 96 et 100
\end{itemize}

L'idée du programme maître est qu'il devra spécifier cette répartition des tâches. Autrement dit, il devra indiquer que la fonction \emph{myfunc()} exécutera les itérations 1, 5, 9, \ldots{} 93 et 97 dans le coeur 1, les itérations 2, 6, 10, \ldots, 94 et 98 dans le coeur 2, etc.

Une fois les tâches effectuées, l'autre rôle du programme maître est de bien récupérer les sorties du programme parallélisé et d'en faire en général une synthèse (calcul de moyenne, d'écart-types, etc.).

On peut résumer ceci par la figure suivante :

\begin{figure}
\centering
\includegraphics{Figures/Figure2.png}
\caption{Exemple de programme maître}
\end{figure}

Il existe énormément de package permettant de faire du calcul parallèle. Nous utiliserons ici les packages \textbf{parallel} et \textbf{snow}.

\hypertarget{fonction-set.seed}{%
\section{\texorpdfstring{Fonction \emph{set.seed()}}{Fonction set.seed()}}\label{fonction-set.seed}}

Quand on fait de l'échantillonage ou qu'on simule des échantillons de façon aléatoire, on peut avoir besoin de retrouver les mêmes tirages. C'est le cas notamment lorsqu'on présente des résultats dans un rapport et qu'on souhaite que les résultats soient reproductibles.

La fonction \emph{set.seed()} est utilisée pour reproduire les mêmes tirages/échantillonages les uns à la suite des autres. Elle prend comme argument d'entrée un entier appelé \textbf{graine} ou ``seed'' qui est utilisée dans l'algorithme de simulation. En effet, la notion d'aléatoire au sens strict n'exite pas lorsqu'on fait de la simulation numérique. Dans la vraie vie, lorsqu'on tire une boule dans une urne (par exemple au tirage du loto), on comprend bien qu'il ne sera pas possible de tirer les mêmes boules deux fois de suite (si la condition d'aléatoire est bien respectée). En revanche, avec des simulations numériques, comme on utilise un algorithme dit pseudo-aléatoire, cela devient possible de répliquer un même tirage en utilisant le même nombre initial dans l'algorithme.

La fonction \emph{set.seed()} précède la fonction \emph{sample()} ou tout autre fonction génératrice de lois de distribution connues (\emph{rnorm()}, \emph{runif()}, \emph{rbinom()}, etc.). Par exemple, on souhaite faire à la suite :

\begin{itemize}
\tightlist
\item
  un tirage aléatoire de 5 nombres dans une urne comprenant 49 boules avec des numéros allant de 1 à 49 example,
\item
  simuler un bruit blanc de taille 5
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{200907}\NormalTok{)}
\NormalTok{(loto }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{49}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  4 21 18  8 37
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(white\_noise }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  0.69019477 -0.13529509  0.69372207 -0.73089395  0.02133644
\end{verbatim}

Si on répète cette même syntaxe, on obtiendra systématiquement les mêmes résultats.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{200907}\NormalTok{)}
\NormalTok{(loto }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{49}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  4 21 18  8 37
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(white\_noise }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  0.69019477 -0.13529509  0.69372207 -0.73089395  0.02133644
\end{verbatim}

Le lecteur trouvera plus d'informations sur la fonction \emph{set.seed()} dans cette vidéo : \url{https://www.youtube.com/watch?v=zAYzAZwufKI}

\textbf{Application dans un algorithme de type ``bootstrap''}

Dans le graphique suivant, on représente l'intérêt du bootstrap.

\begin{figure}
\centering
\includegraphics{Figures/bootstrap-sample.png}
\caption{Exemple d'algorithme de type bootstrap}
\end{figure}

Pour que cela fonctionne, il faut qu'à chaque simulation, on tire un échantillon différent. Autrement dit, il faut veiller à ne pas appliquer la fonction \emph{set.seed()} à un nombre constant dans la boucle \textbf{for}. Dans l'exemple suivant, on calcule l'estimateur ``bootstrap'' de la moyenne de la variable \textbf{Sepal.Length} du jeu de données \textbf{iris}. Comme la graine est fixée, on va toujours tirer le même échantillon et on aura un estimateur biaisée.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OtherTok{\textless{}{-}} \DecValTok{10}
\NormalTok{res\_mean }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(B)}
\ControlFlowTok{for}\NormalTok{ (b }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{B) \{}
  \FunctionTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\NormalTok{  samp }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\FunctionTok{nrow}\NormalTok{(iris), }\AttributeTok{replace =}\NormalTok{ T)}
\NormalTok{  res\_mean[b] }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(iris[samp, }\StringTok{"Sepal.Length"}\NormalTok{])}
\NormalTok{\}}
\NormalTok{res\_mean}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 5.774 5.774 5.774 5.774 5.774 5.774 5.774 5.774 5.774 5.774
\end{verbatim}

\textbf{Solution:} pour corriger le programme ci-dessus, il suffit de remplacer la valeur de la graine 123 par l'objet \textbf{b} qui varie de 1 à B.

\textbf{Exercice 3.1}

On considère le modèle de régression suivant où les données \textbf{wage1} sont issues du package \textbf{wooldridge}:

\[log(wage)=\beta_0+\beta_1 educ + \epsilon\]

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(wooldridge)}
\NormalTok{log\_wage\_model }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(lwage }\SpecialCharTok{\textasciitilde{}}\NormalTok{ educ, }\AttributeTok{data =}\NormalTok{ wage1)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  Calculer un estimateur bootstrap de \(\beta_0\) et \(\beta_1\). On fixe le nombre de réplications à \(B=1000\).
\item
  Representer l'histogramme des valeurs bootstrappées (un histogramme par coefficient), l'estimateur ``bootstrap'' de la moyenne et la vraie valeur.
\item
  Ecrire l'algorithme qui permette de faire la même chose en utilisant le calcul parallèle
\end{itemize}

\hypertarget{syntaxe-pour-lancer-un-calcul-paralluxe8le}{%
\section{Syntaxe pour lancer un calcul parallèle}\label{syntaxe-pour-lancer-un-calcul-paralluxe8le}}

On considère la fonction suivante qui permet de calculer la moyenne d'un échantillon de taille \textbf{r} simulée selon une loi normale de paramètre \textbf{mean} et \textbf{sd}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myfun }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(r, }\AttributeTok{mean =} \DecValTok{0}\NormalTok{, }\AttributeTok{sd =} \DecValTok{1}\NormalTok{) \{}
  \FunctionTok{mean}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(r, }\AttributeTok{mean =}\NormalTok{ mean, }\AttributeTok{sd =}\NormalTok{ sd))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

On souhaite répéter 100 fois cette fonction :

\begin{itemize}
\tightlist
\item
  25 fois quand \textbf{r} vaut 10,
\item
  25 fois quand \textbf{r} vaut 1000,
\item
  25 fois quand \textbf{r} vaut 100000,
\item
  25 fois quand \textbf{r} vaut 10000000,
\end{itemize}

avec \textbf{mean=5} et \textbf{sd=10}.

\hypertarget{syntaxe-dans-le-cas-non-paralluxe8le}{%
\subsection{Syntaxe dans le cas non parallèle}\label{syntaxe-dans-le-cas-non-paralluxe8le}}

Pour répondre à la problématique posée, on va d'abord utiliser la fonction \emph{sapply()} qui permet de répondre au problème de façon séquentielle. Autrement dit, elle va appliquer la fonction \emph{myfun()} itération après itération sur les différentes valeurs de \textbf{r} qu'on donne dans le 1er argument de la fonction \emph{sapply()}. D'abord, on créé le vecteur contenant les valeurs de \textbf{r} et on prépare aussi l'objet qui va contenir les résultats.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{r\_values }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{100000}\NormalTok{, }\DecValTok{10000000}\NormalTok{), }\AttributeTok{each =} \DecValTok{25}\NormalTok{)}
\NormalTok{resultats }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{r\_values =} \FunctionTok{factor}\NormalTok{(r\_values))}
\end{Highlighting}
\end{Shaded}

On lance la fonction \emph{sapply()} et on regarde le temps de calcul :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{time\_sapply }\OtherTok{\textless{}{-}} \FunctionTok{system.time}\NormalTok{(}
\NormalTok{  resultats}\SpecialCharTok{$}\NormalTok{res\_non\_par }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(r\_values, }\AttributeTok{FUN =}\NormalTok{ myfun, }
                \AttributeTok{mean =} \DecValTok{5}\NormalTok{, }\AttributeTok{sd =} \DecValTok{10}\NormalTok{) }\CommentTok{\# options de la fonction myfun}
\NormalTok{)}
\NormalTok{time\_sapply}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## utilisateur     système      écoulé 
##      15.890       0.832      16.723
\end{verbatim}

\hypertarget{syntaxe-dans-le-cas-paralluxe8le}{%
\subsection{Syntaxe dans le cas parallèle}\label{syntaxe-dans-le-cas-paralluxe8le}}

Pour exécuter la fonction précédente dans le cas parallèle, la syntaxe est la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{P }\OtherTok{\textless{}{-}} \DecValTok{4}  \CommentTok{\# définir le nombre de coeurs }
\NormalTok{cl }\OtherTok{\textless{}{-}} \FunctionTok{makeCluster}\NormalTok{(P) }\CommentTok{\# réserve 4 coeurs {-} début du calcul }
\NormalTok{time\_par }\OtherTok{\textless{}{-}} \FunctionTok{system.time}\NormalTok{(}
\NormalTok{ res\_par }\OtherTok{\textless{}{-}} \FunctionTok{clusterApply}\NormalTok{(cl, r\_values, }\AttributeTok{fun =}\NormalTok{ myfun, }\CommentTok{\# évalue myfun sur r\_values  }
                   \AttributeTok{mean =} \DecValTok{5}\NormalTok{, }\AttributeTok{sd =} \DecValTok{10}\NormalTok{)  }\CommentTok{\# options de myfun}
\NormalTok{)  }
\FunctionTok{stopCluster}\NormalTok{(cl) }\CommentTok{\# libère 4 coeurs {-} fin du calcul }
\NormalTok{time\_par}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## utilisateur     système      écoulé 
##       0.036       0.001       6.175
\end{verbatim}

La syntaxe est donc pratiquement la même que dans le cas non parallèle. Il suffit simplement d'utiliser la fonction \emph{makeCluster()} au début pour réserver le nombre de coeurs nécessaires et la fonction \emph{stopCluster()} à la fin pour libérer les coeurs. De même, c'est la fonction \emph{clusterApply()} qui permet de répartir la fonction \emph{myfun()} vers les différents coeurs.

Pendant l'execution d'un programe en parallèle, il est possible de vérifier que les coeurs sont en train de fonctionner en parallèle. Sur Windows, il suffit de cliquer sur le ``Gestionnaire des tâches'' pour voir l'état de l'utilisation des processeurs et/ou de la mémoire.

\begin{figure}
\centering
\includegraphics{Figures/processeur.png}
\caption{Gestionnaire des tâches Windows}
\end{figure}

\hypertarget{recommandations}{%
\subsection{Recommandations}\label{recommandations}}

\hypertarget{gestion-de-la-muxe9moire}{%
\subsubsection{Gestion de la mémoire}\label{gestion-de-la-muxe9moire}}

Si vous parallélisez un programme qui utilise \(x\) Go de RAM, vous allez a priori avoir besoin de \emph{Px} Go de RAM où \(P\) est le nombre de coeurs utilisés. Si dans le gestionnaire des tâches, vous vous rendez compte que vous utilisez un programme qui utilise \(100\%\) de la mémoire RAM, cela aura pour effet de réduire considérablement les temps de calcul.

\hypertarget{en-cas-dinterruption-du-programme-mauxeetre}{%
\subsubsection{En cas d'interruption du programme maître}\label{en-cas-dinterruption-du-programme-mauxeetre}}

Si vous quittez votre programme maître alors que le calcul parallèle est en train de tourner, dans ce cas il est probable que les coeurs alloués continuent de tourner même si votre session maître semble terminer (ceci peut se voir dans le ``Gestionnaire des tâches'' et ``Processus'', plusieurs processus \textbf{R} seront ouverts). Dans ce cas, il faudra penser à exécuter la fonction \emph{stopCluster()}. Si cela n'est pas suffisant (les coeurs continuent à tourner), il faudra vraisemblablement tuer les process à la main (dans ``Gestionnaire des tâches'', puis ``Processus'', puis click droit sur les icônes ``R for Windows'' et ``Fin de tâche'').

\hypertarget{choix-du-nombre-de-coeurs}{%
\subsubsection{Choix du nombre de coeurs}\label{choix-du-nombre-de-coeurs}}

Ici, nous avons utilisé 4 coeurs sur les 40 Threads disponibles de la machine, ce qui laisse un nombre considérable de coeurs libres. Sur une machine de type perso, il est d'usage de ne pas utiliser tous les coeurs disponibles afin d'en laisser un certain nombre de libres pour rendre le fonctionnement de la machine stable (qui doit en effet gérer d'autres processus que \textbf{R}). Sur un serveur dédié au calcul, il est a priori possible d'utiliser tous les coeurs disponible à cet usage.

Le gain en temps de calcul n'est pas linéaire en fonction du nombre de coeurs utilisés. Cependant, dans l'exemple ci-dessus, en utilisant 4 coeurs plutôt qu'un seul, on a eu un facteur environ 2.7 de gain en temps calcul. On s'est amusé à refaire le même calcul que précédemment, mais en faisant évoluer le nombre de coeurs alloué. Pour chaque coeur, on a répliqué 10 fois le calcul pour avoir une distribution du temps de calcul. Dans la figure ci-dessous, on a représenté la courbe du temps de calcul en fonction du nombre de coeurs alloués. On constate que :

\begin{itemize}
\tightlist
\item
  la tendance est décroissante mais pas linéaire
\item
  à partir de 5 coeurs, le temps gagné est de moins en moins significatif et on a une asymptote à partir de 10 coeurs.
\end{itemize}

\includegraphics{_main_files/figure-latex/unnamed-chunk-316-1.pdf}

La raison est qu'en faisant du calcul parallèle, il y a des flux d'informations qui communiquent entre le programme maître et les coeurs sollicités et que ces flux coûtent du temps. Aussi, parfois il arrive que les flux d'informations coûtent plus en temps que les calculs à proprement dit. Autrement dit, il peut arriver que le calcul parallèle ait un effet négatif sur le temps\ldots{} Nous verrons un exemple plus tard.

\hypertarget{ruxe9cupuxe9rer-les-ruxe9sultats}{%
\subsection{Récupérer les résultats}\label{ruxe9cupuxe9rer-les-ruxe9sultats}}

En utilisant la fonction \emph{sapply()} dans le cas non parallèle, le résultat est stocké sous forme d'un \textbf{array}. Avec la fonction \emph{clusterApply()}, le résultat est stocké sous forme de \textbf{list}. Dans les exemples précédents, une façon de récupérer les résultats est donc la suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resultats}\SpecialCharTok{$}\NormalTok{res\_par }\OtherTok{\textless{}{-}} \FunctionTok{unlist}\NormalTok{(res\_par)}
\end{Highlighting}
\end{Shaded}

On calcule ensuite la moyenne et l'écart-type en fonction des valeurs prises par \textbf{r\_values}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{aggregate}\NormalTok{(resultats[, }\DecValTok{2}\SpecialCharTok{:}\DecValTok{3}\NormalTok{], }\FunctionTok{list}\NormalTok{(}\AttributeTok{r\_values =} \FunctionTok{as.factor}\NormalTok{(resultats[, }\StringTok{"r\_values"}\NormalTok{])), }
          \ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{c}\NormalTok{(}\AttributeTok{MEAN =} \FunctionTok{mean}\NormalTok{(x), }\AttributeTok{SD =} \FunctionTok{sd}\NormalTok{(x)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   r_values res_non_par.MEAN res_non_par.SD res_par.MEAN  res_par.SD
## 1       10      4.155421997    2.472656827  5.345868959 3.337169270
## 2     1000      4.916073620    0.314449683  4.933190842 0.283616142
## 3    1e+05      5.004018285    0.035245747  5.001317638 0.028541400
## 4    1e+07      5.000064298    0.003280121  5.001150306 0.003045339
\end{verbatim}

On peut également utiliser la syntaxe \textbf{tidyverse} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"dplyr"}\NormalTok{)}
\NormalTok{resultats }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(r\_values) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarise\_all}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\AttributeTok{mean =}\NormalTok{ mean, }\AttributeTok{sd =}\NormalTok{ sd))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 4 x 5
##   r_values res_non_par_mean res_par_mean res_non_par_sd res_par_sd
##   <fct>               <dbl>        <dbl>          <dbl>      <dbl>
## 1 10                   4.16         5.35        2.47       3.34   
## 2 1000                 4.92         4.93        0.314      0.284  
## 3 1e+05                5.00         5.00        0.0352     0.0285 
## 4 1e+07                5.00         5.00        0.00328    0.00305
\end{verbatim}

Nous verrons un peu plus tard un équivalent de \emph{sapply()} en calcul parallèle qui permettra de récupérer les résultats sous forme simplifiée.

\hypertarget{utiliser-des-packages-objets-jeux-de-donnuxe9es-sur-les-diffuxe9rents-coeurs}{%
\subsection{Utiliser des packages, objets, jeux de données sur les différents coeurs}\label{utiliser-des-packages-objets-jeux-de-donnuxe9es-sur-les-diffuxe9rents-coeurs}}

Lorsqu'on lance un calcul en parallèle sur 4 coeurs, c'est comme si on ouvrait 4 nouvelles consoles \textbf{R}. Or, à l'ouverture d'une nouvelle console \textbf{R}, il n'y a par défaut aucun package ni objets chargés. C'est pourquoi si le programme fait appel à des librairies ou des objets, l'utilisateur devra le spécifier.

\hypertarget{utiliser-des-packages-sur-plusieurs-coeurs}{%
\subsubsection{Utiliser des packages sur plusieurs coeurs}\label{utiliser-des-packages-sur-plusieurs-coeurs}}

On reprend la fonction précédente dans laquelle on aimerait changer la loi de distribution gaussienne par une loi de Pareto. La fonction \emph{rpareto()} du package \textbf{VGAM} permet de faire cela. On a plusieurs possibilités pour programmer la fonction.

\textbf{Solution 1 :} elle consiste à utiliser la fonction \emph{library()} à l'intérieur de la fonction \emph{myfun\_pareto()}. Dans ce cas, si on lance un calcul en parallèle, la librarie sera chargée dans chaque coeur appelé.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myfun\_pareto }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(r, }\AttributeTok{scale =} \DecValTok{1}\NormalTok{, }\AttributeTok{shape =} \DecValTok{10}\NormalTok{) \{}
  \FunctionTok{library}\NormalTok{(}\StringTok{"VGAM"}\NormalTok{)}
  \FunctionTok{mean}\NormalTok{(}\FunctionTok{rpareto}\NormalTok{(r, }\AttributeTok{scale =}\NormalTok{ scale, }\AttributeTok{shape =}\NormalTok{ shape))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 2 :} elle consiste à utiliser la syntaxe suivante qui évite de charger toutes les fonctions du package \textbf{VGAM} mais qui indique dans quelle librairie il faut aller chercher la fonction \emph{rpareto()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myfun\_pareto }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(r, }\AttributeTok{scale =} \DecValTok{1}\NormalTok{, }\AttributeTok{shape =} \DecValTok{10}\NormalTok{) \{}
  \FunctionTok{mean}\NormalTok{(VGAM}\SpecialCharTok{::}\FunctionTok{rpareto}\NormalTok{(r, }\AttributeTok{scale =}\NormalTok{ scale, }\AttributeTok{shape =}\NormalTok{ shape))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Dans les deux cas, lorsqu'on executera cette fonction en parallèle, chaque coeur saura où trouver la fonction \emph{rpareto()}. Pour exécuter la fonction en parallèle :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{r\_values }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{100000}\NormalTok{), }\AttributeTok{each =} \DecValTok{25}\NormalTok{)}
\NormalTok{cl }\OtherTok{\textless{}{-}} \FunctionTok{makeCluster}\NormalTok{(P) }
\NormalTok{res\_par }\OtherTok{\textless{}{-}} \FunctionTok{clusterApply}\NormalTok{(cl, r\_values, }\AttributeTok{fun =}\NormalTok{ myfun\_pareto, }
                    \AttributeTok{scale =} \DecValTok{1}\NormalTok{, }\AttributeTok{shape =} \DecValTok{10}\NormalTok{) }
\FunctionTok{stopCluster}\NormalTok{(cl)  }
\end{Highlighting}
\end{Shaded}

\textbf{Solution 3 :} une façon alternative de procéder est d'écrire la fonction sans faire appel à la librairie \textbf{VGAM}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myfun\_pareto }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(r, }\AttributeTok{scale =} \DecValTok{1}\NormalTok{, }\AttributeTok{shape =} \DecValTok{10}\NormalTok{) \{}
  \FunctionTok{mean}\NormalTok{(}\FunctionTok{rpareto}\NormalTok{(r, }\AttributeTok{scale =}\NormalTok{ scale, }\AttributeTok{shape =}\NormalTok{ shape))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

En revanche, il faudra indiquer dans le programme maître, qu'on souhaite charger le package \textbf{VGAM} sur tous les coeurs que nous allons utiliser. Ceci se fait à l'aide de la fonction \emph{clusterEvalQ()}. Voici un exemple d'utilisation :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cl }\OtherTok{\textless{}{-}} \FunctionTok{makeCluster}\NormalTok{(P) }

\FunctionTok{clusterEvalQ}\NormalTok{(cl, }\FunctionTok{library}\NormalTok{(}\StringTok{"VGAM"}\NormalTok{))}
\NormalTok{res\_par }\OtherTok{\textless{}{-}} \FunctionTok{clusterApply}\NormalTok{(cl, r\_values, }\AttributeTok{fun =}\NormalTok{ myfun\_pareto, }
                    \AttributeTok{scale =} \DecValTok{1}\NormalTok{, }\AttributeTok{shape =} \DecValTok{10}\NormalTok{) }

\FunctionTok{stopCluster}\NormalTok{(cl) }
\end{Highlighting}
\end{Shaded}

\hypertarget{charger-des-objets-fonctions-ou-jeux-de-donnuxe9es-dans-les-diffuxe9rents-coeurs}{%
\subsubsection{Charger des objets, fonctions ou jeux de données dans les différents coeurs}\label{charger-des-objets-fonctions-ou-jeux-de-donnuxe9es-dans-les-diffuxe9rents-coeurs}}

On reprend l'exemple précédent dans lequel on modifie légèrement la fonction de telle sorte que les paramètres \textbf{scale} et \textbf{shape} ne sont pas reconnus en tant que variables locales.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myfun\_pareto }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(r) \{}
  \FunctionTok{mean}\NormalTok{(}\FunctionTok{rpareto}\NormalTok{(r, }\AttributeTok{scale =}\NormalTok{ scale, }\AttributeTok{shape =}\NormalTok{ shape))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Pour que la fonction ne retourne pas de messages d'erreurs, il faudra donc que les objets \textbf{scale} et \textbf{shape} soient définis en tant que variables globales, et ceci dans chaque coeur. Il est possible de faire cela, toujours grâce à la fonction \emph{clusterEvalQ()} que nous avons utilisée précédemment. Dans l'exemple suivant, la librairie \textbf{VGAM} sera chargée dans chaque coeur et les objets \textbf{scale} et \textbf{shape} seront également définis.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cl }\OtherTok{\textless{}{-}} \FunctionTok{makeCluster}\NormalTok{(P) }

\FunctionTok{clusterEvalQ}\NormalTok{(cl, \{}
  \FunctionTok{library}\NormalTok{(}\StringTok{"VGAM"}\NormalTok{)}
\NormalTok{  scale }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{  shape }\OtherTok{\textless{}{-}} \DecValTok{10}
\NormalTok{  \})}
\NormalTok{res\_par }\OtherTok{\textless{}{-}} \FunctionTok{clusterApply}\NormalTok{(cl, r\_values, }\AttributeTok{fun =}\NormalTok{ myfun\_pareto) }

\FunctionTok{stopCluster}\NormalTok{(cl) }
\end{Highlighting}
\end{Shaded}

Une autre façon est de définir ces objets depuis la session maître :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scale }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{shape }\OtherTok{\textless{}{-}} \DecValTok{10}
\end{Highlighting}
\end{Shaded}

puis d'exporter ces objets vers tous les coeurs qui seront utilisés dans la suite à l'aide de la fonction \emph{clusterExport()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cl }\OtherTok{\textless{}{-}} \FunctionTok{makeCluster}\NormalTok{(P) }

\FunctionTok{clusterExport}\NormalTok{(cl, }\FunctionTok{c}\NormalTok{(}\StringTok{"scale"}\NormalTok{, }\StringTok{"shape"}\NormalTok{))}
\FunctionTok{clusterEvalQ}\NormalTok{(cl, }\FunctionTok{library}\NormalTok{(}\StringTok{"VGAM"}\NormalTok{))}
\NormalTok{res\_par }\OtherTok{\textless{}{-}} \FunctionTok{clusterApply}\NormalTok{(cl, r\_values, }\AttributeTok{fun =}\NormalTok{ myfun\_pareto) }

\FunctionTok{stopCluster}\NormalTok{(cl) }
\end{Highlighting}
\end{Shaded}

Cette méthode peut s'avérer intéressante pour exporter des jeux de données vers les différents coeurs.

\hypertarget{fonctions-lapply-sapply-apply-mapply}{%
\subsection{\texorpdfstring{Fonctions \emph{lapply()}, \emph{sapply()}, \emph{apply()}, \emph{mapply()}}{Fonctions lapply(), sapply(), apply(), mapply()}}\label{fonctions-lapply-sapply-apply-mapply}}

Il existe des versions parallélisées de ces fonctions. Celles-ci sont nommées :

\begin{itemize}
\tightlist
\item
  \emph{parLapply()},
\item
  \emph{parSapply()},
\item
  \emph{parApply()},
\item
  \emph{clusterMap()}.
\end{itemize}

Ces fonctions font appel à la fonction \emph{clusterApply()}. Elles semblent en général un peu plus longue en temps de calcul mais permettent de simplifier la syntaxe de sortie (fonction \emph{parSapply()}) ou d'utiliser des arguments différents en fonction de l'itération (fonction \emph{clusterMap()}).

\textbf{Exemple :} dans le premier exemple de ce chapitre, nous avons utilisé la fonction \emph{sapply()} sur la fonction \emph{myfun()} ainsi

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res\_non\_par }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(r\_values, }\AttributeTok{FUN =}\NormalTok{ myfun,}
                      \AttributeTok{mean =} \DecValTok{5}\NormalTok{, }\AttributeTok{sd =} \DecValTok{10}\NormalTok{) }\CommentTok{\# options de la fonction myfun}
\end{Highlighting}
\end{Shaded}

Pour la version parallèle, on aurait pu remplacer simplement \emph{sapply()} par \emph{parSapply()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{P }\OtherTok{\textless{}{-}} \DecValTok{4}  \CommentTok{\# définir le nombre de coeurs }
\NormalTok{cl }\OtherTok{\textless{}{-}} \FunctionTok{makeCluster}\NormalTok{(P) }\CommentTok{\# réserve 4 coeurs {-} début du calcul }
\FunctionTok{system.time}\NormalTok{(}
\NormalTok{  res\_par }\OtherTok{\textless{}{-}} \FunctionTok{parSapply}\NormalTok{(cl, r\_values, }\AttributeTok{FUN =}\NormalTok{ myfun, }\CommentTok{\# évalue myfunc() sur r\_values  }
                    \AttributeTok{mean =} \DecValTok{5}\NormalTok{, }\AttributeTok{sd =} \DecValTok{10}\NormalTok{) }
\NormalTok{)  }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## utilisateur     système      écoulé 
##       0.003       0.000      16.030
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{stopCluster}\NormalTok{(cl) }\CommentTok{\# libère 4 coeurs {-} fin du calcul }
\end{Highlighting}
\end{Shaded}

\textbf{Remarque :} dans cet exemple, le gain en temps de calcul n'est pas aussi prononcé que lorsqu'on avait utilisé la fonction \emph{clusterApply()} seul. Ceci peut s'expliquer par le fait qu'il y a des opérations supplémentaires avec la fonction \emph{parSapply()}. Aussi, même si l'avantage ici est que le résultat est retourné sous forme de vecteur, on recommande d'utiliser la fonction \emph{clusterApply()}.

\hypertarget{autres-packages-de-calcul-paralluxe8le}{%
\subsection{Autres packages de calcul parallèle}\label{autres-packages-de-calcul-paralluxe8le}}

\begin{itemize}
\item
  \textbf{snowFT} : ce package permet de gérer le choix des graines de simulation de façon optimale à l'intérieur de chaque coeur. Nous en présenterons un exemple à la fin de ce chapitre car son utilisation semble prometteuse.
\item
  \textbf{foreach} : ce package permet de faire des boucles de type \textbf{for} en utilisant une syntaxe similaire. Le but est de faire tourner en parallèle les instructions à l'intérieur de la boucle \textbf{for}. Ce package est en général couplé avec le package \textbf{doParallel}, via le package \textbf{parallel} (voir \href{https://cran.r-project.org/web/packages/doParallel/vignettes/gettingstartedParallel.pdf}{vignette à ce lien}), dont on présente ci-dessous un exemple d'utilisation :
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"doParallel"}\NormalTok{)}
\FunctionTok{getDoParWorkers}\NormalTok{() }\CommentTok{\# affiche nombre de coeurs alloué}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{registerDoParallel}\NormalTok{(}\AttributeTok{cores =}\NormalTok{ P) }\CommentTok{\# alloue le nombre de coeurs souhaité}
\FunctionTok{getDoParWorkers}\NormalTok{() }\CommentTok{\# Pour vérifer qu\textquotesingle{}on utilise bien tous les coeurs}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(}
\NormalTok{  res\_par\_foreach }\OtherTok{\textless{}{-}} \FunctionTok{foreach}\NormalTok{(}\AttributeTok{i =}\NormalTok{ r\_values) }
   \SpecialCharTok{\%dopar\%} \FunctionTok{myfun}\NormalTok{(i, }\AttributeTok{mean =} \DecValTok{5}\NormalTok{, }\AttributeTok{sd =} \DecValTok{10}\NormalTok{)}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## utilisateur     système      écoulé 
##      11.841       0.736       5.086
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# pour revenir au nombre de coeur initial }
\FunctionTok{registerDoParallel}\NormalTok{(}\AttributeTok{cores =} \DecValTok{1}\NormalTok{)}

\CommentTok{\# présentation des resultats}
\NormalTok{resultats}\SpecialCharTok{$}\NormalTok{res\_par\_foreach }\OtherTok{\textless{}{-}} \FunctionTok{unlist}\NormalTok{(res\_par\_foreach)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{doMPI} : utilise une architecture mpi.
\end{itemize}

Des temps de calcul ont été comparés entre ces différentes solutions (voir \href{https://rawgit.com/PPgp/useR2017public/master/tutorial.html}{Introduction to parallel computing with R}), le package \textbf{parallel} est parmi ceux qui obtiennent les meilleurs résultats.

\textbf{Exercice 3.2.}

Le bagging est une technique utilisée pour améliorer la classification notamment celle des arbres de décision. On va programmer l'algorithme suivant :

\textbf{Entrées :}

\begin{itemize}
\tightlist
\item
  \textbf{ech\_test} l'échantillon test,
\item
  \textbf{ech\_appr} l'échantillon d'apprentissage,
\item
  \textbf{B} le nombre d'arbres,
\end{itemize}

Pour \(k = 1, ..., B\) :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Tirer un échantillon bootstrap dans \textbf{ech\_appr}
\item
  Construire un arbre CART sur cet échantillon bootstrap et prédire sur l'échantillon test.
\end{enumerate}

On va appliquer cet algorithme sur le jeu de données \textbf{iris} qui est inclus dans \textbf{R} par défaut. L'objectif est de prédire à quel type d'espèce appartient une fleur (variable \textbf{Species} qui contient 3 variétés) en fonction de ses caractéristiques (variables \textbf{Sepal.Length}, \textbf{Sepal.Width}, \textbf{Petal.Length} et \textbf{Petal.Width}).

Tout d'abord, on définit l'échantillon \textbf{ech\_test} qui contient les observations à prédire. Ici, on en tire 25 au hasard et les 125 observations restantes constitueront l'échantillon d'apprentissage :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{id\_pred }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{150}\NormalTok{, }\DecValTok{25}\NormalTok{, }\AttributeTok{replace =}\NormalTok{ F)}
\NormalTok{ech\_test }\OtherTok{\textless{}{-}}\NormalTok{ iris[id\_pred, ]}
\NormalTok{ech\_appr }\OtherTok{\textless{}{-}}\NormalTok{ iris[}\SpecialCharTok{{-}}\NormalTok{id\_pred,]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Créer la fonction \emph{class\_tree()} qui prend comme argument d'entrée la valeur de la graine \(k\) utilisée pour tirer un échantillon bootstrap de \textbf{ech\_appr} (il s'agit simplement d'un tirage aléatoire avec remise appliquée après la fonction \emph{set.seed(k)}), va constuire un arbre CART sur cet échantillon bootstrap et retournera la prédiction sur l'échantillon test \textbf{ech\_test}. On pourra utiliser les fonctions \emph{rpart()} et \emph{predict.rpart()}, mais l'objet retourné sera un vecteur de \textbf{character} contenant l'espèce prédite.
\end{itemize}

Le résultat de cette fonction est le suivant :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"rpart"}\NormalTok{)}
\FunctionTok{class\_tree}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "versicolor" "virginica"  "setosa"     "setosa"     "versicolor"
##  [6] "versicolor" "setosa"     "virginica"  "versicolor" "setosa"    
## [11] "versicolor" "versicolor" "setosa"     "virginica"  "virginica" 
## [16] "setosa"     "virginica"  "virginica"  "versicolor" "setosa"    
## [21] "virginica"  "versicolor" "virginica"  "setosa"     "setosa"
\end{verbatim}

\begin{itemize}
\item
  A présent, nous allons répéter 100 fois cette opération en effectuant du calcul parallèle. Pour cela, on aura besoin d'exporter dans les différents coeurs la librairie \textbf{rpart} et les objets suivants \textbf{ech\_test}, \textbf{ech\_appr}:
\item
  Récupérer les données et donner les valeurs prédites pour chaque observation de l'échantillon test.
\item
  Calculer le tableau de bien classés
\end{itemize}

\hypertarget{equilibrer-la-ruxe9partition-des-tuxe2ches}{%
\section{Equilibrer la répartition des tâches}\label{equilibrer-la-ruxe9partition-des-tuxe2ches}}

En envoyant plusieurs tâches dans différents coeurs, il se peut que certains coeurs soient plus sollicités que d'autres. On considère la fonction suivante qui consiste à calculer la moyenne d'un échantillon de taille \textbf{r} simulée selon une loi gaussienne.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rnmean }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(r, }\AttributeTok{mean =} \DecValTok{0}\NormalTok{, }\AttributeTok{sd =} \DecValTok{1}\NormalTok{) \{}
        \FunctionTok{mean}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(r, }\AttributeTok{mean =}\NormalTok{ mean, }\AttributeTok{sd =}\NormalTok{ sd))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Nous allons appliquer cette fonction en utilisant des valeurs de \textbf{r} qui soient très hétérogènes de telle sorte qu'on va créer un déséquilibre dans l'exécution des tâches.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N }\OtherTok{\textless{}{-}} \DecValTok{40}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{50}\NormalTok{)}
\NormalTok{r.seq }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{ceiling}\NormalTok{(}\FunctionTok{exp}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{14}\NormalTok{, }\AttributeTok{length =} \DecValTok{50}\NormalTok{))), N)}
\NormalTok{r.seq}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  903730    4576   79676 1202605  679133    1460    2981    9348   12439
## [10]   44995   19095  332464   16553  187749  122307    2585   51904   59875
## [19]   39005    3967   33813    6090    1266   69069  162755    8104  783424
## [28] 1042512  141089  288206    5279  383519    1684    2241   22027  510353
## [37]   10783    1942  249839  106025
\end{verbatim}

Si on parallèlise sur 4 coeurs, comment vont se répartir l'envoi des tâches sur les coeurs ? Cela va se faire automatiquement de la façon suivante :

\begin{itemize}
\tightlist
\item
  le coeur 1 va effectuer le calcul pour les valeurs de \textbf{r} suivantes : 162755 (1ère position de \textbf{r.seq}), 29311 (5ème position de \textbf{r.seq}), 1266 (9ème position de \textbf{r.seq}), etc.
\item
  le coeur 2 va effectuer le calcul pour les valeurs de \textbf{r} suivantes : 22027 (2ème position de \textbf{r.seq}), 1460 (6ème position de \textbf{r.seq}), 1942 (10ème position de \textbf{r.seq}), etc.
\item
  le coeur 3 va effectuer le calcul pour les valeurs de \textbf{r} suivantes : 3967 (3ème position de \textbf{r.seq}), 79676 (7ème position de \textbf{r.seq}), 9348 (11ème position de \textbf{r.seq}), etc.
\item
  le coeur 4 va effectuer le calcul pour les valeurs de \textbf{r} suivantes : 187749 (4ème position de \textbf{r.seq}), 51904 (8ème position de \textbf{r.seq}), 4576 (12ème position de \textbf{r.seq}), etc.
\end{itemize}

On constate que le 1er coeur va d'abord commencer à simuler un vecteur de taille 162755 alors que le second coeur va simuler un vecteur de taille 22027. Le second coeur devrait donc être monopolisé moins de temps que le premier. On peut alors se poser la question s'il va passer au calcul de sa seconde valeur à calculer une fois le premier calcul terminé.

Il est possible de faire un rapport de l'usage des coeurs grâce à la fonction \emph{snow.time()} du package \textbf{snow}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"snow"}\NormalTok{)}
\NormalTok{cl }\OtherTok{\textless{}{-}} \FunctionTok{makeCluster}\NormalTok{(P) }
\NormalTok{ctime1 }\OtherTok{\textless{}{-}} \FunctionTok{snow.time}\NormalTok{(}\FunctionTok{clusterApply}\NormalTok{(cl, r.seq, }\AttributeTok{fun =}\NormalTok{ rnmean))}
\FunctionTok{plot}\NormalTok{(ctime1, }\AttributeTok{title =} \StringTok{"Usage with clusterApply"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-341-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{stopCluster}\NormalTok{(cl) }
\end{Highlighting}
\end{Shaded}

Dans le graphique ci-dessus, les traits en vert correspondent à des périodes où un coeur \(i\) (\(i = 1, \ldots, 4\) en ordonnée) est en train d'effecture un calcul. Un trait bleu correspond à une période où le coeur est en repos. Aussi, on constate que dans un coeur donné, pour passer à l'exécution d'une nouvelle tâche, il faut attendre que toutes les instructions effectuées sur les coeurs en parallèle soient terminées. Autrement dit, le coeur 2 a du attendre que le coeur 1 ait terminé l'exécution de sa première tâche avant de pouvoir passer à la tâche suivante. Ceci n'est donc pas optimale.

Une alternative à la fonction \emph{clusterApply()} est d'utiliser la fonction \emph{clusterApplyLB()} qui a été optimisée pour cet usage. On constate ci-dessous que toutes les tâches n'ont plus besoin d'avoir été exécutées avant de passer aux suivantes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cl }\OtherTok{\textless{}{-}} \FunctionTok{makeCluster}\NormalTok{(P) }
\NormalTok{ctimeLB }\OtherTok{\textless{}{-}} \FunctionTok{snow.time}\NormalTok{(}\FunctionTok{clusterApplyLB}\NormalTok{(cl, r.seq, }\AttributeTok{fun =}\NormalTok{ rnmean))}
\FunctionTok{plot}\NormalTok{(ctimeLB, }\AttributeTok{title =} \StringTok{"Usage with clusterApplyLB"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-342-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{stopCluster}\NormalTok{(cl) }
\end{Highlighting}
\end{Shaded}

Le gain en temps de calcul est d'un facteur 1.4.

\textbf{Remarque :} dès lors que nous avons chargé la librairie \textbf{snow}, ce sont les fonctions \emph{clusterApply()} et \emph{clusterApplyLB()} du package \textbf{snow} qui ont été utilisées alors qu'elles existent simultanément dans les packages \textbf{snow} et \textbf{parallel}. Elles sont quasiment équivalentes d'un package à un autre, mais pour garder en mémoire le rapport sur l'usage des coeurs, il faut utiliser les fonctions du package \textbf{snow}.

\hypertarget{amuxe9liorer-la-ruxe9partition-des-tuxe2ches}{%
\section{Améliorer la répartition des tâches}\label{amuxe9liorer-la-ruxe9partition-des-tuxe2ches}}

Dans l'exemple précédent, on a vu qu'il y avait sans arrêt des flux d'information entre le programme maître et les coeurs car on a 40 calculs ou `jobs' qui sont envoyés au fur et à mesure dans les coeurs alloués. Une façon de déjouer cela est de re-travailler le programme maître pour indiquer que les 10 premières tâches seront envoyées dans le 1er coeur, les 10 suivantes dans le second, etc. Pour cela, on modifie d'abord la fonction \emph{rnmean()} afin qu'elle puisse s'appliquer avec \textbf{r} défini comme un vecteur, plutôt qu'un scalaire :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rnmean\_vect }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(r, }\AttributeTok{mean =} \DecValTok{0}\NormalTok{, }\AttributeTok{sd =} \DecValTok{1}\NormalTok{) \{}
        \FunctionTok{sapply}\NormalTok{(r, }
         \ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{mean}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(x, }\AttributeTok{mean =}\NormalTok{ mean, }\AttributeTok{sd =}\NormalTok{ sd)))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Ensuite, on transforme le vecteur \textbf{r.seq} en liste composée de 4 sous vecteurs.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{r.seq\_list }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(r.seq[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{],}
\NormalTok{                   r.seq[}\DecValTok{11}\SpecialCharTok{:}\DecValTok{20}\NormalTok{],}
\NormalTok{                   r.seq[}\DecValTok{21}\SpecialCharTok{:}\DecValTok{30}\NormalTok{],}
\NormalTok{                   r.seq[}\DecValTok{31}\SpecialCharTok{:}\DecValTok{40}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Enfin, on refait appel à la fonction

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"snow"}\NormalTok{)}
\NormalTok{cl }\OtherTok{\textless{}{-}} \FunctionTok{makeCluster}\NormalTok{(P) }
\NormalTok{ctime }\OtherTok{\textless{}{-}} \FunctionTok{snow.time}\NormalTok{(}\FunctionTok{clusterApply}\NormalTok{(cl, r.seq\_list, }\AttributeTok{fun =}\NormalTok{ rnmean\_vect))}
\FunctionTok{plot}\NormalTok{(ctime, }\AttributeTok{title =} \StringTok{"Usage with clusterApply"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-345-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{stopCluster}\NormalTok{(cl) }
\end{Highlighting}
\end{Shaded}

A travers cet exemple, on voit que les flux d'informations sont minimes et le temps de calcul par conséquent meilleur avec une amélioration d'un facteur 3.3.

\textbf{Exercice 3.3.}

En vous inspirant de cette section, améliorer la fonction \emph{class\_tree()} vue précédemment en la vectorisant. Le but est de ne faire que 4 jobs (25 bootstrap par job) au lieu de 100. Comparer le temps de calcul avec la version non vectorisée.

\hypertarget{fonction-vectorisuxe9e-vs-calcul-vs-code-c}{%
\section{\texorpdfstring{Fonction vectorisée VS calcul // VS code \textbf{C++}}{Fonction vectorisée VS calcul // VS code C++}}\label{fonction-vectorisuxe9e-vs-calcul-vs-code-c}}

Faire du calcul // n'est pas nécessairement bénéfique si celui-ci n'est pas utilisé dans les règles de l'art. Dans cette section, on va comparer plusieurs façons de coder le même problème.

On considère le jeu de données suivant qui prend un peu moins d'1 Go de mémoire vive (10M d'observations et 3 variables).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{10000000} 
\NormalTok{big\_file }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{chiffre =} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n,}
                       \AttributeTok{lettre =} \FunctionTok{paste0}\NormalTok{(}\StringTok{"caract"}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\NormalTok{n), }
                       \AttributeTok{date =} \FunctionTok{sample}\NormalTok{(}\FunctionTok{seq.Date}\NormalTok{(}\FunctionTok{as.Date}\NormalTok{(}\StringTok{"2017{-}10{-}01"}\NormalTok{),}
                                        \AttributeTok{by =} \StringTok{"day"}\NormalTok{, }\AttributeTok{len =} \DecValTok{100}\NormalTok{), n,}
                                     \AttributeTok{replace =}\NormalTok{ T))}
\FunctionTok{object.size}\NormalTok{(big\_file)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 840001520 bytes
\end{verbatim}

L'objectif est de créer une nouvelle variable binaire qui vaut 1 si la variable \textbf{chiffre} est paire est 0 sinon. Pour cela, on va comparer plusieurs moyens pour y arriver.

\textbf{Solution 1 :} on va utiliser la fonction \emph{ifelse()} qui s'applique sur la fonction \textbf{\%\%}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sol\_1 }\OtherTok{\textless{}{-}}\NormalTok{ microbenchmark}\SpecialCharTok{::}\FunctionTok{microbenchmark}\NormalTok{(\{}
\NormalTok{  big\_file}\SpecialCharTok{$}\NormalTok{new }\OtherTok{\textless{}{-}} \FunctionTok{ifelse}\NormalTok{(big\_file}\SpecialCharTok{$}\NormalTok{chiffre }\SpecialCharTok{\%\%} \DecValTok{2} \SpecialCharTok{==} \DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{) }
\NormalTok{\}, }\AttributeTok{times =}\NormalTok{ 10L}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 2 :} on va utiliser les opérateurs d'affectation et la fonction \textbf{\%\%}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sol\_2 }\OtherTok{\textless{}{-}}\NormalTok{ microbenchmark}\SpecialCharTok{::}\FunctionTok{microbenchmark}\NormalTok{(\{}
\NormalTok{  big\_file}\SpecialCharTok{$}\NormalTok{new }\OtherTok{\textless{}{-}} \FunctionTok{as.numeric}\NormalTok{(big\_file}\SpecialCharTok{$}\NormalTok{chiffre }\SpecialCharTok{\%\%} \DecValTok{2} \SpecialCharTok{==} \DecValTok{0}\NormalTok{)  }
\NormalTok{\}, }\AttributeTok{times =}\NormalTok{ 10L}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 3 :} on va utiliser du calcul // avec la fonction \emph{foreach()}. D'abord, on créé la fonction à paralléliser qui regarde si un chiffre est pair ou non :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{compare }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x)}
\NormalTok{  x }\SpecialCharTok{\%\%} \DecValTok{2} \SpecialCharTok{==} \DecValTok{0} 
\end{Highlighting}
\end{Shaded}

Ensuite, on parallélise avec la fonction \emph{foreach()} (ici, sur les 1000 premières valeurs uniquement car le temps de calcul serait trop long sur l'ensemble des individus) :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"doParallel"}\NormalTok{)}
\NormalTok{P }\OtherTok{\textless{}{-}} \DecValTok{4} 
\FunctionTok{registerDoParallel}\NormalTok{(}\AttributeTok{cores =}\NormalTok{ P) }
\FunctionTok{system.time}\NormalTok{(}
\NormalTok{  res }\OtherTok{\textless{}{-}} \FunctionTok{foreach}\NormalTok{(}\AttributeTok{i =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{1000}\NormalTok{) }\SpecialCharTok{\%dopar\%} 
    \FunctionTok{compare}\NormalTok{(big\_file}\SpecialCharTok{$}\NormalTok{chiffre[i])}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Dans cet exemple, on a mal programmé la parallélisation comme cela a été vue dans la section 1.6. On va donc re-programmer la fonction à paralléliser pour indiquer que l'on souhaite faire le calcul des 2500000 premières observations sur le 1er coeur, les 2500000 suivantes sur le second coeur, etc. Comme la fonction \emph{compare()} est déjà vectorisée, ce n'est pas la peine de la changer. En revanche, on change l'appel de la fonction \emph{foreach()} afin de l'adapter à ce que l'on souhaite faire :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"doParallel"}\NormalTok{)}
\NormalTok{sol\_3 }\OtherTok{\textless{}{-}}\NormalTok{ microbenchmark}\SpecialCharTok{::}\FunctionTok{microbenchmark}\NormalTok{(\{}
\FunctionTok{registerDoParallel}\NormalTok{(}\AttributeTok{cores =}\NormalTok{ P) }
\NormalTok{res }\OtherTok{\textless{}{-}} \FunctionTok{foreach}\NormalTok{(}\AttributeTok{i =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{) }\SpecialCharTok{\%dopar\%} 
  \FunctionTok{compare}\NormalTok{(big\_file[(}\DecValTok{1} \SpecialCharTok{+} \DecValTok{2500000} \SpecialCharTok{*}\NormalTok{ (i }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{))}\SpecialCharTok{:}\NormalTok{(}\DecValTok{2500000} \SpecialCharTok{*}\NormalTok{ i),                           }\StringTok{"chiffre"}\NormalTok{])}
\NormalTok{\}, }\AttributeTok{times =}\NormalTok{ 10L}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 4 :} on va utiliser du code \textbf{C++}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}Rcpp.h\textgreater{}}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp}\OperatorTok{;}
  
\CommentTok{// [[Rcpp::export]]}
\NormalTok{IntegerVector compare\_cpp}\OperatorTok{(}\NormalTok{IntegerVector x}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=}\NormalTok{ x}\OperatorTok{.}\NormalTok{size}\OperatorTok{();}
\NormalTok{    IntegerVector res}\OperatorTok{(}\NormalTok{n}\OperatorTok{);}
    
    \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
      \ControlFlowTok{if}\OperatorTok{(}\NormalTok{x}\OperatorTok{(}\NormalTok{i}\OperatorTok{)} \OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{      res}\OperatorTok{(}\NormalTok{i}\OperatorTok{)} \OperatorTok{=} \DecValTok{1}\OperatorTok{;}
      \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{      res}\OperatorTok{(}\NormalTok{i}\OperatorTok{)} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}}
    
    \ControlFlowTok{return}\NormalTok{ res}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"Rcpp"}\NormalTok{)}
\NormalTok{sol\_4 }\OtherTok{\textless{}{-}}\NormalTok{ microbenchmark}\SpecialCharTok{::}\FunctionTok{microbenchmark}\NormalTok{(}
\NormalTok{  big\_file}\SpecialCharTok{$}\NormalTok{new }\OtherTok{\textless{}{-}} \FunctionTok{compare\_cpp}\NormalTok{(big\_file}\SpecialCharTok{$}\NormalTok{chiffre),}
  \AttributeTok{times =}\NormalTok{ 10L)}
\end{Highlighting}
\end{Shaded}

Représentons les performances de ces 4 solutions :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{time\_mbm }\OtherTok{\textless{}{-}} \FunctionTok{rbind}\NormalTok{(sol\_1, sol\_2, sol\_3, sol\_4)}
\NormalTok{time\_mbm}\SpecialCharTok{$}\NormalTok{expr }\OtherTok{\textless{}{-}} \FunctionTok{paste0}\NormalTok{(}\StringTok{"solution"}\NormalTok{, }\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\AttributeTok{each =} \DecValTok{10}\NormalTok{))}
\NormalTok{ggplot2}\SpecialCharTok{::}\FunctionTok{autoplot}\NormalTok{(time\_mbm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Coordinate system already present. Adding new coordinate system, which will replace the existing one.
\end{verbatim}

\includegraphics{_main_files/figure-latex/unnamed-chunk-355-1.pdf}

Si on compare les 4 solutions, c'est celle qui utilise \textbf{C++} qui est la plus performante. Souvent, lorsqu'un programme compte un grand nombre de boucles, c'est effectivement cette solution qui est la meilleure. Ici, le calcul // (à condition que la méthode soit bien implantée) donne des résultats équivalents à la solution 2 qui utilise la commande \textbf{\%\%}. Il n'y a pas d'améliorations à utiliser du code // ici car les flux d'informations entre le programme maître et les coeurs sont importants (en effet, on transfère une grosse quantité de données). Enfin, on constate que la solution 1 prend quant à elle plus de temps que la solution 2 car la fonction \emph{ifelse()} contient pas mal de codes internes.

\hypertarget{reproductibilituxe9-des-ruxe9sultats-choix-de-la-graine-aluxe9atoire}{%
\section{Reproductibilité des résultats : choix de la graine aléatoire}\label{reproductibilituxe9-des-ruxe9sultats-choix-de-la-graine-aluxe9atoire}}

Il est de plus en plus souvent demander aux programmeurs de coder de telle sorte que leur résultats soient reproductibles par d'autres sur n'importe quelle machine. Lorsqu'on fait des simulations, il est possible de fixer une graine avec la fonction \emph{set.seed()}, mais ceci n'est valable que sur la machine ``maître'\,'. Ainsi, on peut exécuter autant de fois que l'on souhaite l'instruction suivante, cela donnera des résultats différents à chaque fois car des tirages différents ont été réalisés à chaque itération.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cl }\OtherTok{\textless{}{-}} \FunctionTok{makeCluster}\NormalTok{(P) }
\NormalTok{res\_par }\OtherTok{\textless{}{-}} \FunctionTok{parSapply}\NormalTok{(cl, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\FunctionTok{mean}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{100}\NormalTok{)))}
\FunctionTok{stopCluster}\NormalTok{(cl) }
\end{Highlighting}
\end{Shaded}

Une façon de régler ce problème est de fixer une graine à l'intérieur de la fonction qu'on parallèlise (comme ce qui a déjà été fait précédemment) :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rnmean }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, r, }\AttributeTok{mean =} \DecValTok{0}\NormalTok{, }\AttributeTok{sd =} \DecValTok{1}\NormalTok{) \{}
  \FunctionTok{set.seed}\NormalTok{(x)}
  \FunctionTok{mean}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(r, }\AttributeTok{mean =}\NormalTok{ mean, }\AttributeTok{sd =}\NormalTok{ sd))}
\NormalTok{\}}

\NormalTok{cl }\OtherTok{\textless{}{-}} \FunctionTok{makeCluster}\NormalTok{(P) }
\NormalTok{res\_par }\OtherTok{\textless{}{-}} \FunctionTok{parSapply}\NormalTok{(cl, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{, rnmean, }
                     \AttributeTok{r =} \DecValTok{100}\NormalTok{, }\AttributeTok{mean =} \DecValTok{0}\NormalTok{, }\AttributeTok{sd =} \DecValTok{1}\NormalTok{)}
\FunctionTok{stopCluster}\NormalTok{(cl) }
\end{Highlighting}
\end{Shaded}

Une autre façon de faire est d'utiliser la fonction \emph{performParallel()} du package \textbf{snowFT} qui gère parfaitement la gestion des graines aléatoires et fait en sorte d'attribuer dans chaque coeur des graines qui pourront être reproduites.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rnmean }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(r, }\AttributeTok{mean =} \DecValTok{0}\NormalTok{, }\AttributeTok{sd =} \DecValTok{1}\NormalTok{) \{}
        \FunctionTok{mean}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(r, }\AttributeTok{mean =}\NormalTok{ mean, }\AttributeTok{sd =}\NormalTok{ sd))}
\NormalTok{\}}

\FunctionTok{library}\NormalTok{(}\StringTok{"snowFT"}\NormalTok{)}
\NormalTok{seed }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{r\_values }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{100000}\NormalTok{, }\DecValTok{10000000}\NormalTok{), }\AttributeTok{each =} \DecValTok{10}\NormalTok{)}
\NormalTok{res }\OtherTok{\textless{}{-}} \FunctionTok{performParallel}\NormalTok{(P, r.seq, }\AttributeTok{fun =}\NormalTok{ rnmean, }
                \AttributeTok{seed =}\NormalTok{ seed)}
\FunctionTok{tail}\NormalTok{(}\FunctionTok{unlist}\NormalTok{(res))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  0.0020074546  0.0001398813 -0.0028261112  0.0277917239  0.0001672218
## [6] -0.0024037920
\end{verbatim}

\textbf{Remarque :} cette fonction permet également de définir ou exporter des objets/librairies vers les différents coeurs en utilisant les options \textbf{initexpr} et \textbf{export}. En reprenant l'exemple précédent avec la fonction \emph{myfun\_pareto()} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myfun\_pareto }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(r) \{}
  \FunctionTok{mean}\NormalTok{(}\FunctionTok{rpareto}\NormalTok{(r, }\AttributeTok{scale =}\NormalTok{ scale, }\AttributeTok{shape =}\NormalTok{ shape))}
\NormalTok{\}}

\NormalTok{seed }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{scale }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{shape }\OtherTok{\textless{}{-}} \DecValTok{10}
\NormalTok{r\_values }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{100000}\NormalTok{, }\DecValTok{10000000}\NormalTok{), }\AttributeTok{each =} \DecValTok{10}\NormalTok{)}

\NormalTok{res }\OtherTok{\textless{}{-}} \FunctionTok{performParallel}\NormalTok{(P, r.seq, }\AttributeTok{fun =}\NormalTok{ myfun\_pareto, }
                \AttributeTok{seed =}\NormalTok{ seed,}
                \AttributeTok{initexpr =} \FunctionTok{require}\NormalTok{(}\StringTok{"VGAM"}\NormalTok{),}
                \AttributeTok{export =} \FunctionTok{c}\NormalTok{(}\StringTok{"scale"}\NormalTok{, }\StringTok{"shape"}\NormalTok{))}
\FunctionTok{tail}\NormalTok{(}\FunctionTok{unlist}\NormalTok{(res))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.111299 1.111008 1.110563 1.110589 1.111495 1.111505
\end{verbatim}

\hypertarget{visualisation-de-donnuxe9es}{%
\chapter{Visualisation de données}\label{visualisation-de-donnuxe9es}}

\textbf{Packages à installer}

Depuis le CRAN :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"devtools"}\NormalTok{,      }\CommentTok{\# devtools}
                   \StringTok{"dplyr"}\NormalTok{,         }\CommentTok{\# piping}
                   \StringTok{"gapminder"}\NormalTok{,     }\CommentTok{\# données gapminder}
                   \StringTok{"ggcorrplot"}\NormalTok{,    }\CommentTok{\# graphiques corrélation}
                   \StringTok{"ggridges"}\NormalTok{,      }\CommentTok{\# données ggridges}
                   \StringTok{"ggplot2"}\NormalTok{,       }\CommentTok{\# graphiques ggplot2}
                   \StringTok{"ggpol"}\NormalTok{,         }\CommentTok{\# jitter et boxplot}
                   \StringTok{"kableExtra"}     \CommentTok{\# tableaux customisés }
                   \StringTok{"RColorBrewer"}\NormalTok{,  }\CommentTok{\# couleurs }
                   \StringTok{"stargazer"}\NormalTok{,     }\CommentTok{\# tableaux }
                   \StringTok{"survival"}\NormalTok{,      }\CommentTok{\# modèle de survie}
                   \StringTok{"survminer"}\NormalTok{,     }\CommentTok{\# plot de survie}
                   \StringTok{"plotly"}\NormalTok{,        }\CommentTok{\# graphiques interractifs }
                   \StringTok{"vcd"}\NormalTok{,           }\CommentTok{\# mosaic plot}
                   \StringTok{"visreg"}\NormalTok{),        }\CommentTok{\# effets conditionnels des modèles}
                 \AttributeTok{dependencies =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{fonctions-graphiques-de-base-vs-ggplot2}{%
\section{\texorpdfstring{Fonctions graphiques de base VS \textbf{ggplot2}}{Fonctions graphiques de base VS ggplot2}}\label{fonctions-graphiques-de-base-vs-ggplot2}}

Il est possible de réaliser des graphiques statistiques sous \textbf{R} de multiples façons. Même si de nombreuses fonctions provenant de différents packages font la même chose, deux stratégies semblent se dégager pour réaliser des graphiques statistiques :

\begin{itemize}
\item
  utiliser les fonctions de base \emph{plot()}, \emph{hist()}, \emph{barplot()}, \emph{boxplot()}, etc. conjointement avec les fonctions de bas-niveau \emph{lines()}, \emph{text()}, \emph{legend()} pour ``ornementer'\,' le graphique et la fonction \emph{par()} pour modifier les paramètres graphiques (marges, taille de la fenêtre graphique, taille des légendes, etc.).
\item
  utiliser la philosophie du package \textbf{ggplot2} proposée par H. Wickham.
\end{itemize}

En général, les utilisateurs décident d'adopter l'une ou l'autre façon de faire, rarement les deux. L'idée de cette section est d'essayer de faire une revue des avantages de l'un et de l'autre et si possible déterminer à quel moment il est intéressant d'utiliser l'un plutôt que l'autre.

La stratégie a été la suivante : une grande majorité des utilisateurs de \textbf{ggplot2} choisissent d'utiliser ce package parce que celui-ci leur permet de réaliser des graphiques élégants en modifiant le moins possible les paramétrages par défaut. On va donc partir de graphiques obtenus avec \textbf{ggplot2}, supposés ``élégants'' et essayer d'obtenir des graphiques équivalents en utilisant la syntaxe de base.

Cette section est fortement inspirée de cette page :

\begin{itemize}
\tightlist
\item
  \url{https://flowingdata.com/2016/03/22/comparing-ggplot2-and-r-base-graphics/}
\end{itemize}

Pour une introduction aux graphiques de base et au package \textbf{ggplot2} :

\begin{itemize}
\tightlist
\item
  \url{http://www.thibault.laurent.free.fr/cours/R_intro/chapitre_4.html}
\end{itemize}

\hypertarget{graphiques-standards}{%
\subsection{Graphiques standards}\label{graphiques-standards}}

Par graphique standard, on entend les graphiques de type diagrame en barre, histogramme, nuage de points, boîtes à moustaches parallèles, etc. Dans le contexte où on compare les fonctions graphiques de base à celles du package \textbf{ggplot2}, les graphiques standards seront opposés à des graphiques de types ``conditionnels''. Les graphiques conditionnels correspondent à des graphiques standards qu'on va réaliser conditionnellement à une variable souvent qualitative.

\hypertarget{diagramme-en-barre}{%
\subsubsection{Diagramme en barre}\label{diagramme-en-barre}}

On va commencer par un diagramme en barre. On va utiliser les données \textbf{diamonds} qui sont incluses dans le package \textbf{ggplot2} et qui donnent des informations sur la vente de plus de 50000 diamants. Parmi les variables observées, le prix, le carat, la qualité de la coupe, la couleur, etc.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\FunctionTok{data}\NormalTok{(}\StringTok{"diamonds"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

On rappelle qu'avec \textbf{ggplot2}, les commandes s'enchaînent avec l'opérateur \textbf{+}. La première opération consiste à spécifier le jeu de données sur lequel on travaille (fonction \emph{ggplot()}). Ensuite, on spécifie le nom de la variable qui nous intéresse (avec la fonction \emph{aes()}). Une des spécificités de l'univers \textbf{tidyverse} est qu'une fois le nom du \textbf{data.frame} spécifié, il suffit d'appeler directement les variables par leurs noms, sans préciser à quelle \textbf{data.frame} elles appartiennent.

Enfin, on donne la fonction correspondant au graphique que l'on souhaite représenter. Pour un diagramme en barre, cela se fait avec la fonction \emph{geom\_bar()}. Si on souhaite utiliser des couleurs différentes par barre, une façon de le faire sans avoir à spécifier aucun nom de couleur, consiste à ajouter dans la fonctions \emph{aes()} l'option \textbf{fill=} suivi du nom d'une variable qualitative que l'on souhaite représenter. Il peut s'agir de la même variable pour laquelle on souhaite tracer des barres, mais il peut aussi s'agir d'une autre variable (dans ce cas, chaque barre sera découpée par étages selon les modalités de la seconde variable).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(diamonds) }\SpecialCharTok{+}
  \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ cut) }\SpecialCharTok{+}
  \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"count"}\NormalTok{) }\SpecialCharTok{+} 
  \FunctionTok{xlab}\NormalTok{(}\StringTok{"Degré de qualité"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Effectifs"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ggtitle}\NormalTok{(}\StringTok{"Effectifs des diamants par degré de qualité"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-362-1.pdf}

Pour représenter un diagramme en barres avec les graphiques de base, on a besoin de construire une table de contingences associée à une variable qualitative.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab\_cut }\OtherTok{\textless{}{-}} \FunctionTok{table}\NormalTok{(diamonds}\SpecialCharTok{$}\NormalTok{cut)}
\end{Highlighting}
\end{Shaded}

Une des caractéristiques de \textbf{ggplot2} est de représenter des lignes verticales et horizontales pour aider à la lecture du graphique. Pour faire cela avec les graphiques de base, on peut utiliser la fonction \emph{grid()} qui précise le nombre de barres horizontales et verticales à représenter ou bien utiliser la fonction \emph{abline()} qui donne les coordonnées où tracer les droites. Pour représenter la graduation de l'axe des ordonnées horizontalement, on utilise l'option \textbf{las=1} dans les paramatrès généraux de la fonction \emph{par()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(}\AttributeTok{las =} \DecValTok{1}\NormalTok{)}
\FunctionTok{barplot}\NormalTok{(tab\_cut,}
        \AttributeTok{col =} \StringTok{"\#AFC0CB"}\NormalTok{,}
        \AttributeTok{border =} \ConstantTok{FALSE}\NormalTok{,}
        \AttributeTok{main =} \StringTok{"Effectifs des diamants par degré de qualité"}\NormalTok{,}
        \AttributeTok{xlab =} \StringTok{"Degré de qualité"}\NormalTok{,}
        \AttributeTok{ylab =} \StringTok{"Effectifs"}\NormalTok{,}
        \AttributeTok{cex.axis =} \FloatTok{0.8}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{20000}\NormalTok{, }\AttributeTok{by =} \DecValTok{2500}\NormalTok{), }\AttributeTok{col =} \StringTok{"lightgray"}\NormalTok{, }\AttributeTok{lty =} \StringTok{"dotted"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-364-1.pdf}

Pour ce type de graphique, il n'y a pas de gros écarts en termes de nombre de lignes de codes entre les deux styles de graphique.

\textbf{Remarque :} en revanche, pour reproduire exactement le même graphique (fond en gris, marges, etc.) en utilisant une syntaxe de base, cela demanderait un peu plus de travail. On le fait ici pour le \textbf{barplot} pour que l'utilisateur se rende compte des lignes de codes qui sont implicitement exécutées dans l'appel de fonctions de type \textbf{ggplot2} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{mar =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\FloatTok{3.2}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{0.5}\NormalTok{), }\CommentTok{\# marge}
          \AttributeTok{mgp =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\DecValTok{0}\NormalTok{),        }\CommentTok{\# emplacement annot/étiquettes/légendes}
          \AttributeTok{oma =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{),       }\CommentTok{\# emplacement pour le titre}
          \AttributeTok{cex.axis =} \FloatTok{0.75}\NormalTok{, }\CommentTok{\# tailles des anotations}
          \AttributeTok{cex.lab =} \FloatTok{0.85}\NormalTok{, }\CommentTok{\# tailles des légendes}
          \AttributeTok{pch =} \DecValTok{16}\NormalTok{,       }\CommentTok{\# type de point utilisé}
          \AttributeTok{las =} \DecValTok{1}\NormalTok{,      }\CommentTok{\# affiche les étiquettes |\_ aux axes }
          \AttributeTok{bty =} \StringTok{"n"}    \CommentTok{\# pas de box}
\NormalTok{          ) }
\FunctionTok{plot.new}\NormalTok{()}
\FunctionTok{plot.window}\NormalTok{(}\AttributeTok{xlim =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{, }\FloatTok{5.5}\NormalTok{), }\AttributeTok{ylim =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FunctionTok{max}\NormalTok{(tab\_cut)))}
  
\FunctionTok{rect}\NormalTok{(}\FunctionTok{par}\NormalTok{()}\SpecialCharTok{$}\NormalTok{usr[}\DecValTok{1}\NormalTok{], }\FunctionTok{par}\NormalTok{()}\SpecialCharTok{$}\NormalTok{usr[}\DecValTok{3}\NormalTok{], }
     \FunctionTok{par}\NormalTok{()}\SpecialCharTok{$}\NormalTok{usr[}\DecValTok{2}\NormalTok{], }\FunctionTok{par}\NormalTok{()}\SpecialCharTok{$}\NormalTok{usr[}\DecValTok{4}\NormalTok{], }
     \AttributeTok{col =} \StringTok{"grey89"}\NormalTok{, }\AttributeTok{border =} \StringTok{"white"}\NormalTok{)}

\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{25000}\NormalTok{, }\DecValTok{2500}\NormalTok{), }\AttributeTok{col =} \StringTok{"white"}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{v =} \FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{col =} \StringTok{"white"}\NormalTok{)}

\NormalTok{barre.x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FloatTok{0.55}\NormalTok{, }\FloatTok{1.45}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ (k }\ControlFlowTok{in} \DecValTok{0}\SpecialCharTok{:}\DecValTok{4}\NormalTok{)}
  \FunctionTok{rect}\NormalTok{(barre.x[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ k, }\DecValTok{0}\NormalTok{, barre.x[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ k, tab\_cut[k }\SpecialCharTok{+} \DecValTok{1}\NormalTok{], }
       \AttributeTok{col =} \StringTok{"grey19"}\NormalTok{, }\AttributeTok{border =} \StringTok{"grey19"}\NormalTok{)}

\FunctionTok{axis}\NormalTok{(}\AttributeTok{side =} \DecValTok{1}\NormalTok{,}
     \AttributeTok{at =} \FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{),  }\CommentTok{\# ou mettre les graduations}
     \AttributeTok{labels =} \FunctionTok{c}\NormalTok{(}\StringTok{"Fair"}\NormalTok{, }\StringTok{"Good"}\NormalTok{, }\StringTok{"Very Good"}\NormalTok{, }\StringTok{"Premium"}\NormalTok{, }\StringTok{"Ideal"}\NormalTok{), }\CommentTok{\# quelles étiquettes}
     \AttributeTok{lwd =} \DecValTok{0}\NormalTok{,  }\CommentTok{\# supprime la ligne de l\textquotesingle{}axe des abscisses}
     \AttributeTok{lwd.ticks =} \FloatTok{0.25}\NormalTok{)  }\CommentTok{\# donne l\textquotesingle{}épaisseur des graduations}
\FunctionTok{mtext}\NormalTok{(}\StringTok{"Degré de qualité"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\AttributeTok{line =} \FloatTok{1.5}\NormalTok{)}
\FunctionTok{axis}\NormalTok{(}\AttributeTok{side =} \DecValTok{2}\NormalTok{,}
     \AttributeTok{at =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{25000}\NormalTok{, }\DecValTok{5000}\NormalTok{),}
     \AttributeTok{labels =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{25000}\NormalTok{, }\DecValTok{5000}\NormalTok{),}
     \AttributeTok{lwd =} \DecValTok{0}\NormalTok{, }
     \AttributeTok{lwd.ticks =} \FloatTok{0.25}\NormalTok{,}
     \AttributeTok{cex =} \FloatTok{0.8}\NormalTok{)  }
\FunctionTok{mtext}\NormalTok{(}\StringTok{"Effectifs"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\AttributeTok{line =} \FloatTok{2.2}\NormalTok{, }\AttributeTok{las =} \DecValTok{3}\NormalTok{)}
\FunctionTok{mtext}\NormalTok{(}\StringTok{"Effectifs des diamants par degré de qualité"}\NormalTok{, }\DecValTok{3}\NormalTok{, }
      \AttributeTok{line =} \SpecialCharTok{{-}}\FloatTok{0.25}\NormalTok{, }\AttributeTok{las =} \DecValTok{1}\NormalTok{, }\AttributeTok{outer =}\NormalTok{ T, }\AttributeTok{adj =} \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-365-1.pdf}

\hypertarget{suxe9ries-temporelles-1}{%
\subsubsection{Séries temporelles}\label{suxe9ries-temporelles-1}}

On va considérer une série temporelle mensuelle, supposons qu'il s'agit d'un indice boursier aggrégé mensuellement :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{serie }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FloatTok{161.31}\NormalTok{, }\FloatTok{154.00}\NormalTok{, }\FloatTok{161.94}\NormalTok{, }\FloatTok{160.23}\NormalTok{, }\FloatTok{173.20}\NormalTok{, }\FloatTok{170.21}\NormalTok{, }\FloatTok{163.97}\NormalTok{, }\FloatTok{161.70}\NormalTok{, }
           \FloatTok{144.91}\NormalTok{, }\FloatTok{145.31}\NormalTok{, }\FloatTok{140.50}\NormalTok{, }\FloatTok{139.58}\NormalTok{, }\FloatTok{135.60}\NormalTok{, }\FloatTok{124.40}\NormalTok{, }\FloatTok{132.24}\NormalTok{, }\FloatTok{150.51}\NormalTok{, }
           \FloatTok{146.56}\NormalTok{, }\FloatTok{153.00}\NormalTok{, }\FloatTok{151.78}\NormalTok{, }\FloatTok{160.65}\NormalTok{, }\FloatTok{158.32}\NormalTok{, }\FloatTok{158.06}\NormalTok{, }\FloatTok{153.50}\NormalTok{, }\FloatTok{161.95}\NormalTok{, }
           \FloatTok{167.00}\NormalTok{, }\FloatTok{175.00}\NormalTok{, }\FloatTok{180.48}\NormalTok{, }\FloatTok{173.82}\NormalTok{, }\FloatTok{160.05}\NormalTok{, }\FloatTok{152.80}\NormalTok{, }\FloatTok{153.58}\NormalTok{, }\FloatTok{145.00}\NormalTok{, }
           \FloatTok{142.98}\NormalTok{, }\FloatTok{145.35}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Pour associer des dates à ces valeurs, nous allons utiliser le type d'objet \textbf{Date}. On utilise ici une méthode générique de la fonction \emph{seq()} appliquée à des dates :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date\_serie }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\FunctionTok{as.Date}\NormalTok{(}\StringTok{"2015/1/1"}\NormalTok{), }\AttributeTok{by =} \StringTok{"month"}\NormalTok{, }\AttributeTok{length.out =} \DecValTok{34}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Pour représenter cette série avec \textbf{ggplot2}, il faut d'abord créer un \textbf{data.frame} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{serie\_df }\OtherTok{=} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{date\_serie =}\NormalTok{ date\_serie, }\AttributeTok{serie =}\NormalTok{ serie)}
\end{Highlighting}
\end{Shaded}

Ensuite, il suffit d'utiliser de préciser dans la fonction \emph{aes()} que la variable \textbf{date\_serie} est associée à \textbf{x} et la variable \textbf{serie} à \textbf{y}. C'est la fonction \emph{geom\_line()} qui indique qu'on va relier les points par des lignes brisées :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(serie\_df) }\SpecialCharTok{+}             
  \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ date\_serie, }\AttributeTok{y =}\NormalTok{ serie) }\SpecialCharTok{+} 
  \FunctionTok{geom\_line}\NormalTok{(}\AttributeTok{linetype =} \DecValTok{2}\NormalTok{, }\AttributeTok{colour =} \StringTok{"blue"}\NormalTok{)  }\SpecialCharTok{+} 
  \FunctionTok{xlab}\NormalTok{(}\StringTok{"Mois observés"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Indice boursier"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ggtitle}\NormalTok{(}\StringTok{"Evolution de l\textquotesingle{}indice boursier"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-369-1.pdf}

En utilisant les graphiques de base, cela se fait assez bien car le format \textbf{Date} est également reconnu par la fonction générique \emph{plot()}. On obtient donc un résultat similaire avec seulement quelques lignes de code supplémentaire.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(}\AttributeTok{las =} \DecValTok{1}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(serie }\SpecialCharTok{\textasciitilde{}}\NormalTok{ date\_serie, }\AttributeTok{data =}\NormalTok{ serie\_df, }
     \AttributeTok{type =} \StringTok{"l"}\NormalTok{, }
     \AttributeTok{col =} \StringTok{"royalblue"}\NormalTok{, }
     \AttributeTok{lty =} \DecValTok{2}\NormalTok{,}
     \AttributeTok{main =} \StringTok{"Evolution de l\textquotesingle{}indice boursier"}\NormalTok{,}
     \AttributeTok{xlab =} \StringTok{"Mois observés"}\NormalTok{,}
     \AttributeTok{ylab =} \StringTok{"Indice boursier"}\NormalTok{,}
     \AttributeTok{cex.axis =} \FloatTok{0.8}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \FunctionTok{seq}\NormalTok{(}\DecValTok{130}\NormalTok{, }\DecValTok{180}\NormalTok{, }\AttributeTok{by =} \DecValTok{10}\NormalTok{), }
       \AttributeTok{v =}\NormalTok{ date\_serie[}\FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{32}\NormalTok{, }\DecValTok{6}\NormalTok{)],}
       \AttributeTok{col =} \StringTok{"lightgray"}\NormalTok{, }\AttributeTok{lty =} \StringTok{"dotted"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-370-1.pdf}

\hypertarget{histogramme-et-fonction-de-densituxe9}{%
\subsubsection{Histogramme et fonction de densité}\label{histogramme-et-fonction-de-densituxe9}}

Pour représenter un hstogramme et une densité avec \textbf{ggplot2}, cela se fait avec les fonctions \emph{geom\_histogram()} et \emph{geom\_density()}. L'option \textbf{bins=} dans la fonction \emph{geom\_histogram()} permet de donner le nombre de barres. L'option \textbf{adjust =} permet d'ajuster le degré de lissage de la foncion non paramétrique de la densité. Pour ajouter la fonction paramétrique d'une loi gaussienne, on utilise la fonction \emph{stat\_function()} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(diamonds) }\SpecialCharTok{+}
  \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ price) }\SpecialCharTok{+}
    \FunctionTok{geom\_histogram}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{y =}\NormalTok{ ..density..), }\AttributeTok{fill =} \StringTok{"lightblue"}\NormalTok{, }\AttributeTok{colour =} \StringTok{"black"}\NormalTok{, }
                   \AttributeTok{bins =} \DecValTok{30}\NormalTok{) }\SpecialCharTok{+} 
    \FunctionTok{geom\_density}\NormalTok{(}\AttributeTok{colour =} \StringTok{"red"}\NormalTok{, }
                 \AttributeTok{adjust =} \DecValTok{2}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ dnorm, }
    \AttributeTok{args =} \FunctionTok{c}\NormalTok{(}
      \AttributeTok{mean =} \FunctionTok{mean}\NormalTok{(diamonds}\SpecialCharTok{$}\NormalTok{price), }
      \AttributeTok{sd =} \FunctionTok{sd}\NormalTok{(diamonds}\SpecialCharTok{$}\NormalTok{price))) }\SpecialCharTok{+} 
  \FunctionTok{xlab}\NormalTok{(}\StringTok{"Prix observé"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ggtitle}\NormalTok{(}\StringTok{"Distribution de la variable prix"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-371-1.pdf}

En utilisant les fonctions de base, on peut reproduire quelque chose d'équivalent sans que cela soit trop coûteux. A noter toutefois que l'option \textbf{nclass=} de la fonction \emph{hist()} ne donnera pas nécessairement exactement le nombre de classes souhaité, car un algorithme est utilisé pour déterminer ce nombre.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(}\AttributeTok{las =} \DecValTok{1}\NormalTok{, }\AttributeTok{cex.axis =} \FloatTok{0.8}\NormalTok{, }\AttributeTok{cex.lab =} \FloatTok{0.8}\NormalTok{)}
\FunctionTok{hist}\NormalTok{(diamonds}\SpecialCharTok{$}\NormalTok{price, }\AttributeTok{freq =}\NormalTok{ F, }\AttributeTok{col =} \StringTok{"lightblue"}\NormalTok{, }\AttributeTok{nclass =} \DecValTok{30}\NormalTok{, }
     \AttributeTok{xlab =} \StringTok{"Prix du diamant"}\NormalTok{, }\AttributeTok{main =} \StringTok{"Distribution de la variable prix"}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(}\FunctionTok{density}\NormalTok{(diamonds}\SpecialCharTok{$}\NormalTok{price), }\AttributeTok{col =} \StringTok{"red"}\NormalTok{)}
\NormalTok{x\_seq }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1000}\NormalTok{, }\DecValTok{20000}\NormalTok{, }\AttributeTok{by =} \DecValTok{100}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(x\_seq, }\FunctionTok{dnorm}\NormalTok{(x\_seq, }\FunctionTok{mean}\NormalTok{(diamonds}\SpecialCharTok{$}\NormalTok{price), }\FunctionTok{sd}\NormalTok{(diamonds}\SpecialCharTok{$}\NormalTok{price)))}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.0005}\NormalTok{, }\AttributeTok{by =} \FloatTok{0.00005}\NormalTok{), }
       \AttributeTok{v =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{20000}\NormalTok{, }\AttributeTok{by =} \DecValTok{2500}\NormalTok{), }
       \AttributeTok{col =} \StringTok{"lightgray"}\NormalTok{, }\AttributeTok{lty =} \StringTok{"dotted"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-372-1.pdf}

\hypertarget{nuage-de-points}{%
\subsubsection{Nuage de points}\label{nuage-de-points}}

Afin d'avoir des représentations graphiques moins lourdes, on va se restreindre à un sous-échantillon de taille 5000. En effet, pour certains graphiques, lorsque le nombre d'observations est important, sa lecture devient difficile.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{) }\CommentTok{\# on fixe une graine aléatoire }
\NormalTok{diam\_ech }\OtherTok{\textless{}{-}}\NormalTok{ diamonds[}\FunctionTok{sample}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(diamonds), }\DecValTok{5000}\NormalTok{, }\AttributeTok{replace =}\NormalTok{ F), ]  }
\end{Highlighting}
\end{Shaded}

Pour représenter un nuage de points et une droite de régression non paramétrique, cela se fait dans \textbf{ggplot2} avec les fonctions \emph{geom\_point()} et \emph{geom\_smooth()}. Cette dernière permet de tracer une droite de régression linéaire (option \textbf{method=``lm''}) ou alors une droite de régression non paramétrique (option \textbf{method=``loess''}), basée sur les modèles GAM (Hastie et Tibshirani, 1986). Un intervalle de confiance est également représenté par défaut pour cette dernière méthode.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(diam\_ech) }\SpecialCharTok{+}                \CommentTok{\# on va chercher des variables dans diam\_sample}
  \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ carat, }\AttributeTok{y =}\NormalTok{ price) }\SpecialCharTok{+}     \CommentTok{\# on s\textquotesingle{}intéresse aux 2 variables carat et price}
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+}                  \CommentTok{\# on représente un nuage de points}
  \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{"loess"}\NormalTok{) }\SpecialCharTok{+} \CommentTok{\# on ajoute une droite de rég. non paramétrique}
  \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{"lm"}\NormalTok{,      }\CommentTok{\# on ajoute une droite de régression linéaire}
              \AttributeTok{col =} \StringTok{"red"}\NormalTok{) }\SpecialCharTok{+} 
  \FunctionTok{xlab}\NormalTok{(}\StringTok{"Carat"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"Prix observé"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{ggtitle}\NormalTok{(}\StringTok{"Lien entre deux variables quantis"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `geom_smooth()` using formula 'y ~ x'
## `geom_smooth()` using formula 'y ~ x'
\end{verbatim}

\includegraphics{_main_files/figure-latex/unnamed-chunk-374-1.pdf}

En utilisant les fonctions de base, il faut passer par les fonctions \emph{lm()} pour calculer les coefficients de la droite de régression linéaire et la fonction \emph{loess()} permet d'obtenir une droite de régression non paramétrique basée quant à elle sur la méthode des polynômes locaux. Pour représenter une droite de régression non paramétrique basée sur la méthode GAM, le lecteur pourra se référer au package \textbf{gam}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(}\AttributeTok{las =} \DecValTok{1}\NormalTok{, }\AttributeTok{cex.axis =} \FloatTok{0.8}\NormalTok{, }\AttributeTok{cex.lab =} \FloatTok{0.8}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(price }\SpecialCharTok{\textasciitilde{}}\NormalTok{ carat, }\AttributeTok{data =}\NormalTok{ diam\_ech, }\AttributeTok{pch =} \DecValTok{16}\NormalTok{, }\AttributeTok{cex =} \FloatTok{0.7}\NormalTok{, }
     \AttributeTok{xlab =} \StringTok{"carat"}\NormalTok{, }\AttributeTok{ylab=} \StringTok{"prix"}\NormalTok{, }\AttributeTok{main =} \StringTok{"Lien entre deux variables quantis"}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\FunctionTok{lm}\NormalTok{(price }\SpecialCharTok{\textasciitilde{}}\NormalTok{ carat, }\AttributeTok{data =}\NormalTok{ diam\_ech), }\AttributeTok{col =} \StringTok{"red"}\NormalTok{, }\AttributeTok{lwd =} \DecValTok{3}\NormalTok{)}
\CommentTok{\# values to predict}
\NormalTok{x\_carat }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{4.5}\NormalTok{, }\FloatTok{0.01}\NormalTok{)}
\FunctionTok{lines}\NormalTok{(x\_carat,  }
      \FunctionTok{predict}\NormalTok{(}\FunctionTok{loess}\NormalTok{(price }\SpecialCharTok{\textasciitilde{}}\NormalTok{ carat, }\AttributeTok{data =}\NormalTok{ diam\_ech), }
              \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{carat =}\NormalTok{ x\_carat)), }
      \AttributeTok{col =} \StringTok{"blue"}\NormalTok{, }\AttributeTok{lwd =} \DecValTok{3}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{20000}\NormalTok{, }\AttributeTok{by =} \DecValTok{5000}\NormalTok{), }
       \AttributeTok{v =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{, }\AttributeTok{by =} \FloatTok{0.5}\NormalTok{), }
       \AttributeTok{col =} \StringTok{"lightgray"}\NormalTok{, }\AttributeTok{lty =} \StringTok{"dotted"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-375-1.pdf}

\hypertarget{bouxeetes-uxe0-moustaches-paralluxe8les}{%
\subsubsection{Boîtes à moustaches parallèles}\label{bouxeetes-uxe0-moustaches-paralluxe8les}}

Avec \textbf{ggplot2}, les boîtes à moustaches parallèles se font à partir de la fonction \emph{geom\_boxplot()} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(diam\_ech) }\SpecialCharTok{+}              
  \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ color, }\AttributeTok{y =}\NormalTok{ price) }\SpecialCharTok{+}  
  \FunctionTok{geom\_boxplot}\NormalTok{() }
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-376-1.pdf}

Pour obtenir un graphique similaire avec les fonctions de base, on peut utiliser la fonction \emph{boxplot()} :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(}\AttributeTok{las =} \DecValTok{1}\NormalTok{, }\AttributeTok{cex.axis =} \FloatTok{0.8}\NormalTok{, }\AttributeTok{cex.lab =} \FloatTok{0.8}\NormalTok{)}
\FunctionTok{boxplot}\NormalTok{(price }\SpecialCharTok{\textasciitilde{}}\NormalTok{ color, }\AttributeTok{data =}\NormalTok{ diam\_ech, }\AttributeTok{pch =} \DecValTok{16}\NormalTok{, }\AttributeTok{cex =} \FloatTok{0.7}\NormalTok{, }
     \AttributeTok{xlab =} \StringTok{"carat"}\NormalTok{, }\AttributeTok{ylab=} \StringTok{"prix"}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{20000}\NormalTok{, }\AttributeTok{by =} \DecValTok{2500}\NormalTok{), }
       \AttributeTok{v =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{, }\AttributeTok{by =} \DecValTok{1}\NormalTok{), }
       \AttributeTok{col =} \StringTok{"lightgray"}\NormalTok{, }\AttributeTok{lty =} \StringTok{"dotted"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-377-1.pdf}

\textbf{Conclusion :} pour des graphiques ``standards'', on constate donc que le match ``fonctions de base'' VS ``fonctions \textbf{ggplot2}'' n'a pas vraiment de gagnants. Par ailleurs, ici nous sommes restés sur des graphiques simples avec un minimum d'onrnementations. Le package \textbf{ggplot2} repose sur une représentations de données de type \textbf{data.frame}; du coup, pour faire certains ajouts tels que des points particuliers, des lignes brisées ou des étiquettes, cela peut s'avérer plus compliqué que d'utiliser simplement les fonctions graphiques de base. Malheureusement, il n'est pas possible de combiner les fonctions graphiques de base avec les fonctions du package \textbf{ggplot2}.

\hypertarget{graphiques-conditionnels}{%
\subsection{Graphiques conditionnels}\label{graphiques-conditionnels}}

Un avantage du package \textbf{ggplot2} sur les fonctions graphiques de base repose sur la très bonne gestion des graphiques conditionnels. Les graphiques conditionnels correspondent à des graphiques standards qu'on va réaliser conditionnellement à une variable souvent qualitative.

Il y a deux façons de faire un graphique conditionnel :

\begin{itemize}
\item
  on va afficher dans un même graphique une information relative aux modalités d'une variable qualitative (ex : dans un nuage de points, on va représenter une droite de régression associée à chacune des modalités d'une variable qualitative).
\item
  on va faire autant de graphiques qu'il existe de modalités d'une variable qualitative (ex : on va faire un histogramme d'une variable quantitative pour chaque modalité d'une variable qualitative).
\end{itemize}

\includegraphics{_main_files/figure-latex/unnamed-chunk-378-1.pdf}

\hypertarget{utilisation-des-options-fill-et-colour}{%
\subsubsection{\texorpdfstring{Utilisation des options \textbf{fill=} et \textbf{colour=}}{Utilisation des options fill= et colour=}}\label{utilisation-des-options-fill-et-colour}}

L'utilisation des options \textbf{fill=} et \textbf{colour=} à l'intérieur de la fonction \emph{aes()} ou des fonctions de type \emph{geom\_XXX()}, vont permettre de réaliser le premier type de graphique.

\hypertarget{fonctions-de-densituxe9s}{%
\paragraph{Fonctions de densités}\label{fonctions-de-densituxe9s}}

On souhaite savoir si la distribution de la \textbf{price} est la même selon les modalités prises par la variable qualitative \textbf{cut}. Pour ce faire, on va ajouter l'option \textbf{fill=} dans la fonction \emph{aes()} suivie du nom de la variable qualitative. L'option \textbf{fill=} permet de remplir chaque courbe de densité par une couleur prédifinie dans \textbf{ggplot2}. Si on avait utilisé l'option \textbf{colour=}, on aurait obtenu uniquement des traits de couleurs différentes. L'option \textbf{alpha=} permet quant à elle de définir le degré de transparence des couleurs.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(diam\_ech) }\SpecialCharTok{+} 
  \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ price, }\AttributeTok{fill =}\NormalTok{ cut) }\SpecialCharTok{+} 
  \FunctionTok{geom\_density}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-379-1.pdf}

Pour réaliser un tel graphique en utilisant les fonctions de base, cela nécessite de réaliser les étapes suivantes :

\begin{itemize}
\item
  découper la variable quantitative en fonction des modalités, ceci pouvant se faire avec la fonction \emph{split()},
\item
  appliquer la fonction \emph{density()} sur chaque sous-échantillon,
\item
  ouvrir une fenêtre graphique en définissant correctement les marges,
\item
  représenter une courbe de densité par modalité en utilisant une couleur pour chaque courbe à définir (pour obtenir les mêmes couleurs que celles obtenues proposées dans \textbf{ggplot2}, on pourra voir ce lien : \url{https://stackoverflow.com/questions/8197559/emulate-ggplot2-default-color-palette}).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# on splite la variable price en fonction de carat }
\NormalTok{list\_price }\OtherTok{\textless{}{-}} \FunctionTok{split}\NormalTok{(diam\_ech}\SpecialCharTok{$}\NormalTok{price, diam\_ech}\SpecialCharTok{$}\NormalTok{cut)}
\CommentTok{\# on applique la fonction density à chaque sous{-}groupe}
\NormalTok{list\_density }\OtherTok{\textless{}{-}} \FunctionTok{lapply}\NormalTok{(list\_price, density)}
\CommentTok{\# on ouvre la fenêtre graphique avec les paramètres optimaux}
\FunctionTok{par}\NormalTok{(}\AttributeTok{las =} \DecValTok{1}\NormalTok{, }\AttributeTok{cex.axis =} \FloatTok{0.8}\NormalTok{, }\AttributeTok{cex.lab =} \FloatTok{0.8}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{range}\NormalTok{(}\FunctionTok{unlist}\NormalTok{(}\FunctionTok{lapply}\NormalTok{(list\_density, }\ControlFlowTok{function}\NormalTok{(l) }\FunctionTok{range}\NormalTok{(l}\SpecialCharTok{$}\NormalTok{x)))),}
     \FunctionTok{range}\NormalTok{(}\FunctionTok{unlist}\NormalTok{(}\FunctionTok{lapply}\NormalTok{(list\_density, }\ControlFlowTok{function}\NormalTok{(l) }\FunctionTok{range}\NormalTok{(l}\SpecialCharTok{$}\NormalTok{y)))),}
     \AttributeTok{type =} \StringTok{"n"}\NormalTok{,}
     \AttributeTok{xlab =} \StringTok{"prix"}\NormalTok{,}
     \AttributeTok{ylab =} \StringTok{"densité"}\NormalTok{)}
\CommentTok{\# choix d\textquotesingle{}une palette de couleurs }
\NormalTok{col\_pal }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"\#F8766D"}\NormalTok{, }\StringTok{"\#A3A500"}\NormalTok{, }\StringTok{"\#00BF7D"}\NormalTok{, }\StringTok{"\#00B0F6"}\NormalTok{, }\StringTok{"\#E76BF3"}\NormalTok{)}
\CommentTok{\# application de la fonction lines() sur chaque élément de la liste}
\NormalTok{dont\_print }\OtherTok{\textless{}{-}} \FunctionTok{mapply}\NormalTok{(lines, list\_density, }
       \AttributeTok{col =}\NormalTok{ col\_pal, }\AttributeTok{lwd =} \DecValTok{2}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{4}\SpecialCharTok{*}\DecValTok{10}\SpecialCharTok{\^{}}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{4}\NormalTok{), }\AttributeTok{by =} \DecValTok{10}\SpecialCharTok{\^{}}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{4}\NormalTok{)), }
       \AttributeTok{v =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{25000}\NormalTok{, }\AttributeTok{by =} \DecValTok{5000}\NormalTok{), }
       \AttributeTok{col =} \StringTok{"lightgray"}\NormalTok{, }\AttributeTok{lty =} \StringTok{"dotted"}\NormalTok{)}
\FunctionTok{legend}\NormalTok{(}\StringTok{"topright"}\NormalTok{, }\AttributeTok{legend =} \FunctionTok{names}\NormalTok{(list\_density),}
       \AttributeTok{col =}\NormalTok{ col\_pal, }\AttributeTok{lwd =} \DecValTok{2}\NormalTok{, }\AttributeTok{cex =} \FloatTok{0.8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-380-1.pdf}

\textbf{Conclusion :} on voit donc que \textbf{ggplot2} a très bien pris en compte la représentation de graphiques conditionnellement à une variable qualitative. Un autre atout est la gestion des paramètres graphiques par défaut (de type couleur, légende, etc). C'est pour ces deux raisons que \textbf{ggplot2} rencontre un tel succès. Il est important de souligner que derrière l'utilisation de toutes ces fonctions, se cachent des tas de lignes de codes qui rendent possibles cette utilisation simplifiée.

\textbf{Remarque :} pour remplir les aires sous les courbes de densités avec les graphiques de base, on aurait pu utiliser la fonction \emph{polygon()}

\hypertarget{nuages-de-points}{%
\paragraph{Nuages de points}\label{nuages-de-points}}

L'utilisation d'une variable qualitative conditionnelle peut s'avérer très intéressante à utiliser sur un nuage de points, pour savoir notamment si le lien entre les variables quantitatives \(Y\) et \(X\) sont les mêmes en fonction d'une variable qualitative. Ici on a changé la palette de couleur en utilisant les palettes de couleurs inspirés du package \textbf{RColorBrewer} (voir la note suivante concernant les palettes de couleurs style \textbf{RColorBrewer} : \url{https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/colorPaletteCheatsheet.pdf}).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(diam\_ech) }\SpecialCharTok{+} 
  \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ carat, }\AttributeTok{y =}\NormalTok{ price) }\SpecialCharTok{+} 
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+} 
  \FunctionTok{geom\_smooth}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{colour =}\NormalTok{ cut)) }\SpecialCharTok{+} \CommentTok{\# ajoute 5 courbes selon la variable cut}
  \FunctionTok{theme\_bw}\NormalTok{() }\SpecialCharTok{+}                     \CommentTok{\# modifie la couleur de fond}
  \FunctionTok{xlab}\NormalTok{(}\StringTok{"Carat"}\NormalTok{) }\SpecialCharTok{+}                  \CommentTok{\# modifie la légende de l\textquotesingle{}axe des x}
  \FunctionTok{ylab}\NormalTok{(}\StringTok{"price (in USD)"}\NormalTok{) }\SpecialCharTok{+}         \CommentTok{\# modifie la légende de l\textquotesingle{}axe des y}
  \FunctionTok{ggtitle}\NormalTok{(}\StringTok{"Lien entre deux variables quantis"}\NormalTok{) }\SpecialCharTok{+}   \CommentTok{\# ajoute un titre}
  \FunctionTok{scale\_colour\_brewer}\NormalTok{(}\AttributeTok{name =} \StringTok{"Qualité"}\NormalTok{,   }\CommentTok{\# modifie la légende de cut}
                    \AttributeTok{labels =} \FunctionTok{c}\NormalTok{(}\StringTok{"A{-}{-}"}\NormalTok{, }\StringTok{"A{-}"}\NormalTok{, }\StringTok{"A"}\NormalTok{, }\StringTok{"A+"}\NormalTok{, }\StringTok{"A++"}\NormalTok{) , }\CommentTok{\# Etiquette}
                    \AttributeTok{palette =} \StringTok{"Greens"}\NormalTok{)   }\CommentTok{\# modifie la palette de couleurs }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = "cs")'
\end{verbatim}

\includegraphics{_main_files/figure-latex/unnamed-chunk-381-1.pdf}

Pour réaliser un graphique équivalent avec les fonctions graphiques de base, il faut procéder comme on l'a fait dans l'exemple précédent. On splite dans un premier temps le \textbf{data.frame} en fonction de la variable qualitative, on applique ensuite les fonctions \emph{predict()} et \emph{loess()} aux sous-échantillons avant de représenter les courbes les unes après les autres en utilisant les couleurs choisies.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(}\AttributeTok{las =} \DecValTok{1}\NormalTok{, }\AttributeTok{cex.axis =} \FloatTok{0.8}\NormalTok{, }\AttributeTok{cex.lab =} \FloatTok{0.8}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(price }\SpecialCharTok{\textasciitilde{}}\NormalTok{ carat, }\AttributeTok{data =}\NormalTok{ diam\_ech, }\AttributeTok{pch =} \DecValTok{16}\NormalTok{, }\AttributeTok{cex =} \FloatTok{0.7}\NormalTok{, }
     \AttributeTok{xlab =} \StringTok{"carat"}\NormalTok{, }\AttributeTok{ylab=} \StringTok{"price (in USD)"}\NormalTok{, }
     \AttributeTok{main =} \StringTok{"Lien entre deux variables quantis"}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{20000}\NormalTok{, }\AttributeTok{by =} \DecValTok{5000}\NormalTok{), }
       \AttributeTok{v =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{, }\AttributeTok{by =} \FloatTok{0.5}\NormalTok{), }
       \AttributeTok{col =} \StringTok{"lightgray"}\NormalTok{, }\AttributeTok{lty =} \StringTok{"dotted"}\NormalTok{)}
\CommentTok{\# on split le data.frame en fonction de cut }
\NormalTok{list\_df }\OtherTok{\textless{}{-}} \FunctionTok{split}\NormalTok{(diam\_ech, diam\_ech}\SpecialCharTok{$}\NormalTok{cut)}
\CommentTok{\# values to predict}
\NormalTok{x\_carat }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{4.5}\NormalTok{, }\FloatTok{0.01}\NormalTok{)}
\CommentTok{\# on applique la fonction lowess à chaque sous{-}groupe}
\NormalTok{list\_loess }\OtherTok{\textless{}{-}} \FunctionTok{lapply}\NormalTok{(list\_df, }\ControlFlowTok{function}\NormalTok{(obj) }
  \FunctionTok{predict}\NormalTok{(}\FunctionTok{loess}\NormalTok{(price }\SpecialCharTok{\textasciitilde{}}\NormalTok{ carat, }\AttributeTok{data =}\NormalTok{ obj),}
          \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{carat =}\NormalTok{ x\_carat)))}
\CommentTok{\# choix d\textquotesingle{}une palette de couleurs }
\FunctionTok{require}\NormalTok{(}\StringTok{"RColorBrewer"}\NormalTok{)}
\NormalTok{col\_pal }\OtherTok{\textless{}{-}} \FunctionTok{brewer.pal}\NormalTok{(}\FunctionTok{length}\NormalTok{(list\_price), }\StringTok{"Greens"}\NormalTok{)}
\CommentTok{\# application de la fonction lines() sur chaque élément de la liste}
\NormalTok{dont\_print }\OtherTok{\textless{}{-}} \FunctionTok{mapply}\NormalTok{(lines, }\FunctionTok{rep}\NormalTok{(}\FunctionTok{list}\NormalTok{(x\_carat), }\DecValTok{5}\NormalTok{), list\_loess, }
       \AttributeTok{col =}\NormalTok{ col\_pal, }\AttributeTok{lwd =} \DecValTok{3}\NormalTok{)}
\FunctionTok{legend}\NormalTok{(}\StringTok{"topright"}\NormalTok{, }\AttributeTok{legend =} \FunctionTok{c}\NormalTok{(}\StringTok{"A{-}{-}"}\NormalTok{, }\StringTok{"A{-}"}\NormalTok{, }\StringTok{"A"}\NormalTok{, }\StringTok{"A+"}\NormalTok{, }\StringTok{"A++"}\NormalTok{),}
       \AttributeTok{col =}\NormalTok{ col\_pal, }\AttributeTok{lwd =} \DecValTok{2}\NormalTok{, }\AttributeTok{cex =} \FloatTok{0.8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-382-1.pdf}

\hypertarget{bouxeetes-uxe0-moustaches}{%
\paragraph{Boîtes à moustaches}\label{bouxeetes-uxe0-moustaches}}

Pour réaliser des boîtes à moustache parallèles conditionnelement à une variable qualitative, cela se fait en seulement 3 lignes de codes avec \textbf{ggplot2}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(diam\_ech) }\SpecialCharTok{+}              
  \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ color, }\AttributeTok{y =}\NormalTok{ price, }\AttributeTok{fill =}\NormalTok{ cut) }\SpecialCharTok{+}  
  \FunctionTok{geom\_boxplot}\NormalTok{() }
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-383-1.pdf}

La fonction par défaut \emph{boxplot()} permet de faire quelque chose de similaire en paramétrant suffisament bien les options. Pour afficher la boîte de légendes en-dehors du cadre, on a utilisé l'option \textbf{xpd=T} et modifié le paramètre de la marge à droite.

\begin{Shaded}
\begin{Highlighting}[]
 \CommentTok{\# choix des couleurs :}
\NormalTok{col\_pal }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"\#F8766D"}\NormalTok{, }\StringTok{"\#A3A500"}\NormalTok{, }\StringTok{"\#00BF7D"}\NormalTok{, }\StringTok{"\#00B0F6"}\NormalTok{, }\StringTok{"\#E76BF3"}\NormalTok{)}
\FunctionTok{par}\NormalTok{(}\AttributeTok{las =} \DecValTok{1}\NormalTok{, }\AttributeTok{cex.axis =} \FloatTok{0.8}\NormalTok{, }\AttributeTok{cex.lab =} \FloatTok{0.8}\NormalTok{,}
    \AttributeTok{xpd =}\NormalTok{ T, }\AttributeTok{mar =} \FunctionTok{par}\NormalTok{()}\SpecialCharTok{$}\NormalTok{mar }\SpecialCharTok{+} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{))}
\FunctionTok{boxplot}\NormalTok{(price }\SpecialCharTok{\textasciitilde{}}\NormalTok{ cut }\SpecialCharTok{+}\NormalTok{ color, }\AttributeTok{data =}\NormalTok{ diam\_ech,}
        \AttributeTok{xlab =} \StringTok{"color"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{"price"}\NormalTok{,}
        \AttributeTok{at =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{7}\SpecialCharTok{:}\DecValTok{11}\NormalTok{, }\DecValTok{13}\SpecialCharTok{:}\DecValTok{17}\NormalTok{, }\DecValTok{19}\SpecialCharTok{:}\DecValTok{23}\NormalTok{, }\DecValTok{25}\SpecialCharTok{:}\DecValTok{29}\NormalTok{, }\DecValTok{31}\SpecialCharTok{:}\DecValTok{35}\NormalTok{, }\DecValTok{37}\SpecialCharTok{:}\DecValTok{41}\NormalTok{),}
        \AttributeTok{col =} \FunctionTok{rep}\NormalTok{(col\_pal, }\DecValTok{7}\NormalTok{), }
        \AttributeTok{pch =} \DecValTok{16}\NormalTok{,}
        \AttributeTok{xaxt =} \StringTok{"n"}\NormalTok{)}
\FunctionTok{axis}\NormalTok{(}\DecValTok{1}\NormalTok{, }\AttributeTok{at =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{39}\NormalTok{),}
     \AttributeTok{labels =} \FunctionTok{c}\NormalTok{(}\StringTok{"D"}\NormalTok{, }\StringTok{"E"}\NormalTok{, }\StringTok{"F"}\NormalTok{, }\StringTok{"G"}\NormalTok{, }\StringTok{"H"}\NormalTok{, }\StringTok{"I"}\NormalTok{, }\StringTok{"J"}\NormalTok{))}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{h =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{20000}\NormalTok{, }\AttributeTok{by =} \DecValTok{2500}\NormalTok{), }\AttributeTok{col =} \StringTok{"lightgray"}\NormalTok{, }\AttributeTok{lty =} \StringTok{"dotted"}\NormalTok{)}
\FunctionTok{legend}\NormalTok{(}\DecValTok{45}\NormalTok{, }\DecValTok{15000}\NormalTok{, }\AttributeTok{legend =} \FunctionTok{c}\NormalTok{(}\StringTok{"A{-}{-}"}\NormalTok{, }\StringTok{"A{-}"}\NormalTok{, }\StringTok{"A"}\NormalTok{, }\StringTok{"A+"}\NormalTok{, }\StringTok{"A++"}\NormalTok{),}
       \AttributeTok{fill =}\NormalTok{ col\_pal)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-384-1.pdf}

\hypertarget{utilisation-des-facet}{%
\subsubsection{Utilisation des facet}\label{utilisation-des-facet}}

L'utilisation des fonctions de type \emph{facet\_XXX()} dans \textbf{ggplot2} permet de créer autant de fenêtre graphiques qu'il y a de modalités dans la variable conditionnelle.

Si on reprend l'exemple précédent de la distribution conditionelle de la variable \textbf{price} en fonction de la variable \textbf{cut}, plutôt que de représenter toutes les distributions dans la même fenêtre graphique, on peut vouloir représenter chaque distribution dans une fenêtre graphique différente. Cela se fait avec les fonctions de type \emph{facet\_XXX()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(diam\_ech) }\SpecialCharTok{+}
  \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ price) }\SpecialCharTok{+} 
  \FunctionTok{geom\_density}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{ cut)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-385-1.pdf}

Réaliser le type de graphique ci-dessus avec les fonctions de base de \textbf{R} devient extrêmement compliqué : il faut d'abord découper la fenêtre en 6, puis utiliser une boucle \textbf{for} pour appeler la fonction \emph{plot()} dans chaque sous-compartiment, etc.. Avant l'arrivée du package \textbf{ggplot2}, le package \textbf{lattice} qui fait partie des packages de base, permet également de faire des graphiques conditionnels en quelques lignes de codes. Ici, nous ne présentons pas d'exemples d'utilisation de ce package, mais le lecteur pourra trouver des exemple de comparaison entre \textbf{ggplot2} et \textbf{lattice} dans ce document :

\begin{itemize}
\tightlist
\item
  \url{https://www.londonr.org/wp-content/uploads/sites/2/presentations/LondonR_-_lattice_vs_ggplot2_-_Richard_Pugh_and_Andy_Nicholls_-_20130910.pdf}
\end{itemize}

\textbf{Exercice 4.1}

\begin{itemize}
\tightlist
\item
  Trouver le code en syntaxe \textbf{ggplot} qui permette d'obtenir le grahique suivant obtenu en syntaxe de base:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{oma =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{las =} \DecValTok{1}\NormalTok{)}
\FunctionTok{boxplot}\NormalTok{(Sepal.Length }\SpecialCharTok{\textasciitilde{}}\NormalTok{ Species, }\AttributeTok{data =}\NormalTok{ iris)}
\FunctionTok{points}\NormalTok{(}\FunctionTok{as.numeric}\NormalTok{(iris}\SpecialCharTok{$}\NormalTok{Species) }\SpecialCharTok{+} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{150}\NormalTok{, }\DecValTok{0}\NormalTok{, }\FloatTok{0.1}\NormalTok{), iris}\SpecialCharTok{$}\NormalTok{Sepal.Length)}
\FunctionTok{points}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{), }\FunctionTok{tapply}\NormalTok{(iris}\SpecialCharTok{$}\NormalTok{Sepal.Length, iris}\SpecialCharTok{$}\NormalTok{Species, mean), }
 \AttributeTok{col =} \StringTok{"red"}\NormalTok{, }\AttributeTok{pch =} \DecValTok{16}\NormalTok{, }\AttributeTok{cex =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-386-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(op)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Trouver le code en syntaxe de base qui permette d'obtenir le graphique suivant obtenu avec la syntaxe \textbf{ggplot}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(}\StringTok{"diamonds"}\NormalTok{)}
\FunctionTok{ggplot}\NormalTok{(diamonds, }
       \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ carat,}
           \AttributeTok{y =}\NormalTok{ price)) }\SpecialCharTok{+} 
  \FunctionTok{geom\_point}\NormalTok{() }\SpecialCharTok{+} 
  \FunctionTok{ggtitle}\NormalTok{(}\StringTok{"My scatter plot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-387-1.pdf}

\hypertarget{pruxe9sentation-de-graphiques-originaux}{%
\section{Présentation de graphiques originaux}\label{pruxe9sentation-de-graphiques-originaux}}

On présente ici une liste de graphiques originaux, la plupart inspirée de la syntaxe \textbf{ggplot2}, mais pas uniquement.

\hypertarget{muxe9lange-bouxeete-uxe0-moustachediagramme-de-dispersion}{%
\subsection{Mélange boîte à moustache/diagramme de dispersion}\label{muxe9lange-bouxeete-uxe0-moustachediagramme-de-dispersion}}

Le graphique suivant (issu du package \textbf{ggpol}) permet de représenter une ``demi'' boîte à moustache et un diagramme de dispersion à la place de la demi boîte. Le diagramme de dispersion n'est pas représenté sur une unique droite. En effet, si plusieurs valeurs sont identiques, il n'est pas possible de les distinguer sur une droite. C'est pourquoi les données ne sont pas toutes représentées sur la même droite (elles sont \textbf{jitter} en anglais). L'intérêt de ce graphique est limité, mais il permet toutefois d'apprécier le volume de données correspondant à chaque partie de la boîte à moustache.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"ggpol"}\NormalTok{)}
\FunctionTok{ggplot}\NormalTok{(diamonds, }
       \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ cut, }
           \AttributeTok{y =}\NormalTok{ price, }
           \AttributeTok{fill =}\NormalTok{ cut)) }\SpecialCharTok{+}
  \FunctionTok{geom\_boxjitter}\NormalTok{(}\AttributeTok{color =} \StringTok{"black"}\NormalTok{,}
     \AttributeTok{jitter.color =} \StringTok{"darkgrey"}\NormalTok{,}
     \AttributeTok{errorbar.draw =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme\_minimal}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{legend.position =} \StringTok{"none"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-388-1.pdf}

\hypertarget{violin-plot}{%
\subsection{Violin plot}\label{violin-plot}}

Le but de ce graphique est de représenter sur un même graphique une boîte à moustache et un estimateur non paramétrique de la densité. L'objectif est de visualiser sur un même graphique les informations spécifiques apportées par l'un et par l'autre. Plus précisément la boîte à moustache est intéressante pour visualiser les valeurs extrêmes alors que l'estimateur non paramétrique de la densité permet d'avoir une idée de l'allure de la distribution.

L'estimation non paramétrique est représentée verticalement (alors que celle-ci est généralement représentée horizontalement); de plus, il y a un effet miroir dans le but d'harmoniser le dessin avec la boîte à moustache. Dans l'exemple ci-dessous, on a représenté le ``violin plot'' de la variable \textbf{price} en fonction des modalités de la variable \textbf{cut}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(diamonds, }
       \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ cut, }
           \AttributeTok{y =}\NormalTok{ price)) }\SpecialCharTok{+}
  \FunctionTok{geom\_violin}\NormalTok{(}\AttributeTok{fill =} 
          \StringTok{"cornflowerblue"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_boxplot}\NormalTok{(}\AttributeTok{width =}\NormalTok{ .}\DecValTok{2}\NormalTok{, }
        \AttributeTok{fill =} \StringTok{"orange"}\NormalTok{,}
        \AttributeTok{outlier.color =} \StringTok{"orange"}\NormalTok{,}
        \AttributeTok{outlier.size =} \DecValTok{2}\NormalTok{) }\SpecialCharTok{+} 
  \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{"Price dist. by cut"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-389-1.pdf}

\hypertarget{ridgeline-plots}{%
\subsection{Ridgeline plots}\label{ridgeline-plots}}

Ce graphique (issu du package \textbf{ggridges}) est particulièrement intéressant car il permet de visualiser des estimateurs non paramétriques de densité conditionnement à une variable qualitative. Contrairement à un des graphiques vue dans la section précédente, il est possible d'apprécier correctemment la forme de chaque estimateur car ceux-ci sont représentés sur une ligne différente, tout en conservant la même échelle.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(ggridges)}
\FunctionTok{ggplot}\NormalTok{(diam\_ech, }
       \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ price, }
           \AttributeTok{y =}\NormalTok{ color, }
           \AttributeTok{fill =}\NormalTok{ color)) }\SpecialCharTok{+}
  \FunctionTok{geom\_density\_ridges}\NormalTok{() }\SpecialCharTok{+} 
  \FunctionTok{theme\_ridges}\NormalTok{() }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}\StringTok{"Price by levels color"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{legend.position =} \StringTok{"none"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-390-1.pdf}

\hypertarget{barres-derreurs}{%
\subsection{Barres d'erreurs}\label{barres-derreurs}}

Le graphique suivant permet de représenter sur un graphique les barres d'erreurs correspondant aux intervalles de confiance à \(95\%\) autour des moyennes observées, en utilisant l'hypothèse de normalité. Attention, cela ne remplace pas un test statistique, mais cela permet d'apprécier visuellement si deux moyennes observées semblent significativement différentes l'une de l'autre.

Pour réaliser ce graphique, il faut d'abord mettre en forme les données à la \textbf{ggplot2}, c'est-à-dire sous forme de \textbf{data.frame}, correctement disposé (\textbf{tidy}).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(dplyr)}
\NormalTok{plotdata }\OtherTok{\textless{}{-}}\NormalTok{ diamonds }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(color, cut) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}\AttributeTok{n =} \FunctionTok{n}\NormalTok{(),}
         \AttributeTok{mean =} \FunctionTok{mean}\NormalTok{(price),}
         \AttributeTok{sd =} \FunctionTok{sd}\NormalTok{(price),}
         \AttributeTok{se =}\NormalTok{ sd }\SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(n),}
         \AttributeTok{ci =} \FunctionTok{qt}\NormalTok{(}\FloatTok{0.975}\NormalTok{, }\AttributeTok{df =}\NormalTok{ n }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{) }\SpecialCharTok{*}\NormalTok{ sd }\SpecialCharTok{/} \FunctionTok{sqrt}\NormalTok{(n))}
\end{Highlighting}
\end{Shaded}

Ensuite, on peut représenter les différentes moyennes et les barres d'erreurs.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplot}\NormalTok{(plotdata, }\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ cut,}
                     \AttributeTok{y =}\NormalTok{ mean, }
                     \AttributeTok{group =}\NormalTok{ color, }
                     \AttributeTok{color =}\NormalTok{ color)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{3}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_line}\NormalTok{(}\AttributeTok{size =} \DecValTok{1}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_errorbar}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{ymin =}\NormalTok{ mean }\SpecialCharTok{{-}}\NormalTok{ se, }
                    \AttributeTok{ymax =}\NormalTok{ mean }\SpecialCharTok{+}\NormalTok{ se), }
                \AttributeTok{width =}\NormalTok{ .}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-392-1.pdf}

\hypertarget{cleveland-dot-chart}{%
\subsection{Cleveland dot chart}\label{cleveland-dot-chart}}

Le Cleveland dot chart est un graphique qui permet de visualiser une variabe quantitative de façon brute. On représente en général en ordonnées l'identifiant d'une observation (comme une marque de voiture, un pays, etc.) et en abscisse la valeur observée. Cet outil est particulièrement intéressant lorsque les observations sont triées. Cela permet d'apprécier un ordre de grandeur des différences observées.

Dans l'exemple ci-dessous, les données proviennent du package \textbf{gapminder} sur les espérances de vie observées dans les pays d'Asie en 2007.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(gapminder, }\AttributeTok{package =} \StringTok{"gapminder"}\NormalTok{)}

\FunctionTok{library}\NormalTok{(dplyr)}
\NormalTok{plotdata }\OtherTok{\textless{}{-}}\NormalTok{ gapminder }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(continent }\SpecialCharTok{==} \StringTok{"Asia"} \SpecialCharTok{\&} 
\NormalTok{         year }\SpecialCharTok{==} \DecValTok{2007}\NormalTok{)}
\FunctionTok{ggplot}\NormalTok{(plotdata, }
       \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ lifeExp, }
           \AttributeTok{y =} \FunctionTok{reorder}\NormalTok{(country, }
\NormalTok{                   lifeExp))) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-393-1.pdf}

\hypertarget{area-chart}{%
\subsection{Area chart}\label{area-chart}}

Ce graphique est intéressant pour représenter des données de composition (autrement dit des variables dont la somme est constante) qui évoluent au cours du temps. Dans l'exemple ci-dessous, on a représenté des parts de marché qui écoluent au cours du temps.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{time\_chart }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{year =} \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{2000}\NormalTok{, }\DecValTok{2005}\NormalTok{, }\DecValTok{2010}\NormalTok{), }\AttributeTok{each =}\DecValTok{3}\NormalTok{),}
  \AttributeTok{market\_share =} \FunctionTok{c}\NormalTok{(}\DecValTok{20}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{30}\NormalTok{,}
                   \DecValTok{30}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{20}\NormalTok{,}
                   \DecValTok{50}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{20}\NormalTok{),}
  \AttributeTok{comp =} \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{), }\DecValTok{3}\NormalTok{)}
\NormalTok{)}

\FunctionTok{ggplot}\NormalTok{(time\_chart, }
  \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ year,}
      \AttributeTok{y =}\NormalTok{ market\_share,}
      \AttributeTok{fill =}\NormalTok{ comp)) }\SpecialCharTok{+}
  \FunctionTok{geom\_area}\NormalTok{(}\AttributeTok{color =} \StringTok{"black"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{"Market share"}\NormalTok{,}
       \AttributeTok{subtitle =} \StringTok{"2000 to 2010"}\NormalTok{,}
       \AttributeTok{x =} \StringTok{"Year"}\NormalTok{,}
       \AttributeTok{y =} \StringTok{"percentage"}\NormalTok{,}
       \AttributeTok{fill =} \StringTok{"Company"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_fill\_brewer}\NormalTok{(}\AttributeTok{palette =} \StringTok{"Set2"}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme\_minimal}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-394-1.pdf}

\hypertarget{correlation-plot}{%
\subsection{Correlation plot}\label{correlation-plot}}

Le graphique de corrélation permet d'apprécier le degré de corrélation entre plusieurs variables. Ce graphique provient du package \textbf{ggcorrplot} et a été profondémment épuré. On en effet, une matrice de corrélation est symétrique et constante sur la diagonale; par conséquent, on ne peut garder que l'information provenant de la partie supérieure (ou inférieure). C'est ce que fait le graphique suivant.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(ggcorrplot)}
\NormalTok{r }\OtherTok{\textless{}{-}} \FunctionTok{cor}\NormalTok{(iris[, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{], }\AttributeTok{use =} \StringTok{"complete.obs"}\NormalTok{)}
\FunctionTok{ggcorrplot}\NormalTok{(r, }
           \AttributeTok{hc.order =} \ConstantTok{TRUE}\NormalTok{, }
           \AttributeTok{type =} \StringTok{"lower"}\NormalTok{,}
           \AttributeTok{lab =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-395-1.pdf}

\hypertarget{repruxe9senter-les-effets-des-variables-explicatives}{%
\subsection{Représenter les effets des variables explicatives}\label{repruxe9senter-les-effets-des-variables-explicatives}}

Dans ce paragraphe, nous allons voir des graphiques qui permettent de réprésenter certaines informations provenant de modèles statistiques.

\hypertarget{ruxe9gression-linuxe9aire}{%
\subsubsection{Régression linéaire}\label{ruxe9gression-linuxe9aire}}

La fonction \emph{visreg()} du package \textbf{visreg} permet de représenter les effets d'une variable explicative sur la variable à expliquer. Pour cela, on représente sur le nuage de points les valeurs prédites avec une doite bleue. On notera que pour calculer les valeurs prédites à partire du modèle estimé, les autres variables du modèle sont prises constantes et égales à la médiane pour les variables quantitatives et au mode pour les variables qualitatives (plus de détails sur : \url{https://journal.r-project.org/archive/2017/RJ-2017-046/RJ-2017-046.pdf}).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(visreg)}
\NormalTok{res\_lm }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(Sepal.Length }\SpecialCharTok{\textasciitilde{}} 
\NormalTok{ Sepal.Width }\SpecialCharTok{+}\NormalTok{ Petal.Width }\SpecialCharTok{+}\NormalTok{ Species,}
 \AttributeTok{data =}\NormalTok{ iris)}
\FunctionTok{visreg}\NormalTok{(res\_lm, }\StringTok{"Sepal.Width"}\NormalTok{,}
       \AttributeTok{gg =} \ConstantTok{TRUE}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-396-1.pdf}

Pour les variables qualitatives, les valeurs prédites sont représentées par des traits bleus sur des diagrames de dispersion conditionnels aux modalités de la variable explicative.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{visreg}\NormalTok{(res\_lm, }\StringTok{"Species"}\NormalTok{,}
       \AttributeTok{gg =} \ConstantTok{TRUE}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-397-1.pdf}

\hypertarget{ruxe9gression-logistique}{%
\subsubsection{Régression logistique}\label{ruxe9gression-logistique}}

Une façon de représenter les résultats d'une régression logistique est de représenter la probabilité que l'événement d'intérêt \(Y=1\) arrive, conditionnelement à une variable explicative. C'est ce que fait la fonction \emph{visreg()} dans un modèle de régression logistique.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris}\SpecialCharTok{$}\NormalTok{binary }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(}\FunctionTok{ifelse}\NormalTok{(iris}\SpecialCharTok{$}\NormalTok{Species }\SpecialCharTok{==} \StringTok{"setosa"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{))}
\NormalTok{res\_glm }\OtherTok{\textless{}{-}} \FunctionTok{glm}\NormalTok{(binary }\SpecialCharTok{\textasciitilde{}} 
\NormalTok{ Sepal.Length,}
 \AttributeTok{family =} \FunctionTok{binomial}\NormalTok{(}\AttributeTok{link =} \StringTok{"logit"}\NormalTok{),}
 \AttributeTok{data =}\NormalTok{ iris)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{visreg}\NormalTok{(res\_glm, }\StringTok{"Sepal.Length"}\NormalTok{, }
       \AttributeTok{gg =} \ConstantTok{TRUE}\NormalTok{, }
       \AttributeTok{scale=}\StringTok{"response"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-399-1.pdf}

\hypertarget{moduxe8le-de-survie}{%
\subsubsection{Modèle de survie}\label{moduxe8le-de-survie}}

Dans un modèle de survie, on peut être intéresser de représenter la fonction estimée de survie en fonction du temps et conditionnellement à une variable qualitative (dans l'exemple ci-dessous le sexe). C'est ce que fait le package \textbf{survminer}. Le package \textbf{survival} permet de faire les estimations du modèle.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(survival)}
\FunctionTok{library}\NormalTok{(survminer)}
\FunctionTok{data}\NormalTok{(lung)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in data(lung): data set 'lung' not found
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sfit }\OtherTok{\textless{}{-}} \FunctionTok{survfit}\NormalTok{(}\FunctionTok{Surv}\NormalTok{(time, status) }\SpecialCharTok{\textasciitilde{}}\NormalTok{  sex, }\AttributeTok{data=}\NormalTok{lung)}
\FunctionTok{ggsurvplot}\NormalTok{(sfit, }
  \AttributeTok{conf.int =} \ConstantTok{TRUE}\NormalTok{, }
  \AttributeTok{pval =} \ConstantTok{TRUE}\NormalTok{,}
  \AttributeTok{legend.labs =} \FunctionTok{c}\NormalTok{(}\StringTok{"M"}\NormalTok{, }\StringTok{"F"}\NormalTok{), }
  \AttributeTok{legend.title =} \StringTok{"Sex"}\NormalTok{,}
  \AttributeTok{palette =} \FunctionTok{c}\NormalTok{(}\StringTok{"cornflowerblue"}\NormalTok{, }\StringTok{"indianred3"}\NormalTok{),}
  \AttributeTok{title =} \StringTok{"Kaplan{-}Meier"}\NormalTok{,}
  \AttributeTok{xlab =} \StringTok{"Time (days)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-400-1.pdf}

\hypertarget{mosaic-plot}{%
\subsection{Mosaic plot}\label{mosaic-plot}}

Le mosaic plot permet de représenter le croisement de modalités de variables qualitatives. Il permet notamment de vérifier quels sont les croisements qui sont en sur ou sous effectifs par rapport à une situation où les deux variables seraient indépendantes.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(vcd)}
\NormalTok{tab }\OtherTok{\textless{}{-}} \FunctionTok{xtabs}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{cut }\SpecialCharTok{+}\NormalTok{ color, diamonds)}
\FunctionTok{mosaic}\NormalTok{(tab, }
       \AttributeTok{shade =} \ConstantTok{TRUE}\NormalTok{,}
       \AttributeTok{legend =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-401-1.pdf}

\textbf{Exercice 4.2}

\begin{itemize}
\item
  Sur les données \textbf{lung} utilisées précédemment, réaliser un ``mosaic plot'' entre les variables \textbf{status} et \textbf{sex}.
\item
  Toujours sur les données \textbf{lung}, réaliser un graphique de type ``ridge plot'' sur la variable variable \textbf{age} en fonction des modalités de la variable \textbf{status}.
\item
  Réaliser un graphique des corrélations sur les variables \textbf{ph.karno}, \textbf{pat.karno}, \textbf{meal.cal}, \textbf{wt.loss} du jeu de données \textbf{lung}.
\end{itemize}

\hypertarget{pruxe9senter-des-tableaux-de-ruxe9sultats}{%
\section{Présenter des tableaux de résultats}\label{pruxe9senter-des-tableaux-de-ruxe9sultats}}

Lorsqu'on présente un tableau de résultats (par exemple les résultats d'une régression) dans un document de type rapport ou présentation, il est préférable de ne pas insérer les sorties de \textbf{R} à l'état brut. D'une part, l'esthétique du format de sortie n'est pas agréable à lire et d'autre part, si on prend par exemple les sorties de la fonction \emph{lm()}, il y a énormément de valeurs qu'on ne prend pas la peine de commenter en général.

Plutôt que de faire du copier/coller des chiffres qui nous intéressent depuis \textbf{R}, il existe un certain nombres de fonctions dans \textbf{R} qui retournent du code, par exemple html ou LaTeX, prêt à être insérer directement dans un document de type html ou LaTeX.

L'utilisation de ce type de fonctions est facilitée dans les fichiers \textbf{R} Markdown. En effet, on peut utiliser l'option \textbf{results = `asis'} dans un chunk pour indiquer que le résultat retourné sera dans le format du document de sortie (soit html si le document final est en html, soit LaTeX si le document final est pdf).

\hypertarget{la-fonction-kable}{%
\subsection{\texorpdfstring{La fonction \(kable()\)}{La fonction kable()}}\label{la-fonction-kable}}

Il s'agit d'une fonction incluse dans le package \textbf{knitr}, qui est le package permettant de compiler des fichiers Sweave ou \textbf{R} Markdown dans plusieurs formats de sortie. Cette fonction s'applique sur des objets de type \textbf{matrix} ou \textbf{data.frame}. Pour l'utiliser dans \textbf{R} Markdown, il suffit de faire :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# \textasciigrave{}\textasciigrave{}\textasciigrave{}\{r, results = \textquotesingle{}asis\textquotesingle{}\}}
\CommentTok{\# knitr::kable(mtcars)}
\CommentTok{\# \textasciigrave{}\textasciigrave{}\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

Ce qui produira le résultat suivant. Ici, on a ajouté l'option \textbf{echo = F} dans le chunk pour ne pas afficher le code \textbf{R} :

mpg

cyl

disp

hp

drat

wt

qsec

vs

am

gear

carb

Mazda RX4

21.0

6

160.0

110

3.90

2.620

16.46

0

1

4

4

Mazda RX4 Wag

21.0

6

160.0

110

3.90

2.875

17.02

0

1

4

4

Datsun 710

22.8

4

108.0

93

3.85

2.320

18.61

1

1

4

1

Hornet 4 Drive

21.4

6

258.0

110

3.08

3.215

19.44

1

0

3

1

Hornet Sportabout

18.7

8

360.0

175

3.15

3.440

17.02

0

0

3

2

Valiant

18.1

6

225.0

105

2.76

3.460

20.22

1

0

3

1

Duster 360

14.3

8

360.0

245

3.21

3.570

15.84

0

0

3

4

Merc 240D

24.4

4

146.7

62

3.69

3.190

20.00

1

0

4

2

Merc 230

22.8

4

140.8

95

3.92

3.150

22.90

1

0

4

2

Merc 280

19.2

6

167.6

123

3.92

3.440

18.30

1

0

4

4

Merc 280C

17.8

6

167.6

123

3.92

3.440

18.90

1

0

4

4

Merc 450SE

16.4

8

275.8

180

3.07

4.070

17.40

0

0

3

3

Merc 450SL

17.3

8

275.8

180

3.07

3.730

17.60

0

0

3

3

Merc 450SLC

15.2

8

275.8

180

3.07

3.780

18.00

0

0

3

3

Cadillac Fleetwood

10.4

8

472.0

205

2.93

5.250

17.98

0

0

3

4

Lincoln Continental

10.4

8

460.0

215

3.00

5.424

17.82

0

0

3

4

Chrysler Imperial

14.7

8

440.0

230

3.23

5.345

17.42

0

0

3

4

Fiat 128

32.4

4

78.7

66

4.08

2.200

19.47

1

1

4

1

Honda Civic

30.4

4

75.7

52

4.93

1.615

18.52

1

1

4

2

Toyota Corolla

33.9

4

71.1

65

4.22

1.835

19.90

1

1

4

1

Toyota Corona

21.5

4

120.1

97

3.70

2.465

20.01

1

0

3

1

Dodge Challenger

15.5

8

318.0

150

2.76

3.520

16.87

0

0

3

2

AMC Javelin

15.2

8

304.0

150

3.15

3.435

17.30

0

0

3

2

Camaro Z28

13.3

8

350.0

245

3.73

3.840

15.41

0

0

3

4

Pontiac Firebird

19.2

8

400.0

175

3.08

3.845

17.05

0

0

3

2

Fiat X1-9

27.3

4

79.0

66

4.08

1.935

18.90

1

1

4

1

Porsche 914-2

26.0

4

120.3

91

4.43

2.140

16.70

0

1

5

2

Lotus Europa

30.4

4

95.1

113

3.77

1.513

16.90

1

1

5

2

Ford Pantera L

15.8

8

351.0

264

4.22

3.170

14.50

0

1

5

4

Ferrari Dino

19.7

6

145.0

175

3.62

2.770

15.50

0

1

5

6

Maserati Bora

15.0

8

301.0

335

3.54

3.570

14.60

0

1

5

8

Volvo 142E

21.4

4

121.0

109

4.11

2.780

18.60

1

1

4

2

Il existe un certain nombre d'options dans la fonction \(kable()\) :

\begin{itemize}
\item
  \textbf{digits=} définit le nombre de chiffres décimales à afficher,
\item
  \textbf{align=} (`r', right, `l', left ou `c', center) indique la position des valeurs à l'intérieur des cellules.
\item
  \textbf{caption=} ajoute une légende.
\end{itemize}

Une amélioration de la fonction \emph{kable()} est la fonction \emph{kbl()} du package \textbf{kableExtra}. Celle ci permet de représenter les valeurs dans un tableau avec des couleurs et/ou des tailles de police différentes. Par ailleurs, en cherchant un peu plus loin, il est également possible d'insérer des images ou des petits graphiques statistiques dans les cellules du tableau (voir la page suivante pour plus d'informations \href{https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html}{lien}.)

On représente ici les 5 premières lignes du jeu de données \textbf{iris}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(kableExtra)}
\NormalTok{vs\_dt }\OtherTok{\textless{}{-}}\NormalTok{ iris[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{, ]}
\NormalTok{vs\_dt[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{] }\OtherTok{\textless{}{-}} \FunctionTok{lapply}\NormalTok{(vs\_dt[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{], }\ControlFlowTok{function}\NormalTok{(x) \{}
    \FunctionTok{cell\_spec}\NormalTok{(x, }\AttributeTok{bold =}\NormalTok{ T, }\AttributeTok{color =} \FunctionTok{spec\_color}\NormalTok{(x, }\AttributeTok{end =} \FloatTok{0.9}\NormalTok{),}
              \AttributeTok{font\_size =} \FunctionTok{spec\_font\_size}\NormalTok{(x))}
\NormalTok{\})}
\NormalTok{vs\_dt[}\DecValTok{5}\NormalTok{] }\OtherTok{\textless{}{-}} \FunctionTok{cell\_spec}\NormalTok{(vs\_dt[[}\DecValTok{5}\NormalTok{]], }\AttributeTok{color =} \StringTok{"white"}\NormalTok{, }\AttributeTok{bold =}\NormalTok{ T,}
    \AttributeTok{background =} \FunctionTok{spec\_color}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{, }\AttributeTok{end =} \FloatTok{0.9}\NormalTok{, }\AttributeTok{option =} \StringTok{"A"}\NormalTok{, }\AttributeTok{direction =} \SpecialCharTok{{-}}\DecValTok{1}\NormalTok{))}
\FunctionTok{kbl}\NormalTok{(vs\_dt, }\AttributeTok{escape =}\NormalTok{ F, }\AttributeTok{align =} \StringTok{"c"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} \FunctionTok{kable\_classic}\NormalTok{(}\StringTok{"striped"}\NormalTok{, }\AttributeTok{full\_width =}\NormalTok{ F)}
\end{Highlighting}
\end{Shaded}

\hypertarget{la-fonction-stargazer}{%
\subsection{\texorpdfstring{La fonction \(stargazer()\)}{La fonction stargazer()}}\label{la-fonction-stargazer}}

La fonction \(stargazer()\) du package \textbf{stargazer} est un plus général que la fonction \emph{kable()} car elle prend en compte non seulement des objets de type \textbf{matrix} et \textbf{data.frame}, mais aussi \textbf{lm}.

On l'utilise ainsi dans un document \textbf{R} Markdown :

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# \textasciigrave{}\textasciigrave{}\textasciigrave{}\{r, results = \textquotesingle{}asis\textquotesingle{}\}}
\CommentTok{\# stargazer::stargazer(attitude)}
\CommentTok{\# \textasciigrave{}\textasciigrave{}\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

\hypertarget{table-de-donnuxe9es-brutes}{%
\subsubsection{Table de données brutes}\label{table-de-donnuxe9es-brutes}}

Pour afficher une table de données brutes, on utilise la fonction \emph{stargazer()}. Parmi les nombreuses options de cette fonction, on en cite ici quelques-unes :

\begin{itemize}
\item
  \textbf{summary=F} signifie que la table doit être représentée à l'état brut (par défaut, la fonction appliquée à un \textbf{data.frame} va faire un résumé statistique du \textbf{data.frame}),
\item
  \textbf{digits=1} indique qu'un seul chiffre après la virgule sera représenté,
\item
  \textbf{type=} indique le format dans lequel la table sera retournée, par exemple \textbf{``latex''} (par défaut) ou \textbf{``html''}.
\item
  \textbf{header=F} précise de ne pas ajouter la date, l'heure, etc. à laquelle la table a été crée,
\item
  \textbf{rownames=F} précise de ne pas afficher le nom des lignes,
\item
  \textbf{title=} permet de donner un titre à la table,
\end{itemize}

Dans \textbf{R} Markdown, on a ajouté dans le chunck l'option \textbf{results = `asis'} pour indiquer que \textbf{R} allait ressortir un résultat qui est dans le format du support de sortie utilisé (que ce soit \emph{html} ou \emph{latex})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stargazer}\SpecialCharTok{::}\FunctionTok{stargazer}\NormalTok{(}\FunctionTok{head}\NormalTok{(iris), }\AttributeTok{summary =}\NormalTok{ F, }\AttributeTok{digits =} \DecValTok{1}\NormalTok{, }\AttributeTok{type =} \StringTok{"html"}\NormalTok{, }
          \AttributeTok{header =}\NormalTok{ F, }\AttributeTok{rownames =}\NormalTok{ F, }\AttributeTok{title =} \StringTok{"Tableau de données"}
\NormalTok{          )}
\end{Highlighting}
\end{Shaded}

Tableau de données

Sepal.Length

Sepal.Width

Petal.Length

Petal.Width

Species

binary

5.1

3.5

1.4

0.2

setosa

1

4.9

3

1.4

0.2

setosa

1

4.7

3.2

1.3

0.2

setosa

1

4.6

3.1

1.5

0.2

setosa

1

5

3.6

1.4

0.2

setosa

1

5.4

3.9

1.7

0.4

setosa

1

\hypertarget{tableau-de-ruxe9sumuxe9}{%
\subsubsection{Tableau de résumé}\label{tableau-de-ruxe9sumuxe9}}

Par défaut, la fonction va créer un tableau de résumé statistique :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stargazer}\SpecialCharTok{::}\FunctionTok{stargazer}\NormalTok{(iris, }\AttributeTok{type =} \StringTok{"html"}\NormalTok{, }\AttributeTok{nobs =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{mean.sd =} \ConstantTok{TRUE}\NormalTok{, }
                     \AttributeTok{median =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{iqr =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{header =}\NormalTok{ F,  }\AttributeTok{title =} \StringTok{"Résumé"}\NormalTok{,}
                     \AttributeTok{digit.separate =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Résumé

Statistic

Mean

St.~Dev.

Min

Pctl(25)

Median

Pctl(75)

Max

Sepal.Length

5.843

0.828

4.300

5.100

5.800

6.400

7.900

Sepal.Width

3.057

0.436

2.000

2.800

3.000

3.300

4.400

Petal.Length

3.758

1.765

1.000

1.600

4.350

5.100

6.900

Petal.Width

1.199

0.762

0.100

0.300

1.300

1.800

2.500

\hypertarget{tableaux-de-ruxe9gression}{%
\subsubsection{Tableaux de régression}\label{tableaux-de-ruxe9gression}}

Un des gros avantages de la fonction \emph{stargazer()} est qu'elle permet de synthétiser des modèles de régression.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{output\_1  }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(Sepal.Length }\SpecialCharTok{\textasciitilde{}}\NormalTok{ Species, }\AttributeTok{data =}\NormalTok{ iris)}
\NormalTok{output\_2  }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(Sepal.Length }\SpecialCharTok{\textasciitilde{}}\NormalTok{ Sepal.Width, }\AttributeTok{data =}\NormalTok{ iris)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stargazer}\SpecialCharTok{::}\FunctionTok{stargazer}\NormalTok{(output\_1, output\_2, }\AttributeTok{type =} \StringTok{"html"}\NormalTok{, }
                     \AttributeTok{title =} \StringTok{"Résultat de régression"}\NormalTok{, }\AttributeTok{header =}\NormalTok{ F)}
\end{Highlighting}
\end{Shaded}

Résultat de régression

Dependent variable:

Sepal.Length

(1)

(2)

Speciesversicolor

0.930***

(0.103)

Speciesvirginica

1.582***

(0.103)

Sepal.Width

-0.223

(0.155)

Constant

5.006***

6.526***

(0.073)

(0.479)

Observations

150

150

R2

0.619

0.014

Adjusted R2

0.614

0.007

Residual Std. Error

0.515 (df = 147)

0.825 (df = 148)

F Statistic

119.265*** (df = 2; 147)

2.074 (df = 1; 148)

Note:

\emph{p\textless0.1; \textbf{p\textless0.05; }}p\textless0.01

Elle permet également de comparer des modèles entre eux. Pour en savoir plus, on pourra consulter le document suivant :

\begin{itemize}
\tightlist
\item
  \url{https://www.jakeruss.com/cheatsheets/stargazer/\#html-formatting}
\end{itemize}

\textbf{Exercice 4.3}

Insérer dans un document Markdown :

\begin{itemize}
\item
  le tableau de corrélation des variables quantitatives du jeu de données \textbf{iris}.
\item
  le tableau de régression du jeu de données \textbf{iris}
\end{itemize}

\hypertarget{graphiques-interactifs}{%
\section{Graphiques interactifs}\label{graphiques-interactifs}}

\hypertarget{via-plotly}{%
\subsection{\texorpdfstring{Via \textbf{plotly}}{Via plotly}}\label{via-plotly}}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(}\StringTok{"plotly"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ici, nous allons présenter quelques exemples d'utilisations du package \textbf{plotly} qui permet de faire des graphiques interactifs en utilisant une interface web via la bibliothèque \href{https://plot.ly/javascript/}{plotly.js} écrite en JavaScript.

Il ne s'agit ici que d'une brève introduction, le lecteur pourra consulter le lien suivant pour plus d'informations :

\begin{itemize}
\tightlist
\item
  \url{https://plot.ly/r/}
\end{itemize}

Lorsqu'on utilise les fonctions de ce package depuis \textbf{RStudio}, la fenêtre graphique qui s'ouvre depuis \textbf{RStudio} rend possible l'interactivité. Cela a pour effet de créer un graphique dans lequel il est possible d'obtenir des informations supplémentaires lorsqu'on place le curseur sur des zones de celui-ci.

De plus, lorsqu'on intègre ce type de graphique dans un document \textbf{R} Markdown, cela garde l'interactivité dans la page html créée.

Son utilisation est la suivante : on appelle la fonction \emph{plot\_ly()} dans lequel :

\begin{itemize}
\item
  le 1er argument est le nom du jeu de données,
\item
  l'argument \textbf{x = \textasciitilde{}} donne le nom de la variable d'intérêt,
\item
  l'argument \textbf{color = \textasciitilde{}} donne le nom d'une variable conditionnelle,
\item
  l'argument \textbf{type =} donne le type de graphique qu'on souhaite représenter.
\end{itemize}

Par exemple, pour une boîte à moustache, on utilise la syntaxe suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{plot\_ly}\NormalTok{(diam\_ech, }\AttributeTok{x =} \SpecialCharTok{\textasciitilde{}}\NormalTok{price, }\AttributeTok{color =} \SpecialCharTok{\textasciitilde{}}\NormalTok{cut, }\AttributeTok{type =} \StringTok{"box"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-415-1.pdf}

;

Pour un nuage de points, on utilise la syntaxe suivante :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{plot\_ly}\NormalTok{(diam\_ech, }\AttributeTok{x =} \SpecialCharTok{\textasciitilde{}}\NormalTok{carat, }\AttributeTok{y =} \SpecialCharTok{\textasciitilde{}}\NormalTok{price, }\AttributeTok{type =} \StringTok{"scatter"}\NormalTok{, }\AttributeTok{mode =} \StringTok{"markers"}\NormalTok{,}
             \AttributeTok{hoverinfo =} \StringTok{\textquotesingle{}text\textquotesingle{}}\NormalTok{,}
             \AttributeTok{text =} \SpecialCharTok{\textasciitilde{}}\FunctionTok{paste}\NormalTok{(}\StringTok{\textquotesingle{}Carat: \textquotesingle{}}\NormalTok{, carat,}
                      \StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\StringTok{ Price: \textquotesingle{}}\NormalTok{, price,}
                      \StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\StringTok{ Clarity: \textquotesingle{}}\NormalTok{, diam\_ech}\SpecialCharTok{$}\NormalTok{clarity),}
             \AttributeTok{color =} \SpecialCharTok{\textasciitilde{}}\NormalTok{carat)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-418-1.pdf}

;

On peut si on le souhaite coupler les graphiques \textbf{ggplot2} avec l'interactivité de \textbf{plotly}. Pour cela, on peut reprendre n'importe lequel des graphiques présentés dans la section précédente et utiliser la fonction \emph{ggplotly()} pour rendre possible l'interaction :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{ggplot}\NormalTok{(diam\_ech) }\SpecialCharTok{+}              
  \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ color, }\AttributeTok{y =}\NormalTok{ price) }\SpecialCharTok{+}  
  \FunctionTok{geom\_boxplot}\NormalTok{() }
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ggplotly}\NormalTok{(p)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-421-1.pdf}

;

Autres packages permettant de faire des graphiques intercatifs :

\begin{itemize}
\item
  \textbf{ggvis} : voir par exemple \url{https://ggvis.rstudio.com/}
\item
  \textbf{rCharts} voir par exemple \url{https://ramnathv.github.io/rCharts/}
\end{itemize}

\hypertarget{via-d3}{%
\subsection{\texorpdfstring{Via \textbf{D3}}{Via D3}}\label{via-d3}}

``D3.js (ou D3 pour Data-Driven Documents) est une bibliothèque graphique \textbf{JavaScript} qui permet l'affichage de données numériques sous une forme graphique et dynamique. Il s'agit d'un outil important pour la conformation aux normes \textbf{W3C} qui utilise les technologies courantes \textbf{SVG}, \textbf{JavaScript} et \textbf{CSS} pour la visualisation de données'' (définition donnée par Wikipedia).

Il existe un certain nombre de packages \textbf{R} qui permettent de créer des graphiques en D3. Parmi ces packages, on nommera \textbf{r2d3} (voir \url{https://rstudio.github.io/r2d3/} pour plus d'informations).

On présente ici un exemple provenant d'un autre package (\textbf{networkD3}), qui permet de représenter des donnéds de flux.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(networkD3)}
\NormalTok{hairColourData }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{11975}\NormalTok{, }\DecValTok{1951}\NormalTok{, }\DecValTok{8010}\NormalTok{, }\DecValTok{1013}\NormalTok{, }\DecValTok{5871}\NormalTok{, }\DecValTok{10048}\NormalTok{, }\DecValTok{16145}\NormalTok{, }\DecValTok{990}\NormalTok{,}
                           \DecValTok{8916}\NormalTok{, }\DecValTok{2060}\NormalTok{, }\DecValTok{8090}\NormalTok{, }\DecValTok{940}\NormalTok{, }\DecValTok{2868}\NormalTok{, }\DecValTok{6171}\NormalTok{, }\DecValTok{8045}\NormalTok{, }\DecValTok{6907}\NormalTok{),}
                         \AttributeTok{nrow =} \DecValTok{4}\NormalTok{)}
\FunctionTok{chordNetwork}\NormalTok{(}\AttributeTok{Data =}\NormalTok{ hairColourData, }\AttributeTok{width =} \DecValTok{500}\NormalTok{, }\AttributeTok{height =} \DecValTok{500}\NormalTok{,}
             \AttributeTok{colourScale =} \FunctionTok{c}\NormalTok{(}\StringTok{"\#000000"}\NormalTok{, }\StringTok{"\#FFDD89"}\NormalTok{, }\StringTok{"\#957244"}\NormalTok{, }\StringTok{"\#F26223"}\NormalTok{),}
             \AttributeTok{labels =} \FunctionTok{c}\NormalTok{(}\StringTok{"red"}\NormalTok{, }\StringTok{"brown"}\NormalTok{, }\StringTok{"blond"}\NormalTok{, }\StringTok{"gray"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-423-1.pdf}

\hypertarget{mini-introduction-uxe0-shiny}{%
\section{\texorpdfstring{Mini-introduction à \textbf{shiny}}{Mini-introduction à shiny}}\label{mini-introduction-uxe0-shiny}}

\textbf{shiny} est un package développé par \textbf{RStudio} qui permet la création de pages web interactives, sans avoir à connaître ni HTML, ni CSS, ni JavaScript.

On renvoit le lecteur vers la page web \textbf{RStudio} (\url{http://shiny.rstudio.com/gallery/}) pour voir des exemples d'applications réalisées avec \textbf{shiny}.

Pour utiliser \textbf{shiny}, cela se fait de manière exrêmement intuitive depuis \textbf{RStudio}.

Cette section s'inspire fortement de la présentation suivante :

\begin{itemize}
\tightlist
\item
  \url{https://www.londonr.org/wp-content/uploads/sites/2/presentations/LondonR_-_Workshop-Introduction_to_Shiny_-_Aimee_Gott_-_20150330.pdf}
\end{itemize}

Le lecteur pourra également consulter cette présentation de Christophe Bontemps (TSE) :

\begin{itemize}
\tightlist
\item
  \url{https://vimeo.com/301596705}
\end{itemize}

\hypertarget{un-premier-exemple}{%
\subsection{Un premier exemple}\label{un-premier-exemple}}

Dans un premier temps, on commence par créer deux fichiers qu'il faudra enregister dans un même répertoire.

\begin{itemize}
\tightlist
\item
  le premier fichier, en général nommé ``ui.R'', va contenir le code qui permet de paraméter la disposition des différents éléments que l'on souhaite afficher dans la page web. Dans l'exemple par défaut, on découpe la page web en deux parties : une partie à gauche qui contient des éléments informatifs (un titre, etc.) ainsi que des paramètres que l'utilisateur pourra éventuellement modifier. La partie à droite contiendra un graphique que l'on souhaite représenter.
\end{itemize}

\begin{figure}
\centering
\includegraphics{Figures/screen_shiny.png}
\caption{Screenshot de shiny}
\end{figure}

\begin{itemize}
\tightlist
\item
  le second fichier, en général nommé ``server.R'' contient le code qui va permettre de constuire le graphique que l'on souhaite représenter dans la partie à droite de l'application. Pour construire ce graphique, on utilisera des paramètres qui ont été définis par l'utilisateur depuis l'interface.
\end{itemize}

L'idée est donc que les deux fichiers dépendent l'un de l'autre. En effet, dès que l'utilisateur va modifier des paramètres sur l'interface, cela va modifier des objets dans le fichier ``ui.R'' ce qui aura pour conséquence d'appeler le fichier ``server.R'' afin de représenter le nouveau graphique qui aura pris en compte la modification effectuée par l'utilisateur.

On va commencer par un exemple simple. Pour cela, depuis \textbf{RStudio}, aller dans ``File'', puis ``New File'', puis ``Shiny web app''. Donner un nom à votre api, laisser les options par défaut et choisir le répertoire dans lequel vous aller sauvegarder vos deux fichiers.

Le fichier ``ui.R'' créé par défaut est celui-ci. Nous avons ajouté ici les commentaires pour expliquer les différentes étapes de création de la page web :

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{library}\ErrorTok{(}\StringTok{"shiny"}\KeywordTok{)}  \CommentTok{\# appel de la libraire "shiny"}

\ExtensionTok{shinyUI}\ErrorTok{(} \CommentTok{\# Création d\textquotesingle{}une application}
 \ExtensionTok{fluidPage}\ErrorTok{(} \CommentTok{\# mise en page shiny standard qui permet d\textquotesingle{}adapter l\textquotesingle{}interface}
            \CommentTok{\# au navigateur utilisé}
            
  \ExtensionTok{titlePanel}\ErrorTok{(}\StringTok{"Old Faithful Geyser Data"}\KeywordTok{)}\ExtensionTok{,} \CommentTok{\# titre de l\textquotesingle{}appli}
  
   \ExtensionTok{sidebarLayout}\ErrorTok{(}  \CommentTok{\# fonction qui spécifie quelles sont les différentes parties  }
                   \CommentTok{\# de la page web. Ici, il y en aura 2 :}
                   \CommentTok{\# {-} une partie à gauche (sidebarPanel)}
                   \CommentTok{\# {-} une partie à droite (mainPanel)}
                   
    \ExtensionTok{sidebarPanel}\ErrorTok{(}  \CommentTok{\# {-} la partie à gauche sera une zone grisée qui  }
                   \CommentTok{\# peut contenir différentes choses (texte, réglette, etc.)}
                   \CommentTok{\# Ici, il y aura une réglette (fonction sliderInput()):}
       \ExtensionTok{sliderInput}\ErrorTok{(}\StringTok{"bins"}\ExtensionTok{,} \CommentTok{\# le 1er argument est le nom du paramètre dont  }
                           \CommentTok{\# la valeur vaut ce que l\textquotesingle{}utilisateur choisit }
                           \CommentTok{\# depuis l\textquotesingle{}interface. Cette valeur pourra être }
                           \CommentTok{\# utilisée depuis le fichier "server.R"}
                   \StringTok{"Number of bins:"}\ExtensionTok{,}   \CommentTok{\# le titre de la réglette}
                   \ExtensionTok{min}\NormalTok{ = 1,             }\CommentTok{\# la valeur minimum de la réglette}
                   \ExtensionTok{max}\NormalTok{ = 50,            }\CommentTok{\# la valeur maximum de la réglette}
                   \ExtensionTok{value}\NormalTok{ = 30}\KeywordTok{)}          \CommentTok{\# la valeur par défaut de "bins"}
    \KeywordTok{)}\ExtensionTok{,}
    
    \ExtensionTok{mainPanel}\ErrorTok{(} \CommentTok{\# la partie à droite est la zone principale de la page web }
       \ExtensionTok{plotOutput}\ErrorTok{(}\StringTok{"distPlot"}\KeywordTok{)} \CommentTok{\# elle contiendra un graphique dont le nom est }
                              \CommentTok{\# distPlot et qui sera défini depuis le fichier}
                              \CommentTok{\# "server.R"}
    \KeywordTok{)}
  \KeywordTok{)}
\KeywordTok{))}
\end{Highlighting}
\end{Shaded}

Le fichier ``server.R'' créé par défaut est celui-ci :

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{library}\ErrorTok{(}\StringTok{"shiny"}\KeywordTok{)}   \CommentTok{\# appel de la libraire "shiny"}

\ExtensionTok{shinyServer}\ErrorTok{(} \CommentTok{\# ouvre la connection web et va autoriser le partage d\textquotesingle{}infos }
             \CommentTok{\# entre les fichiers "ui.R" et "server.R" }
 \KeywordTok{function(}\ExtensionTok{input,}\NormalTok{ output}\KeywordTok{)} \KeywordTok{\{} \CommentTok{\# {-} input : contient l\textquotesingle{}environnement produit par}
                           \CommentTok{\# "ui.R"}
                           \CommentTok{\# {-} output contient l\textquotesingle{}environnement produit par}
                           \CommentTok{\# "server.R"}
  \ExtensionTok{output}\VariableTok{$distPlot} \OperatorTok{\textless{}}\NormalTok{{-} renderPlot}\ErrorTok{(}\KeywordTok{\{} \CommentTok{\# on crée dans l\textquotesingle{}environnement output un }
                                  \CommentTok{\# graphique appelé distPlot}

    \ExtensionTok{x}    \OperatorTok{\textless{}}\NormalTok{{-} faithful[, 2]  }\CommentTok{\# données à représenter}
    \CommentTok{\# on crée les classes de l\textquotesingle{}histogramme en utilisant l\textquotesingle{}information bins }
    \CommentTok{\# provenant de l\textquotesingle{}environnement "input"}
    \ExtensionTok{bins} \OperatorTok{\textless{}}\NormalTok{{-} seq}\ErrorTok{(}\ExtensionTok{min}\ErrorTok{(}\ExtensionTok{x}\KeywordTok{)}\ExtensionTok{,}\NormalTok{ max}\ErrorTok{(}\ExtensionTok{x}\KeywordTok{)}\ExtensionTok{,}\NormalTok{ length.out = input}\VariableTok{$bins}\NormalTok{ + 1}\KeywordTok{)} 
    
    \CommentTok{\# on représente l\textquotesingle{}histogramme}
    \ExtensionTok{hist}\ErrorTok{(}\ExtensionTok{x,}\NormalTok{ breaks = bins, col = }\StringTok{\textquotesingle{}darkgray\textquotesingle{}}\NormalTok{, border = }\StringTok{\textquotesingle{}white\textquotesingle{}}\KeywordTok{)}
    
  \ExtensionTok{\}}\ErrorTok{)}
  
\ExtensionTok{\}}\ErrorTok{)}
\end{Highlighting}
\end{Shaded}

Depuis \textbf{RStudio}, lorsque vous avez ouvert l'un des deux fichiers ``ui.R'' ou ``server.R'' il est possible de lancer l'application en cliquant sur le bouton ``Run App''. Cela a pour effet d'ouvrir une fenêtre \emph{html} depuis \textbf{RStudio} où apparaît d'une part sur la gauche l'interface (codée dans le fichier ``ui.R'') et sur la droite le graphique (codé dans le fichier ``server.R''). Dans cet exemple, lorsqu'on bouge le curseur de la réglette, cela a pour effet de modifier le graphique automatiquement.

\textbf{Remarque :} tant que vous n'aurez pas fermé la fenêtre \emph{html}, vous n'aurez pas la main sur la console \textbf{R} de \textbf{RStudio}.

\hypertarget{quelques-fonctionnalituxe9s-de-shiny}{%
\subsection{\texorpdfstring{Quelques fonctionnalités de \textbf{shiny}}{Quelques fonctionnalités de shiny}}\label{quelques-fonctionnalituxe9s-de-shiny}}

\hypertarget{dans-la-partie-de-gauche}{%
\subsubsection{Dans la partie de gauche}\label{dans-la-partie-de-gauche}}

Dans l'exemple ci-dessus, nous avons seulement inséré une réglette dans la partie \emph{sidebarPanel()}. On aurait pu ajouter d'autre types d'outils très intéressants en utilisant une des fonctions ci-dessous :

\begin{itemize}
\tightlist
\item
  \emph{textInput()} : saisie d'une chaîne de caractères,
\item
  \emph{numericInput()} : saisie d'une valeur numérique,
\item
  \emph{selectInput()} : choix parmi une ou plusieurs valeurs sous forme de liste déroulante,
\item
  \emph{sliderInput()} : réglette de valeurs numériques,
\item
  \emph{radioButtons()} : choix de valeurs avec des boutons,
\item
  \emph{fileInput()} : choisir un fichier (en général de données).
\end{itemize}

\hypertarget{dans-la-partie-de-droite}{%
\subsubsection{Dans la partie de droite}\label{dans-la-partie-de-droite}}

Dans l'exemple ci-dessus, nous avons affiché dans la partie de droite seulement un graphique. Pour cela nous avons utilisé la fonction \emph{renderPlot()} depuis le fichier ``server.R'' et \emph{plotOutput()} depuis le fichier ``ui.R''. On peut également affiché :

\begin{itemize}
\tightlist
\item
  du texte : on utilisera la fonction \emph{renderPrint()} depuis le fichier ``server.R'' et \emph{textOutput()} depuis le fichier ``ui.R''
\item
  des tables de données : on utilisera la fonction \emph{renderDataTable()} depuis le fichier ``server.R'' et \emph{dataTableOutput()} depuis le fichier ``ui.R''
\item
  des images : on utilisera la fonction \emph{renderImage()} depuis le fichier ``server.R'' et \emph{imageOutput()} depuis le fichier ``ui.R''
\end{itemize}

\hypertarget{publier-ses-applications}{%
\subsection{Publier ses applications}\label{publier-ses-applications}}

Une fois vos applications développées en local, il est possible de les rendre accessible à tous grâce aux serveurs de chez \textbf{RStudio} qui propose des offres d'hébergement. La première offre est gratuite au-dessous d'un certain nombre d'applications et temps d'utilisation. Pour plus d'informations, consulter : \url{https://www.rstudio.com/products/shiny/shiny-server/}

Générer des documents de sortie : \url{https://stackoverflow.com/questions/66237085/generating-downloadable-reports-from-shiny-app}

\hypertarget{hello-bookdown}{%
\chapter{Hello bookdown}\label{hello-bookdown}}

All chapters start with a first-level heading followed by your chapter title, like the line above. There should be only one first-level heading (\texttt{\#}) per .Rmd file.

\hypertarget{a-section}{%
\section{A section}\label{a-section}}

All chapter sections start with a second-level (\texttt{\#\#}) or higher heading followed by your section title, like the sections above and below here. You can have as many as you want within a chapter.

\hypertarget{an-unnumbered-section}{%
\subsection*{An unnumbered section}\label{an-unnumbered-section}}
\addcontentsline{toc}{subsection}{An unnumbered section}

Chapters and sections are numbered by default. To un-number a heading, add a \texttt{\{.unnumbered\}} or the shorter \texttt{\{-\}} at the end of the heading, like in this section.

\hypertarget{cross}{%
\chapter{Cross-references}\label{cross}}

Cross-references make it easier for your readers to find and link to elements in your book.

\hypertarget{chapters-and-sub-chapters}{%
\section{Chapters and sub-chapters}\label{chapters-and-sub-chapters}}

There are two steps to cross-reference any heading:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Label the heading: \texttt{\#\ Hello\ world\ \{\#nice-label\}}.

  \begin{itemize}
  \tightlist
  \item
    Leave the label off if you like the automated heading generated based on your heading title: for example, \texttt{\#\ Hello\ world} = \texttt{\#\ Hello\ world\ \{\#hello-world\}}.
  \item
    To label an un-numbered heading, use: \texttt{\#\ Hello\ world\ \{-\#nice-label\}} or \texttt{\{\#\ Hello\ world\ .unnumbered\}}.
  \end{itemize}
\item
  Next, reference the labeled heading anywhere in the text using \texttt{\textbackslash{}@ref(nice-label)}; for example, please see Chapter \ref{cross}.

  \begin{itemize}
  \tightlist
  \item
    If you prefer text as the link instead of a numbered reference use: \protect\hyperlink{cross}{any text you want can go here}.
  \end{itemize}
\end{enumerate}

\hypertarget{captioned-figures-and-tables}{%
\section{Captioned figures and tables}\label{captioned-figures-and-tables}}

Figures and tables \emph{with captions} can also be cross-referenced from elsewhere in your book using \texttt{\textbackslash{}@ref(fig:chunk-label)} and \texttt{\textbackslash{}@ref(tab:chunk-label)}, respectively.

See Figure \ref{fig:nice-fig}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(}\AttributeTok{mar =} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{, .}\DecValTok{1}\NormalTok{, .}\DecValTok{1}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(pressure, }\AttributeTok{type =} \StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\AttributeTok{pch =} \DecValTok{19}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{_main_files/figure-latex/nice-fig-1} 

}

\caption{Here is a nice figure!}\label{fig:nice-fig}
\end{figure}

Don't miss Table \ref{tab:nice-tab}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{knitr}\SpecialCharTok{::}\FunctionTok{kable}\NormalTok{(}
  \FunctionTok{head}\NormalTok{(pressure, }\DecValTok{10}\NormalTok{), }\AttributeTok{caption =} \StringTok{\textquotesingle{}Here is a nice table!\textquotesingle{}}\NormalTok{,}
  \AttributeTok{booktabs =} \ConstantTok{TRUE}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{table}

\caption{\label{tab:nice-tab}Here is a nice table!}
\centering
\begin{tabular}[t]{rr}
\toprule
temperature & pressure\\
\midrule
0 & 0.0002\\
20 & 0.0012\\
40 & 0.0060\\
60 & 0.0300\\
80 & 0.0900\\
\addlinespace
100 & 0.2700\\
120 & 0.7500\\
140 & 1.8500\\
160 & 4.2000\\
180 & 8.8000\\
\bottomrule
\end{tabular}
\end{table}

\hypertarget{parts}{%
\chapter{Parts}\label{parts}}

You can add parts to organize one or more book chapters together. Parts can be inserted at the top of an .Rmd file, before the first-level chapter heading in that same file.

Add a numbered part: \texttt{\#\ (PART)\ Act\ one\ \{-\}} (followed by \texttt{\#\ A\ chapter})

Add an unnumbered part: \texttt{\#\ (PART\textbackslash{}*)\ Act\ one\ \{-\}} (followed by \texttt{\#\ A\ chapter})

Add an appendix as a special kind of un-numbered part: \texttt{\#\ (APPENDIX)\ Other\ stuff\ \{-\}} (followed by \texttt{\#\ A\ chapter}). Chapters in an appendix are prepended with letters instead of numbers.

\hypertarget{footnotes-and-citations}{%
\chapter{Footnotes and citations}\label{footnotes-and-citations}}

\hypertarget{footnotes}{%
\section{Footnotes}\label{footnotes}}

Footnotes are put inside the square brackets after a caret \texttt{\^{}{[}{]}}. Like this one \footnote{This is a footnote.}.

\hypertarget{citations}{%
\section{Citations}\label{citations}}

Reference items in your bibliography file(s) using \texttt{@key}.

For example, we are using the \textbf{bookdown} package \citep{R-bookdown} (check out the last code chunk in index.Rmd to see how this citation key was added) in this sample book, which was built on top of R Markdown and \textbf{knitr} \citep{xie2015} (this citation was added manually in an external file book.bib).
Note that the \texttt{.bib} files need to be listed in the index.Rmd with the YAML \texttt{bibliography} key.

The RStudio Visual Markdown Editor can also make it easier to insert citations: \url{https://rstudio.github.io/visual-markdown-editing/\#/citations}

\hypertarget{blocks}{%
\chapter{Blocks}\label{blocks}}

\hypertarget{equations}{%
\section{Equations}\label{equations}}

Here is an equation.

\begin{equation} 
  f\left(k\right) = \binom{n}{k} p^k\left(1-p\right)^{n-k}
  \label{eq:binom}
\end{equation}

You may refer to using \texttt{\textbackslash{}@ref(eq:binom)}, like see Equation \eqref{eq:binom}.

\hypertarget{theorems-and-proofs}{%
\section{Theorems and proofs}\label{theorems-and-proofs}}

Labeled theorems can be referenced in text using \texttt{\textbackslash{}@ref(thm:tri)}, for example, check out this smart theorem \ref{thm:tri}.

\begin{theorem}
\protect\hypertarget{thm:tri}{}\label{thm:tri}For a right triangle, if \(c\) denotes the \emph{length} of the hypotenuse
and \(a\) and \(b\) denote the lengths of the \textbf{other} two sides, we have
\[a^2 + b^2 = c^2\]
\end{theorem}

Read more here \url{https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html}.

\hypertarget{callout-blocks}{%
\section{Callout blocks}\label{callout-blocks}}

The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: \url{https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html}

\hypertarget{sharing-your-book}{%
\chapter{Sharing your book}\label{sharing-your-book}}

\hypertarget{publishing}{%
\section{Publishing}\label{publishing}}

HTML books can be published online, see: \url{https://bookdown.org/yihui/bookdown/publishing.html}

\hypertarget{pages}{%
\section{404 pages}\label{pages}}

By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you'd like to customize your 404 page instead of using the default, you may add either a \texttt{\_404.Rmd} or \texttt{\_404.md} file to your project root and use code and/or Markdown syntax.

\hypertarget{metadata-for-sharing}{%
\section{Metadata for sharing}\label{metadata-for-sharing}}

Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the \texttt{index.Rmd} YAML. To setup, set the \texttt{url} for your book and the path to your \texttt{cover-image} file. Your book's \texttt{title} and \texttt{description} are also used.

This \texttt{gitbook} uses the same social sharing data across all chapters in your book- all links shared will look the same.

Specify your book's source repository on GitHub using the \texttt{edit} key under the configuration options in the \texttt{\_output.yml} file, which allows users to suggest an edit by linking to a chapter's source file.

Read more about the features of this output format here:

\url{https://pkgs.rstudio.com/bookdown/reference/gitbook.html}

Or use:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?bookdown}\SpecialCharTok{::}\NormalTok{gitbook}
\end{Highlighting}
\end{Shaded}


  \bibliography{book.bib,packages.bib}

\end{document}
